<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="排序算法[转载]"><meta name="keywords" content="算法与数据结构"><meta name="author" content="琅琊旻"><meta name="copyright" content="琅琊旻"><title>排序算法[转载] | 琅琊旻</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-1150529212462758',
  enable_page_level_ads: 'true'
});
</script><link rel="dns-prefetch" href="http://ta.qq.com"><script>(function() {
   var hm = document.createElement("script");
   hm.src = "https://tajs.qq.com/stats?sId=66535930";
   var s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(hm, s);
 })();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text"> 1、基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text"> 2、排序算法的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text"> 算法分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.</span> <span class="toc-text"> 算法总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text"> 3、冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text"> （1）冒泡排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text"> （2）冒泡排序的原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA"><span class="toc-number">3.3.</span> <span class="toc-text"> （3）动图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">3.4.</span> <span class="toc-text"> （4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text"> 4、选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.</span> <span class="toc-text"> （1）选择排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text"> （2）选择排序的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BA"><span class="toc-number">4.3.</span> <span class="toc-text"> （3）动态图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-2"><span class="toc-number">4.4.</span> <span class="toc-text"> （4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">5.</span> <span class="toc-text"> 5、插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.1.</span> <span class="toc-text"> （1）插入排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text"> （2）插入排序的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BA-2"><span class="toc-number">5.3.</span> <span class="toc-text"> （3）动态图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-3"><span class="toc-number">5.4.</span> <span class="toc-text"> （4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text"> 6、归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.1.</span> <span class="toc-text"> （1）归并排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text"> （2）归并排序的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BA-3"><span class="toc-number">6.3.</span> <span class="toc-text"> （3）动态图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-4"><span class="toc-number">6.4.</span> <span class="toc-text"> （4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text"> 7、快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.1.</span> <span class="toc-text"> （1）快速排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">7.2.</span> <span class="toc-text"> （2）快速排序的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BA-4"><span class="toc-number">7.3.</span> <span class="toc-text"> （3）动态图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-5"><span class="toc-number">7.4.</span> <span class="toc-text"> （4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text"> 8、希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.1.</span> <span class="toc-text"> （1）希尔排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">8.2.</span> <span class="toc-text"> （2）希尔排序的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BA-5"><span class="toc-number">8.3.</span> <span class="toc-text"> （3）动态图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-6"><span class="toc-number">8.4.</span> <span class="toc-text"> （4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">9.</span> <span class="toc-text"> 9、计数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.1.</span> <span class="toc-text"> （1）计数排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">9.2.</span> <span class="toc-text"> （2）计数排序的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BA-6"><span class="toc-number">9.3.</span> <span class="toc-text"> （3）动态图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-7"><span class="toc-number">9.4.</span> <span class="toc-text"> （4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">10.</span> <span class="toc-text"> 10、桶排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%A1%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">10.1.</span> <span class="toc-text"> （1）桶排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%A1%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">10.2.</span> <span class="toc-text"> （2）桶排序的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BA-7"><span class="toc-number">10.3.</span> <span class="toc-text"> （3）动态图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-8"><span class="toc-number">10.4.</span> <span class="toc-text"> （4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">11.</span> <span class="toc-text"> 11、基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">11.1.</span> <span class="toc-text"> （1）基数排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">11.2.</span> <span class="toc-text"> （2）基数排序的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BA-8"><span class="toc-number">11.3.</span> <span class="toc-text"> （3）动态图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-9"><span class="toc-number">11.4.</span> <span class="toc-text"> （4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">12.</span> <span class="toc-text"> 12、堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">12.1.</span> <span class="toc-text"> （1）堆排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">12.2.</span> <span class="toc-text"> （2）堆排序的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BA-9"><span class="toc-number">12.3.</span> <span class="toc-text"> （3）动态图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-10"><span class="toc-number">12.4.</span> <span class="toc-text"> （4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93"><span class="toc-number">13.</span> <span class="toc-text"> 最后总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://blogimage.lemonlife.top/201910302316_962.jpg"></div><div class="author-info__name text-center">琅琊旻</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/wmwgithub">GitHub关注</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">41</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">19</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.dzou.top">Dzou's Blog</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://boyn.top">Boyn</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://www.parak.top/">ParaK</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://luo-xi.xyz/">洛臣心</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.uchihakakashi.top/">Uchkks's Blog</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://crassulalactea.github.io/">Crassula</a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">琅琊旻</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">类别</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">排序算法[转载]</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-27</time></div><div class="article-container" id="post-content"><h3 id="1-基本介绍"><a class="markdownIt-Anchor" href="#1-基本介绍"></a> 1、基本介绍</h3>
<p>​		排序算法比较基础，但是设计到很多计算机科学的想法，如下：</p>
<p>​			1、比较和非比较的策略</p>
<p>​			2、迭代和递归的实现</p>
<p>​			3、分而治之思想</p>
<p>​			4、最佳、最差、平均情况时间复杂度分析</p>
<p>​			5、随机算法</p>
<h3 id="2-排序算法的分类"><a class="markdownIt-Anchor" href="#2-排序算法的分类"></a> 2、排序算法的分类</h3>
<h4 id="算法分类"><a class="markdownIt-Anchor" href="#算法分类"></a> 算法分类</h4>
<p><img src="http://blogimage.lemonlife.top/201909181100_29.jpg?/" alt="" /></p>
<h4 id="算法总结"><a class="markdownIt-Anchor" href="#算法总结"></a> 算法总结</h4>
<p><img src="http://blogimage.lemonlife.top/201909181101_243.jpg?/" alt="" /></p>
<h3 id="3-冒泡排序"><a class="markdownIt-Anchor" href="#3-冒泡排序"></a> 3、冒泡排序</h3>
<h4 id="1冒泡排序的介绍"><a class="markdownIt-Anchor" href="#1冒泡排序的介绍"></a> （1）冒泡排序的介绍</h4>
<p>​		冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<h4 id="2冒泡排序的原理"><a class="markdownIt-Anchor" href="#2冒泡排序的原理"></a> （2）冒泡排序的原理：</h4>
<p>​		1、如果元素大小关系不正确，交换这两个数（在本例中为a&gt; b），</p>
<p>​		2、比较一对相邻元素（a，b），</p>
<p>​		3、重复步骤1和2，直到我们到达数组的末尾（最后一对是第（N-2）和（N-1）项，因为我们的数组从零开始）</p>
<p>​		4、到目前为止，最大的元素将在最后的位置。 然后我们将N减少1，并重复步骤1，直到N = 1。</p>
<h4 id="3动图演示"><a class="markdownIt-Anchor" href="#3动图演示"></a> （3）动图演示</h4>
<p><img src="http://blogimage.lemonlife.top/201909181101_1.jpg?/" alt="" /></p>
<h4 id="4代码演示"><a class="markdownIt-Anchor" href="#4代码演示"></a> （4）代码演示</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> array[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    t = array[j];</span><br><span class="line">                    array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>JavaScript实现</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">method(arr: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">        [arr[i], arr[j]] = [arr[j], arr[i]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-选择排序"><a class="markdownIt-Anchor" href="#4-选择排序"></a> 4、选择排序</h3>
<h4 id="1选择排序的介绍"><a class="markdownIt-Anchor" href="#1选择排序的介绍"></a> （1）选择排序的介绍</h4>
<p>​		选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h4 id="2选择排序的原理"><a class="markdownIt-Anchor" href="#2选择排序的原理"></a> （2）选择排序的原理</h4>
<p>​		1、在 <strong>[L … N-1]</strong> 范围内找出最小项目 <strong>X</strong> 的位置，</p>
<p>​		2、用第 <strong>L</strong> 项交换X，</p>
<p>​		3、将下限 <strong>L</strong> 增加1并重复步骤1直到 <strong>L = N-2</strong>。</p>
<h4 id="3动态图演示"><a class="markdownIt-Anchor" href="#3动态图演示"></a> （3）动态图演示</h4>
<p><img src="http://blogimage.lemonlife.top/201909181102_996.jpg?/" alt="" /></p>
<h4 id="4代码演示-2"><a class="markdownIt-Anchor" href="#4代码演示-2"></a> （4）代码演示</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; array[index]) </span><br><span class="line">                    index = j; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = array[index];</span><br><span class="line">            array[index] = array[i];</span><br><span class="line">            array[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>JavaScript实现</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">method(arr: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> min = arr[i], minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (min &gt; arr[j]) &#123;</span><br><span class="line">        <span class="comment">// 每轮循环都获取到最小值</span></span><br><span class="line">        min = arr[j]</span><br><span class="line">        minIndex = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定最小值之后 再进行交换</span></span><br><span class="line">    arr[minIndex] = arr[i]</span><br><span class="line">    arr[i] = min</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-插入排序"><a class="markdownIt-Anchor" href="#5-插入排序"></a> 5、插入排序</h3>
<h4 id="1插入排序的介绍"><a class="markdownIt-Anchor" href="#1插入排序的介绍"></a> （1）插入排序的介绍</h4>
<p>​		插入排序（Insertion sort）是一种简单直观且稳定的排序算法。如果有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p>
<h4 id="2插入排序的原理"><a class="markdownIt-Anchor" href="#2插入排序的原理"></a> （2）插入排序的原理</h4>
<p>​		1、从第一个元素开始，该元素可以认为已经被排序；</p>
<p>​		2、取出下一个元素，在已经排序的元素序列中从后向前扫描；</p>
<p>​		3、如果该元素（已排序）大于新元素，将该元素移到下一位置；</p>
<p>​		4、重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</p>
<p>​		5、将新元素插入到该位置后；</p>
<p>​		6、重复步骤2~5。</p>
<h4 id="3动态图演示-2"><a class="markdownIt-Anchor" href="#3动态图演示-2"></a> （3）动态图演示</h4>
<p><img src="http://blogimage.lemonlife.top/201909181102_303.jpg?/" alt="插入排序" /></p>
<h4 id="4代码演示-3"><a class="markdownIt-Anchor" href="#4代码演示-3"></a> （4）代码演示</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> current;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            current = array[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> preIndex = i;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; current &lt; array[preIndex]) &#123;</span><br><span class="line">                array[preIndex + <span class="number">1</span>] = array[preIndex];</span><br><span class="line">                preIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript代码实现</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">method(arr: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">let</span> resArr = [arr[<span class="number">0</span>]]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> insertIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (insertIndex &lt; resArr.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (resArr[insertIndex] &lt; arr[i]) &#123;</span><br><span class="line">        insertIndex++</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resArr.splice(insertIndex, <span class="number">0</span>, arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-归并排序"><a class="markdownIt-Anchor" href="#6-归并排序"></a> 6、归并排序</h3>
<h4 id="1归并排序的介绍"><a class="markdownIt-Anchor" href="#1归并排序的介绍"></a> （1）归并排序的介绍</h4>
<p>​		归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<h4 id="2归并排序的原理"><a class="markdownIt-Anchor" href="#2归并排序的原理"></a> （2）归并排序的原理</h4>
<p>​		1、将每对单个元素（默认情况下，已排序）归并为2个元素的有序数组，</p>
<p>​		2、将2个元素的每对有序数组归并成4个元素的有序数组，重复这个过程…，</p>
<p>​		3、最后一步：归并2个N / 2元素的排序数组（为了简化讨论，我们假设N是偶数）以获得完全排序的N个元素数组。</p>
<h4 id="3动态图演示-3"><a class="markdownIt-Anchor" href="#3动态图演示-3"></a> （3）动态图演示</h4>
<p><img src="http://blogimage.lemonlife.top/201909181103_140.jpg?/" alt="" /></p>
<h4 id="4代码演示-4"><a class="markdownIt-Anchor" href="#4代码演示-4"></a> （4）代码演示</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] MergeSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">       <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> array;</span><br><span class="line">       <span class="keyword">int</span> mid = array.length / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">int</span>[] left = Arrays.copyOfRange(array, <span class="number">0</span>, mid);</span><br><span class="line">       <span class="keyword">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class="line">       <span class="keyword">return</span> merge(MergeSort(left), MergeSort(right));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line">       <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>; index &lt; result.length; index++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i &gt;= left.length)</span><br><span class="line">               result[index] = right[j++];</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= right.length)</span><br><span class="line">               result[index] = left[i++];</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (left[i] &gt; right[j])</span><br><span class="line">               result[index] = right[j++];</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               result[index] = left[i++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-快速排序"><a class="markdownIt-Anchor" href="#7-快速排序"></a> 7、快速排序</h3>
<h4 id="1快速排序的介绍"><a class="markdownIt-Anchor" href="#1快速排序的介绍"></a> （1）快速排序的介绍</h4>
<p>​		快速排序（Quicksort）是对冒泡排序的一种改进。</p>
<p>​		它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<h4 id="2快速排序的原理"><a class="markdownIt-Anchor" href="#2快速排序的原理"></a> （2）快速排序的原理</h4>
<p>​		1、从数列中挑出一个元素，称为 “基准”（pivot）；<br />
​		2、重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br />
​		3、递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<h4 id="3动态图演示-4"><a class="markdownIt-Anchor" href="#3动态图演示-4"></a> （3）动态图演示</h4>
<p><img src="http://blogimage.lemonlife.top/201909181103_889.jpg?/" alt="" /></p>
<h4 id="4代码演示-5"><a class="markdownIt-Anchor" href="#4代码演示-5"></a> （4）代码演示</h4>
<p><strong>Java</strong>  实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] QuickSort(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length &lt; <span class="number">1</span> || start &lt; <span class="number">0</span> || end &gt;= array.length || start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> smallIndex = partition(array, start, end);</span><br><span class="line">        <span class="keyword">if</span> (smallIndex &gt; start)</span><br><span class="line">            QuickSort(array, start, smallIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (smallIndex &lt; end)</span><br><span class="line">            QuickSort(array, smallIndex + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序算法——partition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = (<span class="keyword">int</span>) (start + Math.random() * (end - start + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> smallIndex = start - <span class="number">1</span>;</span><br><span class="line">        swap(array, pivot, end);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt;= array[end]) &#123;</span><br><span class="line">                smallIndex++;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; smallIndex)</span><br><span class="line">                    swap(array, i, smallIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> smallIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换数组内两个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>JavaScript实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr: any[], left: number, right: number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> l = left <span class="comment">// 左索引</span></span><br><span class="line">    <span class="keyword">let</span> r = right <span class="comment">// 右索引</span></span><br><span class="line">    <span class="keyword">let</span> pivot = arr[<span class="built_in">Math</span>.floor((l + r) / <span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="comment">//中线 在左边找 到一个比中间值大的值</span></span><br><span class="line">    <span class="keyword">while</span> (arr[l] &lt; pivot) &#123;</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在中线右边找 比中间值小到值</span></span><br><span class="line">    <span class="keyword">while</span> (arr[r] &gt; pivot) &#123;</span><br><span class="line">        r -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="comment">// 说明 左边都是比中值小的值 ，右边都是比中值大的值</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// l&lt;r的时候交换 索引 l,r 对应的值</span></span><br><span class="line">    [arr[l], arr[r]] = [arr[r], arr[l]]</span><br><span class="line">    <span class="keyword">if</span> (arr[l] == pivot || arr[r] == pivot) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line">        r -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; r) &#123;</span><br><span class="line">        quickSort(arr, left, r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt; l) &#123;</span><br><span class="line">        quickSort(arr, l, right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-希尔排序"><a class="markdownIt-Anchor" href="#8-希尔排序"></a> 8、希尔排序</h3>
<h4 id="1希尔排序的介绍"><a class="markdownIt-Anchor" href="#1希尔排序的介绍"></a> （1）希尔排序的介绍</h4>
<p>​		希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。</p>
<p>​		希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h4 id="2希尔排序的原理"><a class="markdownIt-Anchor" href="#2希尔排序的原理"></a> （2）希尔排序的原理</h4>
<p>​		1、选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；<br />
​		2、按增量序列个数k，对序列进行k 趟排序；<br />
​		3、每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<h4 id="3动态图演示-5"><a class="markdownIt-Anchor" href="#3动态图演示-5"></a> （3）动态图演示</h4>
<p><img src="http://blogimage.lemonlife.top/201909181103_203.jpg?/" alt="" /></p>
<h4 id="4代码演示-6"><a class="markdownIt-Anchor" href="#4代码演示-6"></a> （4）代码演示</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 希尔排序</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ShellSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">       <span class="keyword">int</span> len = array.length;</span><br><span class="line">       <span class="keyword">int</span> temp, gap = len / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">               temp = array[i];</span><br><span class="line">               <span class="keyword">int</span> preIndex = i - gap;</span><br><span class="line">               <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; array[preIndex] &gt; temp) &#123;</span><br><span class="line">                   array[preIndex + gap] = array[preIndex];</span><br><span class="line">                   preIndex -= gap;</span><br><span class="line">               &#125;</span><br><span class="line">               array[preIndex + gap] = temp;</span><br><span class="line">           &#125;</span><br><span class="line">           gap /= <span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> array;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript 实现希尔排序的交换模式,因为交换很耗时</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">method(arr: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">    <span class="keyword">let</span> offSet = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> (offSet &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= arr.length - offSet; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; arr.length - offSet; j += offSet) &#123;</span><br><span class="line">          <span class="keyword">if</span> (arr[j] &gt; arr[j + offSet]) &#123;</span><br><span class="line">            [arr[j], arr[j + offSet]] = [arr[j + offSet], arr[j]]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      offSet = <span class="built_in">Math</span>.floor(offSet / <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript 实现希尔排序的移位模式</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">method(arr: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">let</span> offSet = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">while</span> (offSet &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(&#x27;此轮offset为&#x27;, offSet)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length - offSet; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> min = arr[i], <span class="attr">minIndex</span>: <span class="built_in">number</span> = i</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; arr.length; j += offSet) &#123;</span><br><span class="line">        <span class="comment">// 修改查找方法 为 类选择排序</span></span><br><span class="line">        <span class="comment">//开始查找最小的index</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; min) &#123;</span><br><span class="line">          min = arr[j]</span><br><span class="line">          minIndex = j</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[minIndex] = arr[i]</span><br><span class="line">      arr[i] = min</span><br><span class="line">    &#125;</span><br><span class="line">    offSet = <span class="built_in">Math</span>.floor(offSet / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-计数排序"><a class="markdownIt-Anchor" href="#9-计数排序"></a> 9、计数排序</h3>
<h4 id="1计数排序的介绍"><a class="markdownIt-Anchor" href="#1计数排序的介绍"></a> （1）计数排序的介绍</h4>
<p>​		计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br />
​		计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p>
<h4 id="2计数排序的原理"><a class="markdownIt-Anchor" href="#2计数排序的原理"></a> （2）计数排序的原理</h4>
<p>​		1、找出待排序的数组中最大和最小的元素；<br />
​		2、统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br />
​		3、对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br />
​		4、反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p>
<h4 id="3动态图演示-6"><a class="markdownIt-Anchor" href="#3动态图演示-6"></a> （3）动态图演示</h4>
<p><img src="http://blogimage.lemonlife.top/201909181104_130.jpg?/" alt="" /></p>
<h4 id="4代码演示-7"><a class="markdownIt-Anchor" href="#4代码演示-7"></a> （4）代码演示</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计数排序</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] CountingSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">       <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span> array;</span><br><span class="line">       <span class="keyword">int</span> bias, min = array[<span class="number">0</span>], max = array[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (array[i] &gt; max)</span><br><span class="line">               max = array[i];</span><br><span class="line">           <span class="keyword">if</span> (array[i] &lt; min)</span><br><span class="line">               min = array[i];</span><br><span class="line">       &#125;</span><br><span class="line">       bias = <span class="number">0</span> - min;</span><br><span class="line">       <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">       Arrays.fill(bucket, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">           bucket[array[i] + bias]++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (index &lt; array.length) &#123;</span><br><span class="line">           <span class="keyword">if</span> (bucket[i] != <span class="number">0</span>) &#123;</span><br><span class="line">               array[index] = i - bias;</span><br><span class="line">               bucket[i]--;</span><br><span class="line">               index++;</span><br><span class="line">           &#125; <span class="keyword">else</span></span><br><span class="line">               i++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> array;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>JavaScript实现</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">findMinMax(arr: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">let</span> minMax = [arr[<span class="number">0</span>], arr[<span class="number">0</span>]]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (minMax[<span class="number">0</span>] &gt; arr[i]) minMax[<span class="number">0</span>] = arr[i];</span><br><span class="line">    <span class="keyword">if</span> (minMax[<span class="number">1</span>] &lt; arr[i]) minMax[<span class="number">1</span>] = arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> minMax</span><br><span class="line">&#125;</span><br><span class="line">method(arr: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">let</span> [min, max] = <span class="built_in">this</span>.findMinMax(arr)</span><br><span class="line">  <span class="keyword">let</span> countArr = <span class="keyword">new</span> <span class="built_in">Array</span>(max - min + <span class="number">1</span>)</span><br><span class="line">  arr.map(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    countArr[value - min] ? countArr[value - min] += <span class="number">1</span> : countArr[value - min] = <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  arr = []</span><br><span class="line">  countArr.map(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (value &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      arr.push(min + index)</span><br><span class="line">      value--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-桶排序"><a class="markdownIt-Anchor" href="#10-桶排序"></a> 10、桶排序</h3>
<h4 id="1桶排序的介绍"><a class="markdownIt-Anchor" href="#1桶排序的介绍"></a> （1）桶排序的介绍</h4>
<p>​		桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。</p>
<h4 id="2桶排序的原理"><a class="markdownIt-Anchor" href="#2桶排序的原理"></a> （2）桶排序的原理</h4>
<p>​		1、设置一个定量的数组当作空桶；	<br />
​		2、遍历输入数据，并且把数据一个一个放到对应的桶里去；<br />
​		3、对每个不是空的桶进行排序；<br />
​		4、从不是空的桶里把排好序的数据拼接起来。</p>
<h4 id="3动态图演示-7"><a class="markdownIt-Anchor" href="#3动态图演示-7"></a> （3）动态图演示</h4>
<p><img src="http://blogimage.lemonlife.top/201909181104_316.jpg?/" alt="" /></p>
<h4 id="4代码演示-8"><a class="markdownIt-Anchor" href="#4代码演示-8"></a> （4）代码演示</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 桶排序</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bucketSize</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">BucketSort</span><span class="params">(ArrayList&lt;Integer&gt; array, <span class="keyword">int</span> bucketSize)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.size() &lt; <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span> array;</span><br><span class="line">       <span class="keyword">int</span> max = array.get(<span class="number">0</span>), min = array.get(<span class="number">0</span>);</span><br><span class="line">       <span class="comment">// 找到最大值最小值</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (array.get(i) &gt; max)</span><br><span class="line">               max = array.get(i);</span><br><span class="line">           <span class="keyword">if</span> (array.get(i) &lt; min)</span><br><span class="line">               min = array.get(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> bucketCount = (max - min) / bucketSize + <span class="number">1</span>;</span><br><span class="line">       ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketCount);</span><br><span class="line">       ArrayList&lt;Integer&gt; resultArr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">           bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">           bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (bucketSize == <span class="number">1</span>) &#123; </span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketArr.get(i).size(); j++)</span><br><span class="line">                   resultArr.add(bucketArr.get(i).get(j));</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (bucketCount == <span class="number">1</span>)</span><br><span class="line">                   bucketSize--;</span><br><span class="line">               ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp.size(); j++)</span><br><span class="line">                   resultArr.add(temp.get(j));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> resultArr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-基数排序"><a class="markdownIt-Anchor" href="#11-基数排序"></a> 11、基数排序</h3>
<h4 id="1基数排序的介绍"><a class="markdownIt-Anchor" href="#1基数排序的介绍"></a> （1）基数排序的介绍</h4>
<p>​		基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；<br />
​		基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的</p>
<h4 id="2基数排序的原理"><a class="markdownIt-Anchor" href="#2基数排序的原理"></a> （2）基数排序的原理</h4>
<p>​		1、取得数组中的最大数，并取得位数；<br />
​		2、arr为原始数组，从最低位开始取每个位组成radix数组；<br />
​		3、对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p>
<h4 id="3动态图演示-8"><a class="markdownIt-Anchor" href="#3动态图演示-8"></a> （3）动态图演示</h4>
<p><img src="http://blogimage.lemonlife.top/201909181104_775.jpg?/" alt="" /></p>
<h4 id="4代码演示-9"><a class="markdownIt-Anchor" href="#4代码演示-9"></a> （4）代码演示</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 基数排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] RadixSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">       <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span> array;</span><br><span class="line">       <span class="comment">// 1.先算出最大数的位数；</span></span><br><span class="line">       <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">           max = Math.max(max, array[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> maxDigit = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">           max /= <span class="number">10</span>;</span><br><span class="line">           maxDigit++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> mod = <span class="number">10</span>, div = <span class="number">1</span>;</span><br><span class="line">       ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">           bucketList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, mod *= <span class="number">10</span>, div *= <span class="number">10</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">               <span class="keyword">int</span> num = (array[j] % mod) / div;</span><br><span class="line">               bucketList.get(num).add(array[j]);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketList.size(); j++) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketList.get(j).size(); k++)</span><br><span class="line">                   array[index++] = bucketList.get(j).get(k);</span><br><span class="line">               bucketList.get(j).clear();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> array;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>JavaScript实现</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">method(arr: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="comment">//定义10个装数的桶</span></span><br><span class="line">  <span class="keyword">let</span> bucket = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    bucket[i] = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取出个位数做 放入桶中</span></span><br><span class="line">  arr = arr.filter(<span class="function"><span class="params">value</span> =&gt;</span> &#123; bucket[value % <span class="number">10</span>].push(value) &#125;)</span><br><span class="line">  bucket.map(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      arr.push(value.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 取出 10位数 放桶中</span></span><br><span class="line">  arr = arr.filter(<span class="function"><span class="params">value</span> =&gt;</span> &#123; bucket[<span class="built_in">Math</span>.floor((value / <span class="number">10</span>)) % <span class="number">10</span>].push(value) &#125;)</span><br><span class="line">  bucket.map(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      arr.push(value.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 取出百位数 放入桶中</span></span><br><span class="line">  arr = arr.filter(<span class="function"><span class="params">value</span> =&gt;</span> &#123; bucket[<span class="built_in">Math</span>.floor((value / <span class="number">100</span>)) % <span class="number">10</span>].push(value) &#125;)</span><br><span class="line">  bucket.map(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      arr.push(value.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-堆排序"><a class="markdownIt-Anchor" href="#12-堆排序"></a> 12、堆排序</h3>
<h4 id="1堆排序的介绍"><a class="markdownIt-Anchor" href="#1堆排序的介绍"></a> （1）堆排序的介绍</h4>
<p>​		堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<h4 id="2堆排序的原理"><a class="markdownIt-Anchor" href="#2堆排序的原理"></a> （2）堆排序的原理</h4>
<p>​		1、将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br />
​		2、将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br />
​		3、由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p>
<h4 id="3动态图演示-9"><a class="markdownIt-Anchor" href="#3动态图演示-9"></a> （3）动态图演示</h4>
<p><img src="http://blogimage.lemonlife.top/201909181105_568.jpg?/" alt="" /></p>
<h4 id="4代码演示-10"><a class="markdownIt-Anchor" href="#4代码演示-10"></a> （4）代码演示</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明全局变量，用于记录数组array的长度；</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] HeapSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        len = array.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">1</span>) <span class="keyword">return</span> array;</span><br><span class="line">        <span class="comment">//1.构建一个最大堆</span></span><br><span class="line">        buildMaxHeap(array);</span><br><span class="line">        <span class="comment">//2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆</span></span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(array, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">            len--;</span><br><span class="line">            adjustHeap(array, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立最大堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从最后一个非叶子节点开始向上构造最大堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (len/<span class="number">2</span> - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line">            adjustHeap(array, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整使之成为最大堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = i;</span><br><span class="line">        <span class="comment">//如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span></span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">2</span> &lt; len &amp;&amp; array[i * <span class="number">2</span>] &gt; array[maxIndex])</span><br><span class="line">            maxIndex = i * <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//如果有右子树，且右子树大于父节点，则将最大指针指向右子树</span></span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt; len &amp;&amp; array[i * <span class="number">2</span> + <span class="number">1</span>] &gt; array[maxIndex])</span><br><span class="line">            maxIndex = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex != i) &#123;</span><br><span class="line">            swap(array, maxIndex, i);</span><br><span class="line">            adjustHeap(array, maxIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>JavaScript 实现基本堆排序</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.val = val</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个变量存放二叉搜索树</span></span><br><span class="line">    <span class="built_in">this</span>.tree = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.tree == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.tree = <span class="keyword">new</span> TreeNode(val)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pTree = <span class="built_in">this</span>.tree <span class="comment">// 存一下指针</span></span><br><span class="line">    <span class="keyword">while</span> (pTree != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 开始执行插入的流程</span></span><br><span class="line">      <span class="keyword">if</span> (pTree.val &gt;= val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pTree.left == <span class="literal">null</span>) &#123;</span><br><span class="line">          pTree.left = <span class="keyword">new</span> TreeNode(val)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        pTree = pTree.left</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pTree.right == <span class="literal">null</span>) &#123;</span><br><span class="line">          pTree.right = <span class="keyword">new</span> TreeNode(val)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        pTree = pTree.right</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inOrder</span>(<span class="params">tree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tree == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  inOrder(tree.left)</span><br><span class="line">  <span class="built_in">console</span>.log(tree.val)</span><br><span class="line">  inOrder(tree.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> heapSort = <span class="keyword">new</span> HeapSort()</span><br><span class="line"><span class="keyword">let</span> testArray = [<span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line">testArray.map(<span class="function"><span class="params">value</span> =&gt;</span> heapSort.insert(value))</span><br><span class="line">inOrder(heapSort.tree) <span class="comment">// 1 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure>
<h3 id="最后总结"><a class="markdownIt-Anchor" href="#最后总结"></a> 最后总结</h3>
<p>不同的排序算法有不同的应用场景,一般情况下如果数据都是正数，可以考虑采用基数排序，计数排序，桶排序之类的排序算法。其中计数排序算是最耗费空间的了，也是拿空间换时间最明显的那个😁</p>
<blockquote>
<p>博客中中JavaScript部分是我自己写的,Java和文字引用于马老师,<em>马士兵教育公开课</em>。JS部分<a target="_blank" rel="noopener" href="https://github.com/wmwgithub/typescript-design-mode/tree/master/src/sort">源码</a></p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">琅琊旻</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wmwgithub.github.io/2019/07/27/rank-method/">https://wmwgithub.github.io/2019/07/27/rank-method/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wmwgithub.github.io">琅琊旻</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法与数据结构</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e33bf91133aab4b" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/07/27/init/"><i class="fa fa-chevron-left">  </i><span>博客搭建过程</span></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '55b93500c699e46ecd3c',
  clientSecret: 'b30789a22c5e9d2d1cff1a0aeb9d2af82ff4c6d9',
  repo: 'wmwgithub.github.io',
  owner: 'wmwgithub',
  admin: 'wmwgithub',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By 琅琊旻</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>