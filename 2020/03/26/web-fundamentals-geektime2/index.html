<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="浏览器工作原理~JavaScript"><meta name="keywords" content="浏览器"><meta name="author" content="琅琊旻"><meta name="copyright" content="琅琊旻"><title>浏览器工作原理~JavaScript | 琅琊旻</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-1150529212462758',
  enable_page_level_ads: 'true'
});
</script><link rel="dns-prefetch" href="http://ta.qq.com"><script>(function() {
   var hm = document.createElement("script");
   hm.src = "https://tajs.qq.com/stats?sId=66535930";
   var s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(hm, s);
 })();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.</span> <span class="toc-text"> 消息队列和事件循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.</span> <span class="toc-text"> 宏任务和微任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javascript%E5%AE%8F%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text"> JavaScript宏任务的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javascript%E5%BE%AE%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text"> JavaScript微任务的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8E%BB%E5%86%99%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text"> 使用同步的方式去写异步代码</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://blogimage.lemonlife.top/201910302316_962.jpg"></div><div class="author-info__name text-center">琅琊旻</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/wmwgithub">GitHub关注</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">40</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">17</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.dzou.top">Dzou's Blog</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://boyn.top">Boyn</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://www.parak.top/">ParaK</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://luo-xi.xyz/">洛臣心</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.uchihakakashi.top/">Uchkks's Blog</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://crassulalactea.github.io/">Crassula</a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">琅琊旻</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">类别</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">浏览器工作原理~JavaScript</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-26</time></div><div class="article-container" id="post-content"><h3 id="消息队列和事件循环"><a class="markdownIt-Anchor" href="#消息队列和事件循环"></a> 消息队列和事件循环</h3>
<p>要知道浏览器中的JavaScript是如何运行的，首先需要了解的是浏览器的渲染进程到底是如何工作的。首先渲染进程的主线程肯定是运行了JavaScript代码。然后因为渲染进程要和其他的进程（如网络进程和浏览器进程等）进行一些通信，必定会有一条IO线程，来和外界发生数据交换。同样在渲染进程内部有IO线程和渲染主线程之间的通讯，必然是基于消息队列机制的。方便浏览器主线程读取，和IO线程存放事件。</p>
<p><img src="http://blogimage.lemonlife.top/202003261644_747.png?/" alt="渲染进程内部结构" /></p>
<p>除了图中的一些事件，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。</p>
<p>当然如果消息队列仅仅是每个任务，都是按顺序执行的的设计，不难发现，会造成一个任务的堆积，以及必要任务的延迟。渲染进程内部除了这两条线程之外，也还有预解析DOM线程和垃圾回收的一些辅助线程。这里只是对JavaScript的事件机制一个简单的介绍，有一个最基本的概念上的了解。</p>
<h3 id="宏任务和微任务"><a class="markdownIt-Anchor" href="#宏任务和微任务"></a> 宏任务和微任务</h3>
<p>主线程采用一个 循环机制，不断地从这些任务队列中取出任务并执行任务。为了解决可能出现的任务延迟，阻塞等问题，在V8内部，引入了宏任务和微任务的概念。我们把这些消息队列中的任务称为宏任务。</p>
<p>而对于微任务，在JS执行脚本的时候，会创建一个全局执行的上下文，在创建全局执行上下文的同时，V8引擎会创建一个微任务队列。(这个真的是队列)，然后在执行代码的时候，如果有遇到产生微任务的代码，比如Promise.resove 函数等，会将产生的微任务放置到任务队列中，在当前作用域中的代码执行完成之后，会先执行当前微任务队列中的代码，直到当前微任务代码执行完了再执行宏任务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;0秒定时器&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;执行Promise&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    res()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;0000&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="comment">// 0000</span></span><br><span class="line"><span class="comment">// 执行Promise</span></span><br><span class="line"><span class="comment">// 0秒定时器</span></span><br></pre></td></tr></table></figure>
<p>可见从上面的代码可以看出，在成函数上下文,然后创建了微任务队列之后，开始逐行执行代码，</p>
<ol>
<li>执行了 <code>setTimeout</code> ,将此函数放入宏任务队列中。</li>
<li>遇到了, <code>new Promise()</code>  调用了resolve,将resolve,把resolve中要执行的代码放入微任务队列中</li>
<li>执行 <code>console.log('0000')</code> 输出 <code>0000</code></li>
<li>执行微任务队列中的代码，输出 <code>执行Promise</code></li>
<li>这时候浏览器出现了空闲期，开始执行宏任务，发现有定时器到时间了，执行定时器，<code>输出0秒定时器</code></li>
</ol>
<p><img src="http://blogimage.lemonlife.top/202003271955_472.png?/" alt="微任务的执行过程" /></p>
<h3 id="javascript宏任务的应用"><a class="markdownIt-Anchor" href="#javascript宏任务的应用"></a> JavaScript宏任务的应用</h3>
<blockquote>
<p>setTimeout</p>
</blockquote>
<p>通过之前的介绍你大概对setTimeout有一定的认识，他属于一种浏览器宏任务，但是你是否设想过，浏览器是如何知道setTimeout是如何到时间了呢。除了上述介绍的消息队列之外，浏览器还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。(说成队列只是方便大家理解，其实实际上储存定时器的数据结构可能是hashmap之类的，毕竟浏览器的每个定时器都有一个id)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// A queue for holding delayed tasks before their delay has expired.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DelayedIncomingQueue</span> &#123;</span>&#125;</span><br><span class="line">DelayedIncomingQueue delayed_incoming_queue;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定时器需要注意的问题<br />
1.如果当前任务执行时间过久，会影延迟到期定时器任务的执行<br />
如果你主线程中的代码和微队列中的代码执行时效过久，定时器就算事件到了也要等，之前代码执行完了再执行，参看前面 <code>0秒定时器</code>的例子。</p>
</blockquote>
<ol start="2">
<li>如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒，因为在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxTimerNestingLevel = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> base::TimeDelta kMinimumInterval =</span><br><span class="line">base::TimeDelta::FromMilliseconds(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>未激活的页面，setTimeout 执行最小间隔是 1000 毫秒，未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量</li>
<li>延时执行时间有最大值， Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，这导致定时器会被立即执行。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot; 极客时间 &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> timerID = <span class="built_in">setTimeout</span>(showName,<span class="number">2147483648</span>);<span class="comment">// 会被理解调用执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>WebAPI：XMLHttpRequest</p>
</blockquote>
<p>当执行到let xhr = new XMLHttpRequest()后，JavaScript 会创建一个 XMLHttpRequest对象xhr，用来执行实际的网络请求操作。</p>
<p>浏览器调用xhr.send来发起网络请求了。你可以对照上面那张请求流程图，可以看到：渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。</p>
<ul>
<li>如果网络请求出错了，就会执行 xhr.onerror；</li>
<li>如果超时了，就会执行 xhr.ontimeout；</li>
<li>如果是正常的数据接收，就会执行 onreadystatechange 来反馈相应的状态。</li>
</ul>
<p><img src="http://blogimage.lemonlife.top/202003272119_592.png?/" alt="XMLHttpRequest 工作流程图" /></p>
<h3 id="javascript微任务的应用"><a class="markdownIt-Anchor" href="#javascript微任务的应用"></a> JavaScript微任务的应用</h3>
<blockquote>
<p>监听 DOM , <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver">MutationObserver</a></p>
</blockquote>
<p>对于监听DOM这件事，容易想到的是使用定时器进行轮询监听，(假设没有requestAnimationFrame) 来监听DOM变化。当然这些都会产生一个高延迟或者，资源浪费的问题。其次就是采用基于观察者模式的<code>Mutation Event</code>，在每次资源发生改变的时候，触发对应的函数钩子。虽然这种方式能解决延迟高的问题，但是频繁的去触发函数钩子，带来的就是巨大的开销。从而也能造成页面卡顿。</p>
<p>于是乎，后来推出 <code>Mutation Event</code>的改进版本.<code>MutationObserver</code>,采用了微任务队列，也就是当前上下文执行完成之后，才会执行<code>MutationObserver</code> 中的响应事件,有效的避免了，函数执行造成的页面上的动画卡顿。</p>
<blockquote>
<p>Promise</p>
</blockquote>
<p>做为一个单线程的语言，JavaScript,要想充分的利用计算机资源，必须要采用异步编程模型，而对于JS来说就是，渲染进程上面的主线程的事件循环系统了。页面主线程发起了一个耗时的任务，并将任务交给另外一个进程去处理，这时页面主线程会继续执行消息队列中的任务。等该进程处理完这个任务后，会将该任务添加到渲染进程的消息队列中，并排队等待循环系统的处理。</p>
<p><img src="http://blogimage.lemonlife.top/202003272037_430.png?/" alt="异步编程模型图" /></p>
<p>于是乎，为了处理消息队列中返回的事件，就产生了所谓的回调函数的机制。确保我们能正确的处理异步信息。然后就有可能产生回调地狱问题。而Promise的诞生就是想解决这种回调地狱问题。Promise内部实现的机制就是使用了微任务队列，(可以上网搜一下Promise的实现，也可以参看 <a target="_blank" rel="noopener" href="https://lemonlife.top/2020/02/10/interview/#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bpromise%E4%BB%A5%E5%8F%8A%E5%86%85%E9%83%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">我的博客手写Promise</a>。可以看到里面采用了<code>setTimeout</code>，是js不提供微队列函数，只能采用setTimeout模拟一下微队列，底层的promise实现，正是把那些状态参数都放到了微队列中等待执行。</p>
<h3 id="使用同步的方式去写异步代码"><a class="markdownIt-Anchor" href="#使用同步的方式去写异步代码"></a> 使用同步的方式去写异步代码</h3>
<blockquote>
<p>Generator</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genDemo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot; 开始执行第一段 &quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;generator 2&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot; 开始执行第二段 &quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;generator 2&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot; 开始执行第三段 &quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;generator 2&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot; 执行结束 &quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;generator 2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;main 0&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> gen = genDemo()</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;main 1&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;main 2&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;main 3&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;main 4&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到使用了 Generator 的之后，我们好像可以通过<code>gen.next()</code>随意执行<code>function* genDemo</code> 函数里面的代码，然后，如果在执行函数内部代码过程中，如果遇到 yield 关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。然后在外部继续调用next,会接着上次暂停的地方继续执行，一直这样循环往复。对于这种可以随缘恢复和暂停函数的行为是基于 <strong>协程</strong> 机制。</p>
<p>操作系统对于资源的管理进程是开销最大的，其次是线程，协程是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。</p>
<p><img src="http://blogimage.lemonlife.top/202003272133_917.png?/" alt="协程执行流程图" /></p>
<p><strong>注意</strong></p>
<ol>
<li>gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的</li>
<li>对于父子协程，都有自己独立的调用栈，只不过，父协程中一直保留着子协程的调用栈信息，当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息。</li>
</ol>
<p><img src="http://blogimage.lemonlife.top/202003272139_187.png?/" alt="协程之间的切换" /></p>
<blockquote>
<p>async/await</p>
</blockquote>
<p>async/await,是Generator函数的语法糖，专门针对Promise的一种封装。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="number">100</span></span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>)</span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 1 3 100 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://blogimage.lemonlife.top/202003272144_714.png?/" alt="上述 async/await 执行流程图" /></p>
<blockquote>
<p>本文是我看了<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/216?code=wLzkK4Ecmtj435LqyZ6ecONi5PnKUst4jvEoQKp1yUA%3D">李兵老师极客时间浏览器工作原理的专栏</a>写的总结,文字和图片资料来源与极客时间.</p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">琅琊旻</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wmwgithub.github.io/2020/03/26/web-fundamentals-geektime2/">https://wmwgithub.github.io/2020/03/26/web-fundamentals-geektime2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wmwgithub.github.io">琅琊旻</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e33bf91133aab4b" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/03/28/leetcode-short-encoding-of-words/"><i class="fa fa-chevron-left">  </i><span>单词的压缩编码~后缀树</span></a></div><div class="next-post pull-right"><a href="/2020/03/24/leetcode-the-masseuse-lcci/"><span>按摩师~动态规划</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '55b93500c699e46ecd3c',
  clientSecret: 'b30789a22c5e9d2d1cff1a0aeb9d2af82ff4c6d9',
  repo: 'wmwgithub.github.io',
  owner: 'wmwgithub',
  admin: 'wmwgithub',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By 琅琊旻</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>