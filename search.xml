<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基金</title>
      <link href="2020/12/03/fund-01/"/>
      <url>2020/12/03/fund-01/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>由于互联网技术的发展，早期的封闭式基金，已经退出了历史舞台，被开放式基金代替。开放式基金根据基金类型可分为</p><ul><li>股票型基金 ( 80% 的资金用于股票)</li><li>混合型基金<ul><li>偏股型基金 (股票占比 &gt;= 50% )</li><li>偏债型基金 (债券占比 &gt;= 50% )</li><li>平衡型基金 (股票债券占比 &lt;= 50% )</li><li>灵活型基金 (占比无要求)</li></ul></li><li>债券型基金 ( 80% 的基金用于债券)</li><li>货币市场基金</li></ul><blockquote><p>投资风险从高到底， 股票型基金 混合型基金 债券型基金 货币基金</p></blockquote><h3 id="金融市场"><a class="markdownIt-Anchor" href="#金融市场"></a> 金融市场</h3><p>资本市场： 股票市场和一年期以上的债券市场，称为资本市场。</p><blockquote><p>包括 股票 基金 长期债券</p></blockquote><p>货币市场：只能交易短期债券和各类票据</p><blockquote><p>包括 短期债券 央票 银行汇票 债券回购 银行存款</p></blockquote><h3 id="基金名称解析"><a class="markdownIt-Anchor" href="#基金名称解析"></a> 基金名称解析</h3><ol><li><p>基金公司的名称</p><p>如: 天弘 华夏 易方达 南方 工银瑞信 建信 博时 嘉实 招商 广发 汇添富 鹏华 富国 华宝兴业 ……</p></li><li><p>基金特点或者偏好 (修饰词)<br />如：互联网主题 行业轮动 轻资产 健康环保 经济转型 中小盘 ……</p></li><li><p>基金的投资范围<br />如：货币 债券 纯债 可转债 混合 灵活配置 股票 指数 增强指数 量化 海外 美元 ETF LOF QDII ……</p></li></ol><h2 id="货币基金"><a class="markdownIt-Anchor" href="#货币基金"></a> 货币基金</h2><h4 id="申购时间"><a class="markdownIt-Anchor" href="#申购时间"></a> 申购时间</h4><p>一般选择周日晚~周四下午3点之前买入货币基金。</p><h4 id="七日年化收益"><a class="markdownIt-Anchor" href="#七日年化收益"></a> 七日年化收益</h4><p>货币基金都维持过去七天的收益水平不变,持有一年后的整体收益。因为货币基金的值每天变换，所以七日年化收益一般是虚拟预估,不具有代表性</p><h4 id="每万份收益"><a class="markdownIt-Anchor" href="#每万份收益"></a> 每万份收益</h4><p>或基净值永远是1元,所以每万份收益,就是1w元在当天的收入。</p><h4 id="累计回报"><a class="markdownIt-Anchor" href="#累计回报"></a> 累计回报</h4><p>货币基金本来回报率就稳定不高，看短期收益没有任何意义，应该查看基金累计半年或者一年的收益。</p><hr /><p>登录 天天基金网 点击基金排行,然后再点击,货币基金排行可以查看到货币基金的累计收益</p><p><img src="https://blogimage.lemonlife.top/202012041330_247.png" alt="" /></p><p><img src="https://blogimage.lemonlife.top/202012041333_376.png" alt="货币基金排行" /></p><p><img src="https://blogimage.lemonlife.top/202012041336_84.png" alt="余额宝货币基金规模" /></p><h3 id="货基类型"><a class="markdownIt-Anchor" href="#货基类型"></a> 货基类型</h3><p><strong>A:</strong> 1000元起买,余额宝出来后无限制了<br /><strong>B:</strong> 500万起买</p><blockquote><p>买货币基金建议别买后面有字母的，这样不会有利率歧视</p></blockquote><h3 id="货币etf"><a class="markdownIt-Anchor" href="#货币etf"></a> 货币ETF</h3><p>ETF (交易型开放式指数基金 Exchange Traded Funds )， 场内货币基金(可以直接在证券市场内买卖的货币基金),货币ETF要买不要收取佣金的货币基金。</p><blockquote><p>例如：华宝添益(511990) 银华日利(511880) 理财金H(511810)</p></blockquote><h2 id="债券基金"><a class="markdownIt-Anchor" href="#债券基金"></a> 债券基金</h2><p>从长期看，债基的利率高于货币基金和银行储蓄</p><h3 id="债基分类"><a class="markdownIt-Anchor" href="#债基分类"></a> 债基分类</h3><p>按投资基金分类，债基可分为：</p><ul><li>短债基金</li><li>中短债基金</li><li>长期债券型基金</li></ul><p>按嫩否投资股票可以分为：</p><ul><li>二级债基(可拿出20%的基金去买二级市场股票)</li><li>一级债基(不能买二级市场股票，但是可以在一级市场买新股,风险一般比二级债基低)</li><li>纯债基 (不允许资金买股票的债基)</li><li>转债基金(可以投资可转债市场的转债基金，风险较高)</li></ul><blockquote><p>建议购买纯债基金,其他债基风险不明确</p></blockquote><h3 id="纯债投资和挑选"><a class="markdownIt-Anchor" href="#纯债投资和挑选"></a> 纯债投资和挑选</h3><p>纯债基金的平均年化收益率6%，在天天基金网按照债券型基金，选择长期纯债基金，近三年排行榜，通过剔除：</p><ul><li>剔除可转债的基金</li><li>剔除小公司的基金剔除掉</li><li>剔除基金规模超过20亿的基金</li><li>剔除同一基金公司的非王牌基金</li></ul><blockquote><p>A类B类债基都有申赎费用，A类是前端收费，B类是赎回的时候收费，C类不收取申购赎回费率。只收取销售服务费，短期C类长期选择A类。</p></blockquote><blockquote><p>也可以选择，期限为一年的中期，定期开发债基</p></blockquote><h2 id="混合型基金"><a class="markdownIt-Anchor" href="#混合型基金"></a> 混合型基金</h2><p>平衡型和灵活配置型能体现出混合型基金的优势，风险对冲能力较好，收益很大程度上取决于基金经理的能力。</p><h2 id="股票型基金"><a class="markdownIt-Anchor" href="#股票型基金"></a> 股票型基金</h2><p>现在的公募基金，都是在3~5个月后才能看到具体的持仓配比(哈哈哈,防止对手抄袭吧),一般股票型基金选择大型的基金公司来投。</p><h4 id="大型基金公司"><a class="markdownIt-Anchor" href="#大型基金公司"></a> 大型基金公司</h4><ul><li>基金行业第一梯队<br />天弘基金 工银瑞信(ICBC) 易方达基金 博时基金 招商基金 南方基金( * ) 嘉实基金( * ) 华夏 建信 中银 汇添富( * ) 鹏华 广发 富国( * ) 银华( * ) 华安( * ) 华宝兴业 兴全( * ) 兴业 上投摩根 大成基金</li></ul><h4 id="优秀的基金经理"><a class="markdownIt-Anchor" href="#优秀的基金经理"></a> 优秀的基金经理</h4><ul><li>基金经理背景(年龄,35岁左右以上 学历 履历,管理6~7年或者以上)</li><li>操盘风格 (基金公司每季度会公布基金报告,会看到基金最新持有的10大仓股,或者查看基金换手率，一般来说这些变化越小，说明该经理喜欢短线投资)</li></ul><h4 id="看业绩"><a class="markdownIt-Anchor" href="#看业绩"></a> 看业绩</h4><p>首先基金成立的时间足够久,至少是3~5年的,其他条件相同，时间越长越好。其次看收益,在长时间内，收益一直稳定,收益排名要一直靠前。</p><h4 id="β系数"><a class="markdownIt-Anchor" href="#β系数"></a> β系数</h4><p>基金和业绩评价基准之间的相关性。风险和收益的相关系，例如货币基金的基准是定期存款利率。股票型基金，对应的就是大盘走势。指数型基金就是所跟踪的指数。β指数越高，说明基金的风险和收益波动性越大。β表示着基金要承担的系统性风险。</p><h4 id="α系数"><a class="markdownIt-Anchor" href="#α系数"></a> α系数</h4><p>基金的绝对回报收益(超额收益，基金的收益 - 市场无风险收益)，主要靠基金经理的择时和选股水平决定的。一般α系数越高，说明基金经理的理财能力越强。</p><h4 id="r平方0~100"><a class="markdownIt-Anchor" href="#r平方0~100"></a> R平方(0~100)</h4><p>R<sup>2</sup> 的数值越高 <code>α系数</code> 和 <code>β系数</code> 的可信度就越高。</p><h4 id="夏普比率"><a class="markdownIt-Anchor" href="#夏普比率"></a> 夏普比率</h4><p>夏普比率越高,基金性价比越高,还有好多指数……记不住了……</p><h4 id="看基金规模"><a class="markdownIt-Anchor" href="#看基金规模"></a> 看基金规模</h4><ul><li>投资中小盘股的基金(10亿~20亿)</li><li>投资大盘股基金(30~100亿)</li><li>超过100亿,巨无霸基金😅</li></ul><h2 id="指数型基金"><a class="markdownIt-Anchor" href="#指数型基金"></a> 指数型基金</h2><p>根据某一个指数的成分股来配置股票基金。指数跟踪误差越小说明指数基金越优秀。</p><p><img src="https://blogimage.lemonlife.top/202012051656_469.png" alt="招商国政生物医药指数跟踪误差" /></p><p>一般指数基金的日跟踪误差都在0.5%以内,优秀的指数基金可以把误差缩小到0.05%以内,年度跟踪误差不会超过1.5%。</p><h4 id="综合指数"><a class="markdownIt-Anchor" href="#综合指数"></a> 综合指数</h4><p>股票的股价和发行量的加权平均数，容易造成指数失真</p><ul><li>上证指数：上海证券交易所挂牌的所有股票的价格</li><li>深证指数</li></ul><h4 id="成分指数"><a class="markdownIt-Anchor" href="#成分指数"></a> 成分指数</h4><p>根据科学客观的选样方法，挑选出样本股所构成的指数，成分指数在计算时候，只考虑流通股不考虑非流通股。现在基本是全流通股时代。成分指数的股票基本没半年更新一次。</p><ul><li>深证成分指数 (深证的中小盘股票指数)</li><li>深证100指数,由深圳证券市场流通市值最大成分最活跃的100只成分股所编制的股票指数，代码为(399330) (深证大盘股票指数)</li><li>上证50指数,26只股基本都是金融股和中石化，中石油。</li><li>上证180指数，流通市值基本占到了上交所一般。</li><li>沪深300指数，中证公司成立,大盘指数</li><li>中证500指数 (小盘股)<ul><li>排除沪深300指数成分股</li><li>再排除剩下的市值排名前300的股票</li><li>再排除最不活跃的20%的股票</li><li>最后挑选剩下的市值，由高到低的最高的500个股票</li></ul></li><li>中证800指数 (大中小盘的综合反映)</li><li>中证1000指数 (小市值股票反映)</li><li>中小版指数,创业板指数 (2009年诞生,投资风险高)</li></ul><h3 id="指数基金查询"><a class="markdownIt-Anchor" href="#指数基金查询"></a> 指数基金查询</h3><ol><li>上交所官网 <a href="http://www.sse.com.cn/">http://www.sse.com.cn/</a></li><li>深交所官网 <a href="http://www.szse.cn/">http://www.szse.cn/</a></li><li>中证公司官网 <a href="http://www.csindex.com.cn/">http://www.csindex.com.cn/</a></li></ol><h3 id="主动增强型指数基金"><a class="markdownIt-Anchor" href="#主动增强型指数基金"></a> 主动增强型指数基金</h3><p>基金经理可以，根据指数来做调整，风险较高,管理费介于股票基金和指数基金之间</p><h3 id="挑选技巧"><a class="markdownIt-Anchor" href="#挑选技巧"></a> 挑选技巧</h3><p>买基金规模大的指数基金，买管理费低的,买老的指数基金，新基金可能没完成建仓，导致指数跟踪误差较大。</p><h4 id="大数据指数基金"><a class="markdownIt-Anchor" href="#大数据指数基金"></a> 大数据指数基金</h4><p>利用大数据技术来预测，大数据基金的成分股不只是看基金经理，而是看好几位专家组成的专家团队的决策，中国第一代大数据基金：</p><ul><li>腾讯+银河(定投宝) 银河中证腾讯腾讯济安价值100指数基金,2013年5月诞生</li><li>百度+广发 广发中证百度百发策略100指数基金</li><li>阿里+博时 博时中证淘金大数据100指数基金</li></ul><p>第二批大数据基金：</p><ul><li>南方i100</li><li>新浪i100</li><li>中证银联智慧大数据100指数</li><li>中证银联智策大数据100指数</li><li>中证银联智策消费大数据指数</li></ul><p>大数据混合型基金：</p><ul><li>天弘云端生活优选基金</li><li>东方红京东大数据混合基金</li><li>广发百发大数据价值混合基金</li><li>广发百发大数据成长混合基金</li><li>嘉实腾讯自选股大数据策略混合基金</li></ul><blockquote><p>目前人工智能，感觉还无法处理股市的风险，因此感觉大数据基金风险很大。  但是技术在进步，可以观望未来、</p></blockquote><h3 id="etf基金"><a class="markdownIt-Anchor" href="#etf基金"></a> ETF基金</h3><p>中国第一支ETF基金诞生于2004年12月30日，华夏上证50ETF基金。ETF基金管理费的属于指数基金中最低的了。</p><h4 id="etf优点"><a class="markdownIt-Anchor" href="#etf优点"></a> ETF优点</h4><ol><li>公开透明 投资成本最低</li><li>操作灵活 投资门槛最低</li><li>仓位最高 资金利用效率最高</li><li>套利玩法可以带来超额收益</li></ol><h4 id="etf联接基金"><a class="markdownIt-Anchor" href="#etf联接基金"></a> ETF联接基金</h4><p>可以在场外的一级市场的申购赎回，方便大家购买。规定必须要有90%的资金购买对应的ETF基金。</p><h4 id="etf联接基金的优势"><a class="markdownIt-Anchor" href="#etf联接基金的优势"></a> ETF联接基金的优势</h4><ol><li>持有成本比普通指数基金低</li><li>可以自动设置定投计划方便投资者</li></ol><h4 id="lof基金"><a class="markdownIt-Anchor" href="#lof基金"></a> LOF基金</h4><p>LOF<code>(Listed Open-ended Fund 上市型开放式基金)</code> 是中国市场自主创造的一种基金品种。中国第一支LOF基金成立于2004年8月24日，<code>南方积极配置混合(LOF)(160105)</code>。</p><p><img src="https://blogimage.lemonlife.top/202012052203_547.png" alt="南方积极配置混合(LOF)(160105)" /></p><blockquote><p>ETF,LOF套利的规则我觉得很麻烦，主要时间肯定还是在工作上，基金就是长期投着玩玩。所以不记录这种高级的玩法。</p></blockquote><h3 id="行业指数基金"><a class="markdownIt-Anchor" href="#行业指数基金"></a> 行业指数基金</h3><p>宽基指数，选股基础比较宽泛行业分布比较均匀的指数。行业指数属于窄基指数。</p><ul><li><p>泛教育</p><ul><li>中证教育产业指数</li></ul></li><li><p>泛理财</p><ul><li>中证金融指数(银行 证券 保险)</li><li>中证互联网金融指数</li></ul></li><li><p>泛娱乐产业</p><ul><li>中证娱乐产业指数</li><li>中证传媒产业指数</li><li>中证影视产业指数</li><li>中证文体休闲产业指数</li><li>中证TMT指数</li></ul></li><li><p>健康产业</p><ul><li>各种医药医疗指数</li><li>互联网医疗指数</li><li>中证健康产业指数</li><li>中证养老产业指数</li></ul></li></ul><h2 id="特种基金"><a class="markdownIt-Anchor" href="#特种基金"></a> 特种基金</h2><h3 id="分级基金"><a class="markdownIt-Anchor" href="#分级基金"></a> 分级基金</h3><p>具有中国特色的杠杆基金,国内第一支分级基金是<code>国投瑞银瑞福分级基金</code>,把一个基金的资产和收益拆分成不同风险级别的两个子基金。分级A和分级B。<br />上交所发行的母基金、分级A和分级B代码都以50开头。深交所发行的母基金都是以16开头分级A、分级B都是15开头。</p><p><code>分级A约定收益 = 一年期定期存款基准利率+1.5%~5%</code></p><blockquote><p>分级基金游戏规则，我也觉的太复杂了</p></blockquote><h2 id="小技巧"><a class="markdownIt-Anchor" href="#小技巧"></a> 小技巧</h2><ul><li>支付宝免费提现，可采用网商银行，中继的方式</li><li>天天基金网 <a href="https://fund.eastmoney.com/">链接</a></li><li>shiboe <a href="http://www.shibor.org/">链接</a></li><li>集思录 <a href="https://www.jisilu.cn/">链接</a></li></ul><h3 id="基金定投"><a class="markdownIt-Anchor" href="#基金定投"></a> 基金定投</h3><p>指数基金由国内大厂，来控制，基本符合国内的宏观经济学发展。沪深300指数基金（大盘股）；中证500指数基金（小盘股），</p><h4 id="定投周期"><a class="markdownIt-Anchor" href="#定投周期"></a> 定投周期</h4><p>一个月一次，定投的频率越高，收益亏损曲线月平滑，股市大涨减少投资，股市大跌 增加定投。</p><h4 id="智能定投平台"><a class="markdownIt-Anchor" href="#智能定投平台"></a> 智能定投平台</h4><table><thead><tr><th>招商银行</th><th>摩羯智投</th></tr></thead><tbody><tr><td>蚂蚁财富</td><td>慧定投</td></tr><tr><td>腾讯理财通</td><td>目标盈定投</td></tr><tr><td>雪球蛋卷基金</td><td>蛋定投</td></tr></tbody></table><h3 id="基金评级机构"><a class="markdownIt-Anchor" href="#基金评级机构"></a> 基金评级机构</h3><ul><li><a href="http://cn.morningstar.com/">晨星</a></li><li>理柏( 好像暂时没有中国大陆地区 )</li><li><a href="https://www.fitchratings.com/">惠誉</a></li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><h4 id="股票代码"><a class="markdownIt-Anchor" href="#股票代码"></a> 股票代码</h4><table><thead><tr><th>名称</th><th>沪市A股</th><th>沪市B股</th><th>深市A股</th><th>深市B股</th><th>深市中小板</th><th>深市创业板</th></tr></thead><tbody><tr><td>代码开头</td><td>60</td><td>900</td><td>00</td><td>200</td><td>002</td><td>300</td></tr></tbody></table><blockquote><p>0 2 3 6 9 开头的6位代码，一般对应股票</p></blockquote><h4 id="基金"><a class="markdownIt-Anchor" href="#基金"></a> 基金</h4><table><thead><tr><th>名称</th><th>沪市基金</th><th>沪市ETF</th><th>沪市LOF</th><th>深市基金</th><th>深市ETF</th><th>深市LOF</th></tr></thead><tbody><tr><td>代码开头</td><td>5</td><td>51</td><td>5010</td><td>1</td><td>15</td><td>16</td></tr></tbody></table><blockquote><p>1 5 开头的6位代码，一般对应基金</p></blockquote><blockquote><p>资料来源 网易云课堂 力哥理财</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
            <tag> 基金 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单词的压缩编码~后缀树</title>
      <link href="2020/03/28/leetcode-short-encoding-of-words/"/>
      <url>2020/03/28/leetcode-short-encoding-of-words/</url>
      
        <content type="html"><![CDATA[<blockquote><p>来源：力扣（LeetCode）链接：<a href="https://leetcode-cn.com/problems/short-encoding-of-words">https://leetcode-cn.com/problems/short-encoding-of-words</a></p></blockquote><h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3><p>给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。</p><p>例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。</p><p>对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。</p><p>那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: words &#x3D; [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</span><br><span class="line">输出: 10</span><br><span class="line">说明: S &#x3D; &quot;time#bell#&quot; ， indexes &#x3D; [0, 2, 5] 。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><ol><li>根据题目是从一个单词某个索引处，读取到该单词的末尾结束。且必须要读到末尾，，因为只有末尾有分割符&quot;#&quot;,因此很自然的就想到了后缀树的思想</li><li>JavaScript 并没有内置，后缀树这种数据结构，我们可以用Map的嵌套，来模拟一个后缀字典树。</li></ol><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minimumLengthEncoding = <span class="function"><span class="keyword">function</span> (<span class="params">words</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (words.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 使用Map 数据结构模仿后缀字典树</span></span><br><span class="line">  <span class="keyword">let</span> tree = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">    word = <span class="string">`<span class="subst">$&#123;word&#125;</span>`</span></span><br><span class="line">    <span class="keyword">let</span> _tree = tree</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = word.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!_tree.has(word[i])) &#123;</span><br><span class="line">        _tree.set(word[i], <span class="keyword">new</span> <span class="built_in">Map</span>())</span><br><span class="line">      &#125;</span><br><span class="line">      _tree = _tree.get(word[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向字典树中插入单词</span></span><br><span class="line">  words.map(<span class="function"><span class="params">value</span> =&gt;</span> insert(value))</span><br><span class="line">  <span class="comment">// 统计出 生成的字典树，有多少字母，以及多少个单词</span></span><br><span class="line">  <span class="keyword">let</span> letters = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> bound = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">orderMap</span>(<span class="params">tree, temp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree.size === <span class="number">0</span>) &#123;</span><br><span class="line">      letters += temp</span><br><span class="line">      bound += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> tree) &#123;</span><br><span class="line">      <span class="keyword">let</span> _temp = temp</span><br><span class="line">      orderMap(tree.get(key), ++_temp)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  orderMap(tree, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> letters + bound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器工作原理~JavaScript</title>
      <link href="2020/03/26/web-fundamentals-geektime2/"/>
      <url>2020/03/26/web-fundamentals-geektime2/</url>
      
        <content type="html"><![CDATA[<h3 id="消息队列和事件循环"><a class="markdownIt-Anchor" href="#消息队列和事件循环"></a> 消息队列和事件循环</h3><p>要知道浏览器中的JavaScript是如何运行的，首先需要了解的是浏览器的渲染进程到底是如何工作的。首先渲染进程的主线程肯定是运行了JavaScript代码。然后因为渲染进程要和其他的进程（如网络进程和浏览器进程等）进行一些通信，必定会有一条IO线程，来和外界发生数据交换。同样在渲染进程内部有IO线程和渲染主线程之间的通讯，必然是基于消息队列机制的。方便浏览器主线程读取，和IO线程存放事件。</p><p><img src="http://blogimage.lemonlife.top/202003261644_747.png?/" alt="渲染进程内部结构" /></p><p>除了图中的一些事件，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。</p><p>当然如果消息队列仅仅是每个任务，都是按顺序执行的的设计，不难发现，会造成一个任务的堆积，以及必要任务的延迟。渲染进程内部除了这两条线程之外，也还有预解析DOM线程和垃圾回收的一些辅助线程。这里只是对JavaScript的事件机制一个简单的介绍，有一个最基本的概念上的了解。</p><h3 id="宏任务和微任务"><a class="markdownIt-Anchor" href="#宏任务和微任务"></a> 宏任务和微任务</h3><p>主线程采用一个 循环机制，不断地从这些任务队列中取出任务并执行任务。为了解决可能出现的任务延迟，阻塞等问题，在V8内部，引入了宏任务和微任务的概念。我们把这些消息队列中的任务称为宏任务。</p><p>而对于微任务，在JS执行脚本的时候，会创建一个全局执行的上下文，在创建全局执行上下文的同时，V8引擎会创建一个微任务队列。(这个真的是队列)，然后在执行代码的时候，如果有遇到产生微任务的代码，比如Promise.resove 函数等，会将产生的微任务放置到任务队列中，在当前作用域中的代码执行完成之后，会先执行当前微任务队列中的代码，直到当前微任务代码执行完了再执行宏任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;0秒定时器&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;执行Promise&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    res()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;0000&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="comment">// 0000</span></span><br><span class="line"><span class="comment">// 执行Promise</span></span><br><span class="line"><span class="comment">// 0秒定时器</span></span><br></pre></td></tr></table></figure><p>可见从上面的代码可以看出，在成函数上下文,然后创建了微任务队列之后，开始逐行执行代码，</p><ol><li>执行了 <code>setTimeout</code> ,将此函数放入宏任务队列中。</li><li>遇到了, <code>new Promise()</code>  调用了resolve,将resolve,把resolve中要执行的代码放入微任务队列中</li><li>执行 <code>console.log('0000')</code> 输出 <code>0000</code></li><li>执行微任务队列中的代码，输出 <code>执行Promise</code></li><li>这时候浏览器出现了空闲期，开始执行宏任务，发现有定时器到时间了，执行定时器，<code>输出0秒定时器</code></li></ol><p><img src="http://blogimage.lemonlife.top/202003271955_472.png?/" alt="微任务的执行过程" /></p><h3 id="javascript宏任务的应用"><a class="markdownIt-Anchor" href="#javascript宏任务的应用"></a> JavaScript宏任务的应用</h3><blockquote><p>setTimeout</p></blockquote><p>通过之前的介绍你大概对setTimeout有一定的认识，他属于一种浏览器宏任务，但是你是否设想过，浏览器是如何知道setTimeout是如何到时间了呢。除了上述介绍的消息队列之外，浏览器还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。(说成队列只是方便大家理解，其实实际上储存定时器的数据结构可能是hashmap之类的，毕竟浏览器的每个定时器都有一个id)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// A queue for holding delayed tasks before their delay has expired.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DelayedIncomingQueue</span> &#123;</span>&#125;</span><br><span class="line">DelayedIncomingQueue delayed_incoming_queue;</span><br></pre></td></tr></table></figure><blockquote><p>定时器需要注意的问题<br />1.如果当前任务执行时间过久，会影延迟到期定时器任务的执行<br />如果你主线程中的代码和微队列中的代码执行时效过久，定时器就算事件到了也要等，之前代码执行完了再执行，参看前面 <code>0秒定时器</code>的例子。</p></blockquote><ol start="2"><li>如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒，因为在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxTimerNestingLevel = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> base::TimeDelta kMinimumInterval =</span><br><span class="line">base::TimeDelta::FromMilliseconds(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>未激活的页面，setTimeout 执行最小间隔是 1000 毫秒，未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量</li><li>延时执行时间有最大值， Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，这导致定时器会被立即执行。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot; 极客时间 &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> timerID = <span class="built_in">setTimeout</span>(showName,<span class="number">2147483648</span>);<span class="comment">// 会被理解调用执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>WebAPI：XMLHttpRequest</p></blockquote><p>当执行到let xhr = new XMLHttpRequest()后，JavaScript 会创建一个 XMLHttpRequest对象xhr，用来执行实际的网络请求操作。</p><p>浏览器调用xhr.send来发起网络请求了。你可以对照上面那张请求流程图，可以看到：渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。</p><ul><li>如果网络请求出错了，就会执行 xhr.onerror；</li><li>如果超时了，就会执行 xhr.ontimeout；</li><li>如果是正常的数据接收，就会执行 onreadystatechange 来反馈相应的状态。</li></ul><p><img src="http://blogimage.lemonlife.top/202003272119_592.png?/" alt="XMLHttpRequest 工作流程图" /></p><h3 id="javascript微任务的应用"><a class="markdownIt-Anchor" href="#javascript微任务的应用"></a> JavaScript微任务的应用</h3><blockquote><p>监听 DOM , <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver">MutationObserver</a></p></blockquote><p>对于监听DOM这件事，容易想到的是使用定时器进行轮询监听，(假设没有requestAnimationFrame) 来监听DOM变化。当然这些都会产生一个高延迟或者，资源浪费的问题。其次就是采用基于观察者模式的<code>Mutation Event</code>，在每次资源发生改变的时候，触发对应的函数钩子。虽然这种方式能解决延迟高的问题，但是频繁的去触发函数钩子，带来的就是巨大的开销。从而也能造成页面卡顿。</p><p>于是乎，后来推出 <code>Mutation Event</code>的改进版本.<code>MutationObserver</code>,采用了微任务队列，也就是当前上下文执行完成之后，才会执行<code>MutationObserver</code> 中的响应事件,有效的避免了，函数执行造成的页面上的动画卡顿。</p><blockquote><p>Promise</p></blockquote><p>做为一个单线程的语言，JavaScript,要想充分的利用计算机资源，必须要采用异步编程模型，而对于JS来说就是，渲染进程上面的主线程的事件循环系统了。页面主线程发起了一个耗时的任务，并将任务交给另外一个进程去处理，这时页面主线程会继续执行消息队列中的任务。等该进程处理完这个任务后，会将该任务添加到渲染进程的消息队列中，并排队等待循环系统的处理。</p><p><img src="http://blogimage.lemonlife.top/202003272037_430.png?/" alt="异步编程模型图" /></p><p>于是乎，为了处理消息队列中返回的事件，就产生了所谓的回调函数的机制。确保我们能正确的处理异步信息。然后就有可能产生回调地狱问题。而Promise的诞生就是想解决这种回调地狱问题。Promise内部实现的机制就是使用了微任务队列，(可以上网搜一下Promise的实现，也可以参看 <a href="https://lemonlife.top/2020/02/10/interview/#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bpromise%E4%BB%A5%E5%8F%8A%E5%86%85%E9%83%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">我的博客手写Promise</a>。可以看到里面采用了<code>setTimeout</code>，是js不提供微队列函数，只能采用setTimeout模拟一下微队列，底层的promise实现，正是把那些状态参数都放到了微队列中等待执行。</p><h3 id="使用同步的方式去写异步代码"><a class="markdownIt-Anchor" href="#使用同步的方式去写异步代码"></a> 使用同步的方式去写异步代码</h3><blockquote><p>Generator</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genDemo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot; 开始执行第一段 &quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;generator 2&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot; 开始执行第二段 &quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;generator 2&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot; 开始执行第三段 &quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;generator 2&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot; 执行结束 &quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;generator 2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;main 0&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> gen = genDemo()</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;main 1&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;main 2&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;main 3&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;main 4&#x27;</span>)</span><br></pre></td></tr></table></figure><p>可以看到使用了 Generator 的之后，我们好像可以通过<code>gen.next()</code>随意执行<code>function* genDemo</code> 函数里面的代码，然后，如果在执行函数内部代码过程中，如果遇到 yield 关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。然后在外部继续调用next,会接着上次暂停的地方继续执行，一直这样循环往复。对于这种可以随缘恢复和暂停函数的行为是基于 <strong>协程</strong> 机制。</p><p>操作系统对于资源的管理进程是开销最大的，其次是线程，协程是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。</p><p><img src="http://blogimage.lemonlife.top/202003272133_917.png?/" alt="协程执行流程图" /></p><p><strong>注意</strong></p><ol><li>gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的</li><li>对于父子协程，都有自己独立的调用栈，只不过，父协程中一直保留着子协程的调用栈信息，当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息。</li></ol><p><img src="http://blogimage.lemonlife.top/202003272139_187.png?/" alt="协程之间的切换" /></p><blockquote><p>async/await</p></blockquote><p>async/await,是Generator函数的语法糖，专门针对Promise的一种封装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="number">100</span></span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>)</span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 1 3 100 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://blogimage.lemonlife.top/202003272144_714.png?/" alt="上述 async/await 执行流程图" /></p><blockquote><p>本文是我看了<a href="https://time.geekbang.org/column/intro/216?code=wLzkK4Ecmtj435LqyZ6ecONi5PnKUst4jvEoQKp1yUA%3D">李兵老师极客时间浏览器工作原理的专栏</a>写的总结,文字和图片资料来源与极客时间.</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>按摩师~动态规划</title>
      <link href="2020/03/24/leetcode-the-masseuse-lcci/"/>
      <url>2020/03/24/leetcode-the-masseuse-lcci/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3><blockquote><p>来源：力扣（LeetCode）<br />链接：<a href="https://leetcode-cn.com/problems/the-masseuse-lcci">https://leetcode-cn.com/problems/the-masseuse-lcci</a></p></blockquote><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [1,2,3,1]</span><br><span class="line">输出： 4</span><br><span class="line">解释： 选择 1 号预约和 3 号预约，总时长 &#x3D; 1 + 3 &#x3D; 4。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [2,1,4,5,3,1,1,3]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 &#x3D; 2 + 4 + 3 + 3 &#x3D; 12。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><p>本题中 面对每一个预约，我们有只有两种选择，选或者不选。因此 我们定义变量dpy （yes）表示 选；定义dpn (no) 表示不选。</p><p>如果 目前这个预约我选了，那么之前那个预约一定是不选的， 所以 <code>dpy = dpn + nums[i]</code></p><p>如果目前这个预约我不选，不选就意味着，可以理解成当前这个预约不存在，那么决定我当前dpn的值，肯定是上一次 选和不选 两个状态中的最大值。所以 <code>dpn = Math.max(dpy,dpn)</code></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> massage = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> dpn = <span class="number">0</span> <span class="comment">// 不预约</span></span><br><span class="line">  <span class="keyword">let</span> dpy = nums[<span class="number">0</span>] <span class="comment">//预约</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    [dpn,dpy] = [<span class="built_in">Math</span>.max(dpn,dpy),dpn+nums[i]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(dpn, dpy)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="2020/03/21/regular-expression/"/>
      <url>2020/03/21/regular-expression/</url>
      
        <content type="html"><![CDATA[<blockquote><p>做自己喜欢的事保持进步。</p></blockquote><p>首先推荐两个网址，<a href="https://jex.im/regulex/#!flags=&amp;re=%5E(a%7Cb)*%3F%24">用图形化解释你写的正则</a>,<a href="https://regexr.com/">很方便测试正则的网站</a></p><p>正则表达式基础可参看<a href="https://www.runoob.com/regexp/regexp-syntax.html">菜鸟教程~正则表达式</a>,后面本文中的基础语法只是对教程中的一些解释。推荐用一小时过一遍菜鸟教程，再继续看下文。</p><h2 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h2><p>你可以把正则表达式，看成是一门编程语言，其中有一些字符，就是规定了一些基础的语法，像JavaScript的 <code>function</code> 表示函数，<code>let</code>声明变量,用 <code>+ - * / ()</code> 表示四则运算一样。</p><h3 id="基本写法和修饰符"><a class="markdownIt-Anchor" href="#基本写法和修饰符"></a> 基本写法和修饰符</h3><p>可以直接采用 <code>/正则表达式/修饰符</code> 这种,把正则表达式直接写在<code>//</code> 注释符号双斜杠中间，或者采用ES6的 <code>RegExp(&quot;正则表达式&quot;,&quot;修饰符&quot;)</code> 的形式(ES5,也有RegExp,不过没有第二个参数)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;xyz&#x27;</span>,<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">/xyz/i</span><br><span class="line"><span class="comment">//等价于ES5中的</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;/xyz/i&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="对于修饰符es5中只有igm也是比较常用的三种"><a class="markdownIt-Anchor" href="#对于修饰符es5中只有igm也是比较常用的三种"></a> 对于修饰符ES5中只有<code>igm</code>也是比较常用的三种。</h4><blockquote><p><code>i</code>表示不区分匹配的大小写，即 <code>a</code> 可以匹配到<code>A或a</code></p></blockquote><p><img src="http://blogimage.lemonlife.top/202003231105_156.png?/" alt="区分大小写匹配" /></p><p><img src="http://blogimage.lemonlife.top/202003231106_287.png?/" alt="不区分大小写匹配" /></p><blockquote><p><code>g</code> 表示全局匹配，有点递归执行函数的意思。</p></blockquote><p>如果用<code>/a/i</code> 匹配Aa,从上图可知匹配到 <code>A</code> 后，正则函数将不再继续向后执行。如果使用<code>/a/ig</code> ,匹配到<code>A</code>后将继续向后执行,匹配到a。两次匹配是相互独立的，每次匹配的结果都存在数组里面最后返回 [A,a]</p><p><img src="http://blogimage.lemonlife.top/202003231110_791.png?/" alt="全局匹配" /></p><blockquote><p><code>m</code> 表示,多行(multiline)匹配。你可能会想 <code>g</code> 全局匹配吗？为什么还要多行匹配呢？</p></blockquote><p>可以看到下图中通过g的全局匹配，我们的确匹配到了多行文本中所有的Aa(图中红色箭头是指换行符可以用<code>\x0a</code>匹配)。</p><p><img src="http://blogimage.lemonlife.top/202003231132_796.png?/" alt="" /></p><p>现在分析一下 <code>/^Aa\x0a/g</code> 这个表达式。猜猜这个会匹配到什么？(^表示必须以A字符开头)。首先肯定可以匹配到第一行的Aa。对于第二行和第三行的字符还能匹配到吗？<br /><img src="http://blogimage.lemonlife.top/202003231153_510.png?/" alt="" /></p><p>当我们全局扫描到第一行时匹配到了<code>Aa\n</code> (\n 表示末尾的换行符哈),但是我们接着往下继续扫描时候，正则表达式还记着我的第一行还有东西呢，因此再后面匹配的时候，正则表达式发现，开始的字符就不是A了，于是就停止了匹配。</p><p>如果我们加上m修饰符，能让正则表达式变成一个健忘症患者，忘记上一行的内容。那么 <code>/^Aa\x0a/gm</code> 就会是像下面这样</p><ul><li><p>第一次表达式面对的文本(\n表示换行符)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Aa\n</span><br><span class="line">Aa\n</span><br><span class="line">Aa\n</span><br></pre></td></tr></table></figure><p>匹配到<code>Aa\n</code></p></li><li><p>第二次表达式面对的文本，(忘掉了第一行)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Aa\n</span><br><span class="line">Aa\n</span><br></pre></td></tr></table></figure><p>匹配到<code>Aa\n</code></p></li><li><p>第三次表达式面对的文本，(忘掉了前两行)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aa\n</span><br></pre></td></tr></table></figure><p>匹配到<code>Aa\n</code></p></li></ul><p>所以最后我们可以看到，又成功的匹配到了三行以A开始的文本<br /><img src="http://blogimage.lemonlife.top/202003231204_357.png?/" alt="" /></p><p>下面继续分析通过<code>/^Aa\x0a$/m</code>(表示字符串必须已A开始换行符结束，中间是a)，匹配相同的文本，结果又是什么？</p><p>从上面的的分析可知，第一次正则表达式面对的是三行完整的文字，的确是A开始但是后面不满足,中间是a,结尾是换行符的条件。同样面对第二行时，也不满足条件。直到面对第三行文本的时候(此时忘记了前两行了)，刚刚好就是 <code>Aa\n</code></p><p><img src="http://blogimage.lemonlife.top/202003231212_614.png?/" alt="" /></p><h4 id="es6新增u和y修饰符"><a class="markdownIt-Anchor" href="#es6新增u和y修饰符"></a> ES6新增u和y修饰符</h4><blockquote><p>u 修饰符是针对Unicode编码的,</p></blockquote><p>为了让正则表达式能正确处理四个字节的 UTF-16 编码.类似于(<code>\ud83d\ude18</code>) 。 ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符。直接来图吧。</p><p><img src="http://blogimage.lemonlife.top/202003231605_990.png?/" alt="" /></p><p><img src="http://blogimage.lemonlife.top/202003231607_852.png?/" alt="" /></p><p>对比上面两个图, 可以先说明一下表情😘对应的Unicode编码就是 <code>\ud83d\ude18</code>,正则表达式最初的意思就是想匹配最开始的😘。<br />可是你会发现，什么情况 /^\ud83d/ 为啥也命中了这个表情，很明显就是在没有指定u修饰符的情况下，ES5 把 😘 这个可爱的表情拆成了，两个字符 <code>\ud83d</code> 和 <code>\ude18</code>。</p><p><img src="http://blogimage.lemonlife.top/202003231613_459.png?/" alt="" /></p><p><img src="http://blogimage.lemonlife.top/202003231613_746.png?/" alt="" /></p><p>果然我们加上u修饰符之后,只有<code>\ud83d\ude18</code>能匹配到 😘 了。</p><blockquote><p>除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。</p></blockquote><p>前面说过正则有点递归调用的意思，g修饰符每次进行新的调用的时候，不用在意字符串的位置，而y修饰符相当于每次都在正则表达式上加了一个 <code>^</code> 指定了，必须是开始第一个。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;AaAaAa&quot;</span></span><br><span class="line"><span class="keyword">let</span> rg = <span class="regexp">/A/g</span></span><br><span class="line"><span class="keyword">let</span> ry = <span class="regexp">/A/y</span></span><br><span class="line"><span class="keyword">let</span> ryAa = <span class="regexp">/Aa/y</span></span><br></pre></td></tr></table></figure><p>执行 <code>rg.exec(str)</code> ,可以看到字符串中的三个A都被匹配到了</p><p><img src="http://blogimage.lemonlife.top/202003231635_501.png?/" alt="" /></p><p>执行 <code>ry.exec(str)</code> ,可以看到字符串中只有第一个A被匹配到了,因为y修饰符的原因，第一次执行的时候相当于<code>/^A/</code>去匹配，匹配完之后剩下字符串aAaAa,然后<code>/^A/</code> 再去匹配。然后就什么都匹配不到了</p><p><img src="http://blogimage.lemonlife.top/202003231640_48.png?/" alt="" /></p><p>执行 <code>ryAa.exec(str)</code> ,可以看到每次都拿/Aa/y去匹配，相当于/^Aa/,然后三个Aa就都匹配到了。</p><p><img src="http://blogimage.lemonlife.top/202003231649_959.png?/" alt="" /></p><h4 id="暂不支持的s修饰符"><a class="markdownIt-Anchor" href="#暂不支持的s修饰符"></a> 暂不支持的s修饰符</h4><blockquote><p><code>s</code>修饰符(single)，意思是无论文本中有没有换行符，统一把这些文本当成一行。</p></blockquote><p><strong>友情提示一下s修饰符，现在的浏览器可能都不能支持,应该是<a href="https://baike.baidu.com/item/PCRE/7401536?fr=aladdin">PCRE</a>和ES2018 引入的语法</strong></p><p>这个修饰符与 multiline 有点相反的意思。下面我们来演示一种场景。先补充一个知识 <code>.*</code> 表示贪婪匹配，可以匹配到除换行符之外的任意字符。</p><p>定义 <code>/A.*a/g</code> 正则表达式，易知该正则表达式意思是：匹配任意位置A开始，中间可以是任何字符，最后遇到a结束。来匹配下面文本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Axxxyyya</span><br></pre></td></tr></table></figure><p>易知 上面的文本可以被完整的匹配。(即 会匹配到 Axxxyyya)</p><p><img src="http://blogimage.lemonlife.top/202003231418_437.png?/" alt="" /></p><p>如果我们把文本改成下面这个多行，会怎么样呢？正则表达式不变，还能匹配到所有文字吗？(注意上面贪婪匹配的定义)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">xxx</span><br><span class="line">yyy</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p><img src="http://blogimage.lemonlife.top/202003231427_174.png?/" alt="" /></p><p><code>/A.*a/gs</code> 正则表达式改成这样会怎么样呢。不想解释了直接看图吧，看完就知道s修饰符大概怎么用了🐶</p><p><img src="http://blogimage.lemonlife.top/202003231429_130.png?/" alt="" /></p><h3 id="其他语法"><a class="markdownIt-Anchor" href="#其他语法"></a> 其他语法</h3><blockquote><p>特殊字符，限定符之类的直接从 <a href="https://www.runoob.com/regexp/regexp-syntax.html">菜鸟教程</a> 截图了。</p></blockquote><p><img src="http://blogimage.lemonlife.top/202003231717_753.png?/" alt="特殊字符" /></p><p><img src="http://blogimage.lemonlife.top/202003231718_930.png?/" alt="限定符" /></p><p>有一点想说明一下，菜鸟教程中有说，对于一些相当于是编程语言中的保留字，概念的一些正则关键字。(\n 换行符,\t制表符，\v,垂直制表符，空格，{, 以及html左标签&lt;等…这些都是不用记的)。 对于这些特殊字符都是<a href="https://tool.oschina.net/commons?type=4">ASCII码表</a>里面有的。可以统一采用<code>\x16进制的ASCII</code>表示,比如<code>\x0a</code>表示换行符，<code>\x20</code> 匹配空格,<code>\x20*</code> 匹配任意个数的空格等。</p><p><strong>补充：边界匹配</strong><br /><code>/\bCha/</code>  匹配句子中的单词,且这个单词必须要以Cha开始。(Chapter)</p><p><code>/ter\b/</code> 匹配句子中的单词,且这个单词必须要以ter结束。(Chapter)</p><p><code>/\Bapt/</code> 匹配句子中的单词，且这个单词中间必须要有，apt字符。(可以匹配Chapter ，但是不能匹配 aptitude 因为这个单词中apt出现在，开始不再单词中间)</p><h2 id="常见的一些组合语法"><a class="markdownIt-Anchor" href="#常见的一些组合语法"></a> 常见的一些组合语法</h2><h3 id="分组"><a class="markdownIt-Anchor" href="#分组"></a> 分组</h3><p>正则表达式通过()进行分组，主要使用场景是在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace">JavaScript replace函数中</a>,</p><p>可以看到下图中 <code>/(\w+)\s(\w+)/ig</code> 根据(),将这些元素分成了两组, 然后依次对应着JS replace函数中的<code>$1,$2...</code></p><p><img src="http://blogimage.lemonlife.top/202003241114_203.png?/" alt="" /></p><ul><li>字符串前后两两交换位置</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Talk is cheap show me the code&#x27;</span></span><br><span class="line">str.replace(<span class="regexp">/(\w+)\s(\w+)/ig</span>,<span class="function">(<span class="params">_,p1,p2</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;p2&#125;</span> <span class="subst">$&#123;p1&#125;</span>`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// is Talk show cheap the me code</span></span><br></pre></td></tr></table></figure><h3 id="捕获于非捕获"><a class="markdownIt-Anchor" href="#捕获于非捕获"></a> 捕获于非捕获</h3><p>在JavaScript中我们采用$1,$2…，依次获取每个()表达式中匹配到的文本，同样用\1\2…依次引用，正则表达式中()匹配到的文本，我们把这种行为称为捕获。看图</p><p><img src="http://blogimage.lemonlife.top/202003251109_562.png?/" alt="" /></p><p><img src="http://blogimage.lemonlife.top/202003251109_87.png?/" alt="" /></p><p>如果我们不想让某一个()表达式中的内容被捕获，这个过程就称为非捕获，非捕获表达式(?:xxx),如上我们将正则表达式中的 <code>(two)</code> 改成 <code>(?:two)</code> 此时依然要匹配 <code>one,two,three,one,three</code>,应该把<code>\3</code> 改成<code>\2</code>,因为此时<code>two</code> 不会被捕获,<code>\2</code>从之前对应two变成对应three，看图就行</p><p><img src="http://blogimage.lemonlife.top/202003251131_298.png?/" alt="" /></p><p><img src="http://blogimage.lemonlife.top/202003251133_381.png?/" alt="" /></p><h3 id="前项查找"><a class="markdownIt-Anchor" href="#前项查找"></a> 前项查找</h3><p>形如 <code>待查找字符(?=&quot;查找条件)</code>, 我们把<code>(?=xxx)</code> 这种格式的式子称作条件表达式，一般我们把想要查找的字符放在，条件表达式前面。因此称为前项查找。</p><p><img src="http://blogimage.lemonlife.top/202003241237_799.png?/" alt="/lo(?=ck)/g" /></p><p><img src="http://blogimage.lemonlife.top/202003241240_909.png?/" alt="" /></p><ul><li>否定前项查找，即对条件取反的操作</li></ul><p><img src="http://blogimage.lemonlife.top/202003241243_836.png?/" alt="/lo(?!ck)/g" /><br /><img src="http://blogimage.lemonlife.top/202003241244_917.png?/" alt="" /></p><h3 id="后项查找"><a class="markdownIt-Anchor" href="#后项查找"></a> 后项查找</h3><p>同上 给两个单词，<code>condition</code>,<code>action</code>，同样只是条件表达式形式不一样，而且带查找字符，要放在条件表达式 <code>(?&lt;=xxx)</code> 后面。</p><p><img src="http://blogimage.lemonlife.top/202003241252_467.png?/" alt="/(?&lt;=ac)tion/g" /></p><ul><li>否定后项查找</li></ul><p><img src="http://blogimage.lemonlife.top/202003241253_914.png?/" alt="/(?&lt;!ac)tion/g" /></p><h3 id="逻辑处理"><a class="markdownIt-Anchor" href="#逻辑处理"></a> 逻辑处理</h3><h4 id="或"><a class="markdownIt-Anchor" href="#或"></a> 或 |,[]</h4><p>匹配 字符串 “tea,ten,test,term”。</p><p><img src="http://blogimage.lemonlife.top/202003241258_125.png?/" alt="/te(a|n|st|rm)/g" /></p><p><img src="http://blogimage.lemonlife.top/202003241259_312.png?/" alt="" /></p><p><img src="http://blogimage.lemonlife.top/202003241301_229.png?/" alt="/te[anstrm]/g" /><br /><img src="http://blogimage.lemonlife.top/202003241301_614.png?/" alt="" /></p><h4 id="非"><a class="markdownIt-Anchor" href="#非"></a> 非 [^],!</h4><p><img src="http://blogimage.lemonlife.top/202003241304_922.png?/" alt="/te[^ans]/g" /><br /><img src="http://blogimage.lemonlife.top/202003241304_809.png?/" alt="" /></p><p>!操作，参看前面的前向查找和后项查找</p><h2 id="正则表达式js应用"><a class="markdownIt-Anchor" href="#正则表达式js应用"></a> 正则表达式JS应用</h2><blockquote><p>部分案例来源于<a href="https://github.com/qdlaoyao/js-regex-mini-book">JS 正则迷你书</a>,以及<a href="https://juejin.im/post/5965943ff265da6c30653879">该书掘金地址</a></p></blockquote><h3 id="匹配千分位"><a class="markdownIt-Anchor" href="#匹配千分位"></a> 匹配千分位</h3><ul><li>解法1</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thousands</span>(<span class="params">num, sep</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(num)</span><br><span class="line">  <span class="keyword">const</span> arr = str.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> reg = <span class="regexp">/(\d+)(\d&#123;3&#125;)/</span></span><br><span class="line">  <span class="keyword">let</span> integer = arr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> decimal = arr.length &gt; <span class="number">1</span> ? <span class="string">`.<span class="subst">$&#123;arr[<span class="number">1</span>]&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">while</span> (reg.test(integer)) &#123;</span><br><span class="line">    integer = integer.replace(reg, <span class="string">&quot;$1&quot;</span> + sep + <span class="string">&quot;$2&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;integer&#125;</span><span class="subst">$&#123;decimal&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(thousands(<span class="number">1234567890000</span>,<span class="string">&#x27;,&#x27;</span>)) <span class="comment">//</span></span><br></pre></td></tr></table></figure><ul><li>解法二 利用前向查找结合 <code>/(?!^)(?=(\d&#123;3&#125;)+$)/g</code> (我们假设是正整数，小数的话，和方法一一样，分割一下就行) 或者 可以写成 <code>/(?&lt;=\d+)(?=(\d&#123;3&#125;)+$)/g</code> 以及 <code>\B(?=(\d&#123;3&#125;)+$)</code> 总之都是为了过滤边界条件</li></ul><p><img src="http://blogimage.lemonlife.top/202003250158_667.png?/" alt="/(?!^)(?=(\d{3})+$)/g" /></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;123456789&quot;</span>.replace(<span class="regexp">/(?&lt;=\d+)(?=(\d&#123;3&#125;)+$)/g</span>,<span class="string">&#x27;,&#x27;</span>) <span class="comment">// 123,456,789</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;123456789&quot;</span>.replace(<span class="regexp">/(?!^)(?=(\d&#123;3&#125;)+$)/g</span>,<span class="string">&#x27;,&#x27;</span>) <span class="comment">//  123,456,789</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="window操作系统文件路径"><a class="markdownIt-Anchor" href="#window操作系统文件路径"></a> window操作系统文件路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">F:\study\javascript\regex\regular expression.pdf</span><br><span class="line"></span><br><span class="line">F:\study\javascript\regex\</span><br><span class="line"></span><br><span class="line">F:\study\\javascript</span><br><span class="line"></span><br><span class="line">F:\</span><br><span class="line"></span><br><span class="line">F:\x*x\</span><br></pre></td></tr></table></figure><p>首先匹配盘符<code>^[a-zA-Z]:\\</code>，接着匹配文件夹，排除一些字符即可<code>[^\\:*&lt;&gt;|'&quot;?,。/]+\\</code> (假设中文标点啥的已经被排除了),文件夹可能出现很多次<code>([^\\:*&lt;&gt;|'&quot;?/]+\\)*</code>,结尾的文件夹没有 <code>\</code> , <code>([^\\:*&lt;&gt;|'&quot;?/]+)?$</code>，所以最后的正则表达式是<br /><code>^[a-zA-Z]:\\([^\\:*&lt;&gt;|'&quot;?/]+\\)*([^\\:*&lt;&gt;|'&quot;?/]+)?$</code></p><p><img src="http://blogimage.lemonlife.top/202003241746_567.png?/" alt="window操作系统文件路径" /></p><p><img src="http://blogimage.lemonlife.top/202003241747_272.png?/" alt="匹配结果" /></p><h3 id="校验密码"><a class="markdownIt-Anchor" href="#校验密码"></a> 校验密码</h3><p>规定了密码只能是，大写或者小写字母，或者是数字。且至少含有三种字符中的两种,密码位数只能是6-12位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1234567</span><br><span class="line">abcdef</span><br><span class="line">ABCDEF</span><br><span class="line">ABCDEF234</span><br><span class="line">1ABCDEF</span><br><span class="line">abcDEFG</span><br><span class="line">1abcDEF</span><br></pre></td></tr></table></figure><p>首先可以确定密码只能是大小写字母和数字组成，且位数是6~12位的情况。<code>/^[0-9A-Za-z]&#123;6,12&#125;$/</code></p><p><img src="http://blogimage.lemonlife.top/202003251002_768.png?/" alt="" /></p><p>接下来就是要防止全是数字，或者全是小写字母和全是大写字母的情况出现。很明显就是要给出合适的条件表达式，所以无法就是前项查找，或者后项查找，然而因为是排除，所以就要对查找表达式取反。</p><p>按照前项表达式可在 <code>/^[0-9A-Za-z]&#123;6,12&#125;$/</code> 前添加查找条件,如添加<code>(?!^[0-9]&#123;6,12&#125;$)</code>过滤掉都是数字的情况，同理针对大小写字母可以写出如下表达式。</p><p><code>(?!^[0-9]&#123;6,12&#125;$)(?!^[A-Z]&#123;6,12&#125;$)(?!^[a-z]&#123;6,12&#125;$)^[0-9A-Za-z]&#123;6,12&#125;$</code></p><p><img src="http://blogimage.lemonlife.top/202003251052_816.png?/" alt="前项查找" /></p><p><img src="http://blogimage.lemonlife.top/202003251052_312.png?/" alt="" /></p><p>同理也可采用后项查找，把查找条件放在表达式后面。</p><p><img src="http://blogimage.lemonlife.top/202003251054_824.png?/" alt="/[0-9A-Za-z]{6,12}$(?&lt;!^[0-9]{6,12}$)(?&lt;![a-z]{6,12})/g" /></p><h3 id="匹配日期"><a class="markdownIt-Anchor" href="#匹配日期"></a> 匹配日期</h3><p>匹配出用 <code>-</code>用做分割符的日期 <code>xxxx-xx-xx</code>,或者用 <code>/ .</code> 做为分隔符,对于<code>xxxx-xx.xx</code>这种分隔符不一致的不匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2016-06-12</span><br><span class="line">2016&#x2F;06&#x2F;12</span><br><span class="line">2016.06.12</span><br><span class="line">2016-06.12</span><br><span class="line">2016.06&#x2F;12</span><br></pre></td></tr></table></figure><p>需要引入一个方向引用的概念，在正则表达式中使用<code>\1</code>匹配第一个()表达式中的匹配到内容。 用<code>\2</code> 匹配第二个括号表达式中匹配的内容。例如正则表达式<code>/(one),(two),(three),\1,\3/g</code>直接看图吧</p><p><img src="http://blogimage.lemonlife.top/202003251109_562.png?/" alt="" /></p><p><img src="http://blogimage.lemonlife.top/202003251109_87.png?/" alt="" /></p><p>所以日期的正则表达式就容易写了 <code>/^\d&#123;4&#125;(-|\x2f|\x2e)d&#123;2&#125;\1d&#123;2&#125;$/g</code> (2f,2e是16进制47,46表示/和.) ，如下图：</p><p><img src="http://blogimage.lemonlife.top/202003251118_437.png?/" alt="" /></p><p><img src="http://blogimage.lemonlife.top/202003251118_179.png?/" alt="" /></p><h3 id="单词首字母转成大写"><a class="markdownIt-Anchor" href="#单词首字母转成大写"></a> 单词首字母转成大写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is a programming technique which will help you parallelize your code and speed up performance</span><br></pre></td></tr></table></figure><p>题目的思路很明确就是如何匹配到单词的首字母的问题，因此我们可以采用 <code>(\b\w)</code>来匹配单词首字母。</p><p><img src="http://blogimage.lemonlife.top/202003251151_238.png?/" alt="" /></p><p><img src="http://blogimage.lemonlife.top/202003251152_538.png?/" alt="" /></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleize</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.toLowerCase().replace(<span class="regexp">/(\b\w)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> c.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">titleize(<span class="string">&#x27;上述文本&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://blogimage.lemonlife.top/202003251153_928.png?/" alt="代码执行结果" /></p><h3 id="匹配ipv4地址"><a class="markdownIt-Anchor" href="#匹配ipv4地址"></a> 匹配IPv4地址</h3><p><code>((25[0-5]|2[0-4]\d|[01]?\d?\d)\.)&#123;3&#125;(25[0-5]|2[0-4]\d|[01]?\d?\d)</code></p><p><img src="http://blogimage.lemonlife.top/202003251325_470.png?/" alt="" /></p><p><img src="http://blogimage.lemonlife.top/202003251326_432.png?/" alt="IPV4匹配结果" /></p><h3 id="匹配国内身份证号"><a class="markdownIt-Anchor" href="#匹配国内身份证号"></a> 匹配国内身份证号</h3><p>身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X。</p><p><code>(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)</code></p><p><img src="http://blogimage.lemonlife.top/202003251330_597.png?/" alt="" /></p><h3 id="匹配国内手机号码"><a class="markdownIt-Anchor" href="#匹配国内手机号码"></a> 匹配国内手机号码</h3><p><a href="https://zhidao.baidu.com/question/434432697263212804.html">三大运营商号码段~2019年</a></p><p>170为虚拟号码要排除，166,198,199 是新增号码段，所以正则表达式为</p><p><code>/^(?!170)^((13|14|15|17|18)[0-9]|166|198|199)\d&#123;8&#125;$/g</code></p><p><img src="http://blogimage.lemonlife.top/202003251346_11.png?/" alt="" /></p><p><img src="http://blogimage.lemonlife.top/202003251344_947.png?/" alt="匹配结果" /></p><h3 id="座机号码匹配"><a class="markdownIt-Anchor" href="#座机号码匹配"></a> 座机号码匹配</h3><p>注意开始符号<code>^</code>和结束符号 <code>$</code> 的位置，注意不要把 <code>/^((\d&#123;3&#125;-)?\d&#123;8&#125;|(\d&#123;4&#125;-)?\d&#123;7&#125;)$/g</code>  写成了<code>/^(\d&#123;3&#125;-)?\d&#123;8&#125;|(\d&#123;4&#125;-)?\d&#123;7&#125;$/g</code>  ,这和正则表达式运算符优先级有关，不细说了直接看图</p><p><img src="http://blogimage.lemonlife.top/202003251354_853.png?/" alt="正确的写法" /></p><p><img src="http://blogimage.lemonlife.top/202003251355_657.png?/" alt="错误的写法" /></p><p><img src="http://blogimage.lemonlife.top/202003251356_902.png?/" alt="匹配结果" /></p>]]></content>
      
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器工作原理-chrome篇</title>
      <link href="2020/03/21/web-fundamentals-geektime/"/>
      <url>2020/03/21/web-fundamentals-geektime/</url>
      
        <content type="html"><![CDATA[<h3 id="chrome架构"><a class="markdownIt-Anchor" href="#chrome架构"></a> chrome架构</h3><p><strong>问题1</strong>  只是打开了 1 个页，chrome启动了4个进程(在浏览器打开第一个页面的时候，且没有其他插件，音频的时候)</p><p><img src="http://blogimage.lemonlife.top/202003192140_995.png?/" alt="Chrome 的任务管理器窗口" /><br /><strong>进程与线程的特点</strong></p><ol><li>线程是不能单独存在的，它是由进程来启动和管理的</li><li>一个进程就是一个程序的运行实例,是操作系统分配资源的最小单元，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程</li><li>进程中的任意一线程执行出错，都会导致整个进程的崩溃。</li><li>线程之间可以共享进程中的数据，线程之间可以对自身进程中的公共数据进行读写操作</li><li>当一个进程关闭之后，操作系统会回收进程所占用的内存</li><li>进程之间的内容相互隔离，进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了。(前端框架Electron)</li></ol><p><strong>现代化的浏览器进程架构</strong></p><p><img src="http://blogimage.lemonlife.top/202003192202_530.png?/" alt="最新的 Chrome 进程架构图" /></p><p><strong>浏览器进程。</strong> 主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</p><p><strong>渲染进程。</strong> 核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p><p>**GPU 进程。**其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p><p>**网络进程。**主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</p><p>**插件进程。**主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</p><blockquote><p>因此打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p></blockquote><p><strong>process-per-site-instance策略</strong></p><p>通常情况下是一个页面使用一个进程，但是，有一种情况，叫&quot;同一站点(same-site)&quot;，具体地讲，我们将“同一站点”定义为根域名（例如，<a href="http://geekbang.org">geekbang.org</a>）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;time.geekbang.org</span><br><span class="line">https:&#x2F;&#x2F;www.geekbang.org</span><br><span class="line">https:&#x2F;&#x2F;www.geekbang.org:8080</span><br></pre></td></tr></table></figure><p>都是属于同一站点，因为它们的协议都是https，<a href="http://xn--geekbang-fq0m528bmhkkj7b1sfuv7g3dtc.org">而根域名也都是geekbang.org</a>。你也许了解同源策略，但是同一站点和同源策略还是存在一些不同地方，在这里你需要了解它们不是同一件事就行了。<br />Chrome的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。</p><p>直白的讲，就是如果几个页面符合同一站点，那么他们将被分配到一个渲染进程里面去。<br />所以，这种情况下，一个页面崩溃了，会导致同一站点的页面同时崩溃，因为他们使用了同一个渲染进程。</p><p>在一个渲染进程里面，他们就会共享JS的执行环境，也就是说A页面可以直接在B页面中执行脚本。因为是同一家的站点，所以是有这个需求的。</p><p><strong>iframe</strong></p><p>如果页面里有iframe的话，iframe也会运行在单独的进程中，下图是我浏览器任务管理器的一个截图，图中的辅助框架应该就是指页面中的 <code>iframe</code> 标签对应的地址</p><p><img src="http://blogimage.lemonlife.top/202003192230_498.png?/" alt="贴上我自己电脑里面的一张图" /></p><p><strong>未来面向服务的架构</strong></p><p>为了解决这些问题，在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称SOA）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型图。</p><p><img src="http://blogimage.lemonlife.top/202003192317_372.png?/" alt="" /></p><h3 id="浏览器中的http协议"><a class="markdownIt-Anchor" href="#浏览器中的http协议"></a> 浏览器中的HTTP协议</h3><p>TCP和HTTP的关系，以及TCP三次握手四次挥手等，可以见我博客有关网络的文章。</p><h4 id="浏览器的缓存机制"><a class="markdownIt-Anchor" href="#浏览器的缓存机制"></a> 浏览器的缓存机制</h4><p>HTTP/1.1定义的 <code>Cache-Control</code> 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。</p><p><strong>禁止进行缓存</strong> <code>Cache-Control: no-store</code></p><p>缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。</p><p><strong>强制确认缓存</strong> <code>Cache-Control: no-store</code></p><p>如下头部定义，此方式下，每次有请求发出时，缓存会将此请求发到服务器（该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（实际就是返回304），则缓存才使用本地缓存副本。</p><p><strong>私有缓存和公共缓存</strong> <code>Cache-Control: private/public</code></p><p>“public” 指令表示该响应可以被任何中间人（译者注：比如中间代理、CDN等）缓存。若指定了&quot;public&quot;，则一些通常不被中间人缓存的页面（译者注：因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定状态码的页面），将会被其缓存。</p><p><strong>缓存过期机制</strong> <code>Cache-Control: max-age=资源有效时间(s)</code></p><p>max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。</p><p><strong>协商缓存</strong><br />协商缓存主要涉及请求头设置中的，Etag和 Last-Modified。可以在响应头中设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">etag: &#39;xxxxxx&#39;</span><br><span class="line">last-modified: Mon, 20 Dec 2019 09:49:49 GMT</span><br></pre></td></tr></table></figure><p>etag：每个文件有一个，改动文件了就变了，就是个文件hash，每个文件唯一，就像用webpack打包的时候，每个资源都会有这个东西，如： app.js打包后变为 app.xxxx.js，加个唯一hash，也是为了解决缓存问题。<br /><code>发请求--&gt;本地判断资源是否过期--&gt;过期--&gt;请求服务器--&gt;服务器对比资源是否真的过期--&gt;没过期--&gt;返回304状态码--&gt;客户端使用缓存资源</code> (如果服务器资源已经过期,服务器会返回200)</p><p><img src="http://blogimage.lemonlife.top/202003200041_288.png?/" alt="缓存查找流程示意图" /></p><h4 id="浏览器端发起-http-请求流程"><a class="markdownIt-Anchor" href="#浏览器端发起-http-请求流程"></a> 浏览器端发起 HTTP 请求流程</h4><h5 id="构建请求"><a class="markdownIt-Anchor" href="#构建请求"></a> 构建请求</h5><p>首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index.html HTTP1.1</span><br></pre></td></tr></table></figure><h5 id="查找缓存"><a class="markdownIt-Anchor" href="#查找缓存"></a> 查找缓存</h5><p>在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件,具体缓存的操作，上文已经说过了,如果缓存失效或者没缓存，就会进入网络请求过程了。</p><h5 id="准备-ip-地址和端口"><a class="markdownIt-Anchor" href="#准备-ip-地址和端口"></a> 准备 IP 地址和端口</h5><p>浏览器会请求 DNS 返回域名对应的 IP。当然浏览器还提供了DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求</p><h5 id="等待-tcp-队列"><a class="markdownIt-Anchor" href="#等待-tcp-队列"></a> 等待 TCP 队列</h5><p>Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。</p><h5 id="建立-tcp-连接"><a class="markdownIt-Anchor" href="#建立-tcp-连接"></a> 建立 TCP 连接</h5><p>三次握手</p><h5 id="发送-http-请求"><a class="markdownIt-Anchor" href="#发送-http-请求"></a> 发送 HTTP 请求</h5><p>一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。</p><p><img src="http://blogimage.lemonlife.top/202003200034_510.png?/" alt="HTTP 请求数据格式" /></p><h4 id="服务器端处理-http-请求流程"><a class="markdownIt-Anchor" href="#服务器端处理-http-请求流程"></a> 服务器端处理 HTTP 请求流程</h4><p><img src="http://blogimage.lemonlife.top/202003200038_19.png?/" alt="" /></p><h4 id="断开连接"><a class="markdownIt-Anchor" href="#断开连接"></a> 断开连接</h4><p>四次挥手，通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了<code>Connection:Keep-Alive</code>。那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。</p><p><img src="http://blogimage.lemonlife.top/202003192344_989.png?/" alt="HTTP 请求流程示意图" /></p><h3 id="浏览器渲染流程"><a class="markdownIt-Anchor" href="#浏览器渲染流程"></a> 浏览器渲染流程</h3><p>可以参看我的博客 <a href="http://lemonlife.top/2020/02/21/web-fundamentals/">浏览器工作原理~渲染篇</a> 和 <a href="http://lemonlife.top/2020/02/23/web-fundamentals-optimize/">浏览器工作原理~优化篇</a></p><blockquote><p>看完上面的部分，你对浏览器应该已经有了一个大概的了解了，应该也知道从一个网址变成一个网页这些大概是经历了哪些流程。后面我们将介绍，浏览器具体每一块是如何工作的，以及怎么优化页面的显示</p></blockquote><h3 id="浏览器中的js"><a class="markdownIt-Anchor" href="#浏览器中的js"></a> 浏览器中的JS</h3><blockquote><p>这一块我应该只会大概的写一下，想要；了解具体的可以去看看，这个极客时间的专题，或者 <a href="https://yangbo5207.github.io/wutongluo/ji-chu-jin-jie-xi-lie/yi-3001-nei-cun-kong-jian-xiang-jie.html">GitHub上这个大佬的博客</a> 的一到六节，感觉都是非常好的资料。</p></blockquote><h4 id="v8与javascript"><a class="markdownIt-Anchor" href="#v8与javascript"></a> V8与JavaScript</h4><blockquote><p>前端的小伙伴应该都知道，JS在chrome中是通过V8引擎进行编译的。</p></blockquote><p><strong>JS内模型</strong></p><p>对于JS语言本身来说,是一种动态的弱类型语言，意味着我们在定义一个变量时候，不需要告诉解析引擎这个变量的类型是什么，JS引擎在运行代码的时候，引擎自己计算出数据的类型。而且可以使用一个变量来保存不同类型的数据。<br />JavaScript的数据类型有8种,(基础数据类型是7种)。</p><p>对于 <code>Boolean</code> <code>Null</code> <code>Undefined</code> <code>Number</code> <code>BigInt</code>  <code>String</code>  <code>Symbol</code> 这七种数据基础类型是储存在内存的栈空间中的，而<code>Object</code> 这种引用数据类型是储存在堆空间中的。(此处的栈，和堆，指的是内存空间。注意和方法调用的时候的堆栈区分)。</p><p><img src="http://blogimage.lemonlife.top/202003211302_206.png?/" alt="JS内存模型" /></p><p>在函数执行期间，对于储存在栈空间中的基础数据类型变量，是直接被直接赋值到函数的调用栈中，对于堆空间中的引用类型变量，把变量的地址赋值到函数的调用栈中。</p><p><img src="http://blogimage.lemonlife.top/202003211305_429.png?/" alt="函数调用模型" /></p><blockquote><p>所以我觉得 js 本身其实没有，堆内存和栈内存的区别，只有基础数据类型和引用数据类型的区别。</p></blockquote><p><strong>代码的两个阶段</strong></p><p>对于JavaScript代码运行，分为<code>代码的创建阶段</code> 和 <code>代码的执行阶段</code>,最常见的就是变量提升问题。对于一个JS函数。在代码创建阶段会提前把，函数中声明的变量都创建成<code>undefined</code>值。再在代码的执行阶段，对<code>undefined</code> 进行赋值。</p><ul><li>代码中的函数变量除外，函数变量都是直接在创建阶段赋值的</li><li>S6没有变量提升的问题,不是因为没有代码的创建阶段，而是因为ES6 引入了一个暂时性死区的机制。</li></ul><p>可以看下面那个例子函数 <code>foo</code> ，当代码运行到 <code>var bar = foo()</code> 时候。代码会先创建 <code>myName</code> <code>test</code> <code>innerBar</code> 三个变量。</p><p><img src="http://blogimage.lemonlife.top/202003211711_280.png?/" alt="代码创建过程" /></p><p>在代码的执行阶段，会依次对这三个变量进行赋值。当代码执行到 <code>return innerBar</code> 的时候，此时三个变量已经赋值完成。</p><p><img src="http://blogimage.lemonlife.top/202003211719_506.png?/" alt="代码的执行阶段" /></p><p><strong>闭包机制</strong></p><p>闭包就不介绍了，直接看下面这个函数吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">    <span class="keyword">var</span> test = <span class="string">&#x27;test&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> innerBar = &#123; </span><br><span class="line">     setName:<span class="function">(<span class="params">newName</span>)=&gt;</span>&#123;</span><br><span class="line">         myName = newName</span><br><span class="line">         <span class="built_in">console</span>.log(test) <span class="comment">//test       </span></span><br><span class="line">     &#125;,</span><br><span class="line">     getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> myName</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerBar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo()</span><br><span class="line">bar.setName(<span class="string">&quot; 极客&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(bar.getName()) <span class="comment">//极客</span></span><br></pre></td></tr></table></figure><p>正常逻辑我们再执行完<code>bar = foo()</code>之后 代码应该执行完毕了。此时,应该无法访问到变量test,和myName了，因为在一个函数执行完了他内部的变量也应该被释放掉。但是根据函数的执行结果可以判断，变量依旧可以被正常的能被访问，这就是典型的<strong>闭包</strong>机制。</p><p>首先产生闭包是在函数的执行阶段，发现了某个子函数对自身变量有引用，就会在堆内存再创建一个闭包对象 <code>Clourse(自身函数名)</code>，对于这个闭包对象的值，我认为储存的是本身函数调用的变量的指针,对于基础数据类型肯定都是直接复制。</p><p>(此处，有文档认为是把内存中的变量都复制了一遍到这个闭包对象中，然后函数运行结束的时候,函数里面的变量都被回收了,但是闭包堆内存没有被回收，因此产生了闭包现象。我没有读过V8源码，但是我觉得代码底层应该不会有这种没有意义的复制)</p><p>对于上面的例子也就是，当 <code>foo</code> 函数执行完 <code>var innerBar =</code> 之后。会生成 <code>Closure (foo)</code> 对象,然后在<code>setName</code> 和 <code>getName</code> 这两个对象上都绑定上生成的  <code>Closure (foo)</code> 。</p><p><img src="http://blogimage.lemonlife.top/202003211910_165.png?/" alt="foo函数执行情况" /></p><p>最后在我们执行 <code>bar.setName(&quot; 极客&quot;)</code> 和 <code>bar.getName()</code> 的时候 在setName函数的创建过程中，可以看到函数里面已经有了对象 ，<code>Closure (foo)</code>，然后再在函数的执行阶段重复之前分析的函数执行阶段的赋值操作。</p><p><img src="http://blogimage.lemonlife.top/202003211917_421.png?/" alt="setName 函数的创建阶段" /></p><h4 id="v8的垃圾回收gc"><a class="markdownIt-Anchor" href="#v8的垃圾回收gc"></a> v8的垃圾回收(GC)</h4><blockquote><p>首先值得庆幸的是，V8是自动管理垃圾回收的。某个函数执行完成之后，指向该函数的函数指针(ESP)就会指向下一个函数，该函数的执行上下文会从堆内存销毁掉。</p></blockquote><p>V8会把堆分层新生代和老生代 (代际假说)，新生代收集器也称副垃圾收集器，老生代也称主垃圾收集器。新生代存放的都是生存时间短的对象，老生代中存放的都是生存时间久的对象。新生代区通常只支持1~8M的容量，老生区支持的容量会大很多。</p><p><strong>垃圾收集器工作流程</strong></p><ul><li>标记空间中的活动对象和非活动对象,根据当前这个对象是否还被引用，也就是是否还在使用进行判断。</li><li>回收非活动对象所占据的内存。其实就是清理上一步中被标记的可回收对象。</li><li>内存整理，因为清除完可回收的之后，就好像一整块拼图中，你随机抠掉了几块后，会出现很多不连续的片段，因此为了方便后续程序，使用我们要进行内存整理。</li></ul><p><strong>新生代回收过程</strong></p><p><img src="http://blogimage.lemonlife.top/202003212142_450.png?/" alt="新生区被划分为对象区域和空闲区域" /></p><p>新增的对象都会被放在新生代的对象区，然后经历，一标记，二回收，之后整理的时候是将对象区剩下的变量复制到空闲区，这样就得到了,空内存的对象区和有对象且内存连续的空闲区，再把此时的对象区，空闲区身份交换。继续写入新变量进行下一轮GC。（不得不说这里真的很佩服这个垃圾收集器的设计思路，身份交换的想法，能让新生代中的这两块区域无限重复使用下去）</p><p>如果有个对象经历了两轮垃圾回收，还在新生区，就会将此对象移入老生区（对象晋升策略）</p><p><strong>老生区回收过程</strong></p><p>主垃圾收集器，主要采用 <b>标记-清除（Mark-Sweep)</b> 的方式进行垃圾回收。标记清除的过程和之前差不多，但是不同的是，老生区不是通过复制对象来整理内存的，因为老生区内存大，对象多，复制整理会很耗时。老生区是在多次标记之后，将老生区的存活对象，朝着老生区的一段移动。然后直接一次性清除掉其他地方的对象。这一过程被称为 <b>标记-整理</b> ,下面我画了一个大致流程。(假设按图中可以直接清除左边两列之外的列)</p><p><img src="http://blogimage.lemonlife.top/202003212305_912.png?/" alt="标记和清除的过程" /></p><p><strong>全停顿</strong></p><p>因为JavaScript运行在V8的主线程之上，所以一旦执行了垃圾回收算法。都需要将正在执行的JavaScript代码暂停。等待垃圾回收完再执行，这种行为被称作 <strong>全停顿(Stop-The-World)</strong></p><p>因为新生代本来内存小,变量少GC不会有太大影响。所以为了降低老生代GC造成的卡顿，V8把标记过程分成一个个子标记过程。同时让垃圾回收标记和JavaScript应用逻辑交替进行，直到标记移动完成,感觉这种整块舍弃的思路，清理起来应该挺快。主要耗时应该就是标记和移动(<strong>增量标记算法</strong>)。</p><h3 id="v8的编译期和解释器"><a class="markdownIt-Anchor" href="#v8的编译期和解释器"></a> V8的编译期和解释器</h3><p>因为我们写的是高级语言，而机器只能识别二进制机器码，所以我们需要用解释器和编译器把我们写的代码翻译成机器码。按语言的执行流程，可以把编程语言分为编译期语言和解释型语言。</p><p><strong>编译型语言</strong> 在程序执行之前，需要经过编译期的编译过程，并且编译之后会直接保留机器能读懂二进制文件，每次运行程序时，都可以直接运行二进制文件，不需要再次重新编译了.(C/C++、GO)</p><p><img src="http://blogimage.lemonlife.top/202003220954_620.png?/" alt="编译型语言的过程" /></p><p><strong>解释型语言</strong> 在每次运行时都需要通过解释器对程序进行动态的解释和执行。(Python,JavaScript)</p><p><img src="http://blogimage.lemonlife.top/202003221009_316.png?/" alt="解释型语言的过程" /></p><h4 id="v8是如何执行一段javascript代码"><a class="markdownIt-Anchor" href="#v8是如何执行一段javascript代码"></a> V8是如何执行一段JavaScript代码</h4><p>V8在执行过程中既有 解释器(lgnition) ,又有 解释器(TurboFan)</p><p><img src="http://blogimage.lemonlife.top/202003221022_904.png?/" alt="V8执行一段代码流程图" /></p><h4 id="生成抽象语法树ast和执行上下文"><a class="markdownIt-Anchor" href="#生成抽象语法树ast和执行上下文"></a> 生成抽象语法树(AST)和执行上下文</h4><p>源代码经过词法分析和与分析之后会生成抽象语法树(AST)，推荐一个可以生成<a href="https://resources.jointjs.com/demos/javascript-ast">AST网站</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">console</span>.log</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><p>AST的结构和代码结构非常相似，编译期或者解释器后续的工作依赖于AST，而不是源代码。在JavaScript中最典型的是Babel和ESLint。</p><p>Babel将ES6转成ES5代码的过程，就是先将ES6代码转成AST,然后再将ES6语法生成的AST转换成ES5的AST (Babel的代码库里有函数，能把ES6的代码复写成ES5的代码)</p><p><img src="http://blogimage.lemonlife.top/202003221034_422.png?/" alt="上述代码生成的AST" /></p><p>ESLint第一阶段是词法分析(tokenize),将一行行的源码拆解成一个个token。(语法上不可以再分的最小字符和字符串),图中 <code>var</code> <code>myName</code> <code>=</code>&quot; <code>极客时间</code> 这四个都是四个token。</p><p><img src="http://blogimage.lemonlife.top/202003221123_690.png?/" alt="生成Token" /></p><p>第二个阶段是语法分析(parse),作用是将上一步生成的token数据，根据语法规则转为AST。如果源码符合语法规则，会顺利生成Token，如果源码存在语法错误，这一步就会终止，并抛出一个&quot;语法错误&quot;。成功生成了AST后，V8就会生成该段代码的执行上下文。</p><h4 id="生成字节码"><a class="markdownIt-Anchor" href="#生成字节码"></a> 生成字节码</h4><p>解释器lgnition，可以转换成AST生成字节码，并解释执行字节码。字节码是介于AST和机器码之间的一种代码。比机器码占用的内存要少很多，字节码需要通过解释器将其转成机器码才能执行。</p><p><img src="http://blogimage.lemonlife.top/202003221240_926.png?/" alt="字节码机器码内存占用对比" /></p><p>(这一段我猜测一下，之前的V8模型可能是，AST转换生成机器码，然后再执行机器码，就会出现机器码被储存在内存中的现象；但是现在是AST转换从字节码，在运行到某个字节码片段时，直接把字节码转成机器码然后执行,这个过程堆积在内存中的只是字节码，机器码一生成就会被消费掉，所以节约了内存)</p><h4 id="执行代码"><a class="markdownIt-Anchor" href="#执行代码"></a> 执行代码</h4><p>生成代码之后，到了代码的执行阶段。解释器会逐条消费字节码。在执行字节码的过程中，如果有经常被执行的字节码（热点代码 HotSpot）。也会被后台编译器（TurboFan）转换成更高效的机器码，以后再遇到这段代码时，直接运生成的行机器码即可。这种将解释器和编译器结合使用的技术称作<strong>即时编译（JIT）</strong></p><p><img src="http://blogimage.lemonlife.top/202003221313_799.png?/" alt="即时编译 JIT 技术" /></p><blockquote><p>本文是我看了<a href="https://time.geekbang.org/column/intro/216?code=wLzkK4Ecmtj435LqyZ6ecONi5PnKUst4jvEoQKp1yUA%3D">李兵老师极客时间浏览器工作原理的专栏</a>写的总结,文字和图片资料来源与极客时间，不得不说这个专题，作者的工作经历真的丰富。这篇博客大概概括的写了专栏的一至四节，this的指向性没有涉及(因为我觉得在es6的诞生后this的指向已经比较明确了)。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法之美</title>
      <link href="2020/03/19/geektime-arithmetic/"/>
      <url>2020/03/19/geektime-arithmetic/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2><h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3><p>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p><h3 id="数组的储存"><a class="markdownIt-Anchor" href="#数组的储存"></a> 数组的储存</h3><p>由定义可知，计算机给数组开辟一个连续的内存空间，会给数组的首地址，分配一个内存地址，接下来的地址，首地址加上被访问元素之前元素的数据类型大小之和，即<code>a[i]_address = base_address + i * data_type_size</code> 如下图我们假设<code>int</code>数据,每个数据大小占4个字节</p><p><img src="http://blogimage.lemonlife.top/202003191137_954.png?/" alt="" /></p><h3 id="数组和链表的区别"><a class="markdownIt-Anchor" href="#数组和链表的区别"></a> 数组和链表的区别</h3><p>数组区别与链表是数组支持随机访问，随机访问的时间复杂度是O(1);(注意不是查找,查找最适合的是哈希表，不是数组),链表支持元素的快速的插入或者删除。</p><p>数组需要一块连续的内存空间来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。</p><p>而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。</p><p><img src="http://blogimage.lemonlife.top/202003191427_188.png?/" alt="链表和数组的内存分布" /></p><blockquote><p>此篇文章文字，图片资料来源于<a href="https://time.geekbang.org/column/intro/126">极客时间算法与数据结构之美</a>专题<br /><a href="https://github.com/wangzheng0822/algo">项目github地址</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵中的路径</title>
      <link href="2020/03/18/ju-zhen-zhong-de-lu-jing/"/>
      <url>2020/03/18/ju-zhen-zhong-de-lu-jing/</url>
      
        <content type="html"><![CDATA[<h3 id="矩阵路径"><a class="markdownIt-Anchor" href="#矩阵路径"></a> 矩阵路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</span><br><span class="line"></span><br><span class="line">[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;],</span><br><span class="line">[&quot;s&quot;,&quot;f&quot;,&quot;c&quot;,&quot;s&quot;],</span><br><span class="line">[&quot;a&quot;,&quot;d&quot;,&quot;e&quot;,&quot;e&quot;]</span><br><span class="line"></span><br><span class="line">但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</span><br></pre></td></tr></table></figure><ul><li>案例1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]],   </span><br><span class="line"></span><br><span class="line">word &#x3D; &quot;ABCCED&quot;</span><br><span class="line"></span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><h3 id="解决思路"><a class="markdownIt-Anchor" href="#解决思路"></a> 解决思路</h3><p>遇到路径矩阵问题,基本就是递归加dfs,或者采用循环加队列的形式，此题要注意的就是，不同路线的单词都是可以复用的，而不是那种只能访问一次，只是在某一条路线中，单词只能访问一次</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var exist &#x3D; function (board, word) &#123;</span><br><span class="line">  let res &#x3D; false;</span><br><span class="line">  function dfs(i, j, k) &#123;</span><br><span class="line">    if (k &#x3D;&#x3D;&#x3D; word.length - 1) return true;</span><br><span class="line">    board[i][j] &#x3D; &quot;#&quot;</span><br><span class="line">    &#x2F;&#x2F;上</span><br><span class="line">    if (i - 1 &gt;&#x3D; 0 &amp;&amp; board[i - 1][j] &#x3D;&#x3D;&#x3D; word[k + 1]) &#123;</span><br><span class="line">      res &#x3D; res || dfs(i - 1, j, k + 1)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;下</span><br><span class="line">    if (i + 1 &lt; board.length &amp;&amp; board[i + 1][j] &#x3D;&#x3D;&#x3D; word[k + 1]) &#123;</span><br><span class="line">      res &#x3D; res || dfs(i + 1, j, k + 1)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;左    </span><br><span class="line">    if (j - 1 &gt;&#x3D; 0 &amp;&amp; board[i][j - 1] &#x3D;&#x3D;&#x3D; word[k + 1]) &#123;</span><br><span class="line">      res &#x3D; res || dfs(i, j - 1, k + 1)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;右</span><br><span class="line">    if (j + 1 &lt; board[0].length &amp;&amp; board[i][j + 1] &#x3D;&#x3D;&#x3D; word[k + 1]) &#123;</span><br><span class="line">      res &#x3D; res || dfs(i, j + 1, k + 1)</span><br><span class="line">    &#125;</span><br><span class="line">    board[i][j] &#x3D; word[k]</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">  for (let i &#x3D; 0; i &lt; board.length; i++) &#123;</span><br><span class="line">    for (let j &#x3D; 0; j &lt; board[0].length; j++) &#123;</span><br><span class="line">      if (board[i][j] &#x3D;&#x3D;&#x3D; word[0]) &#123;</span><br><span class="line">        if (dfs(i, j, 0) &#x3D;&#x3D;&#x3D; true) &#123;</span><br><span class="line">          return true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零钱兑换</title>
      <link href="2020/03/08/leetcode-322/"/>
      <url>2020/03/08/leetcode-322/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><h3 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h3><blockquote><p>待解答😵😵😵😵</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><h4 id="动态规划法"><a class="markdownIt-Anchor" href="#动态规划法"></a> 动态规划法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">coins</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">amount</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> coinChange = <span class="function"><span class="keyword">function</span> (<span class="params">coins, amount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(amount === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> res = [<span class="number">0</span>]</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">temp</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="built_in">Number</span>.MAX_VALUE</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> index = i - coins[j]</span><br><span class="line">      <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; res.length &amp;&amp; res[index] &lt; min) &#123;</span><br><span class="line">        min = res[index]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">    res[i] = temp(i) + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res[amount] &gt; amount ? -<span class="number">1</span> : res[amount]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="贪心回溯方法"><a class="markdownIt-Anchor" href="#贪心回溯方法"></a> 贪心+回溯方法</h4><blockquote><p>来源：力扣（LeetCode）<br />链接：<a href="https://leetcode-cn.com/problems/coin-change">https://leetcode-cn.com/problems/coin-change</a><br />著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和为s的连续正数序列</title>
      <link href="2020/03/06/leetcode-lian-xu-zheng-shu-lcof/"/>
      <url>2020/03/06/leetcode-lian-xu-zheng-shu-lcof/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</span><br><span class="line"></span><br><span class="line">序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target &#x3D; 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target &#x3D; 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><p>先把数分解9=1+8=2+7=3+6=4+5,按这种，找到可能组成正确结果的数组，根据数的结构，易知结果可能存在<code>[1,2,3,4,5]</code>中，不难发现数组最后一个数,如果target是偶数就是<code>target/2</code>,如果是奇数就是<code>target/2</code>取整加一，即<code>Math.floor(target/2)+1</code> 或采用二进制取整<code>(target/2 | 0) + 1</code>,再对找到的数组采用滑动窗口模型，找出答案。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findContinuousSequence = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = target % <span class="number">2</span> === <span class="number">0</span> ? target / <span class="number">2</span> : (target / <span class="number">2</span> | <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">let</span> temp = []</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= index; i++) &#123;</span><br><span class="line">    temp.push(i)</span><br><span class="line">    sum = sum + i</span><br><span class="line">    <span class="keyword">while</span> (sum &gt; target) &#123;</span><br><span class="line">      sum -= temp[<span class="number">0</span>]</span><br><span class="line">      temp.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">      temp.length &gt;= <span class="number">2</span> &amp;&amp; res.push([...temp])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br />链接：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof</a><br />著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腐烂的橘子</title>
      <link href="2020/03/04/leetcode-994/"/>
      <url>2020/03/04/leetcode-994/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p><img src="http://blogimage.lemonlife.top/202003040932_499.png?/" alt="图片来源LeetCode" /></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在给定的网格中，每个单元格可以有以下三个值之一：</span><br><span class="line"></span><br><span class="line">值 0 代表空单元格；</span><br><span class="line">值 1 代表新鲜橘子；</span><br><span class="line">值 2 代表腐烂的橘子。</span><br><span class="line">每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</span><br><span class="line"></span><br><span class="line">返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[[0,2]]</span><br><span class="line">输出：0</span><br><span class="line">解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><p>你站在这别动，我去买几个橘子😂😂😂</p><ol><li>写一个函数把 每次坏掉的橘子记录下来，存在数组里面，函数的返回值是坏掉橘子的位置,组成的数组<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="number">2</span>) &#123;</span><br><span class="line">        arr.push([i, j])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>定义一个 坏橘子的操作,取出上面统计的结果，循环遍历每个元素,把数组中的每个坏橘子，周围的好橘子腐烂掉。<br />每次，所有的腐烂操作结束后，再进行一次，统计坏橘子的位置，如果发现，统计函数返回的坏橘子的位置数组，和上次一样。说明能被腐烂的已经全腐烂了，此时返回times(即bad函数被调用的次数-1),否则继续调用bad函数，进行坏橘子的操作。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> times = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> badsArr = count(grid)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bad</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  badsArr.forEach(<span class="function">(<span class="params">[i, j]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">      grid[i - <span class="number">1</span>][j] = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; grid.length &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">      grid[i + <span class="number">1</span>][j] = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] ==<span class="number">1</span>) &#123;</span><br><span class="line">      grid[i][j - <span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j + <span class="number">1</span> &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[i][j + <span class="number">1</span>] ==<span class="number">1</span>) &#123;</span><br><span class="line">      grid[i][j + <span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> newBadsArr = count(grid)</span><br><span class="line">  <span class="keyword">if</span> (newBadsArr.length === badsArr.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    times++</span><br><span class="line">    badsArr = newBadsArr</span><br><span class="line">    <span class="keyword">return</span> bad()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">bad()</span><br></pre></td></tr></table></figure></li><li>上述，两个过程都结束之后，我们再次看一下现在的二维橘子数组，如果在数组里面，找到了好的橘子。说明，没完全腐烂成功，返回 <code>-1</code>,否则 返回 <code>times</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j] === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="完整代码如下"><a class="markdownIt-Anchor" href="#完整代码如下"></a> 完整代码如下</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> orangesRotting = <span class="function"><span class="keyword">function</span> (<span class="params">grid</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] === <span class="number">2</span>) &#123;</span><br><span class="line">          arr.push([i, j])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> times = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> badsArr = count(grid)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bad</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    badsArr.forEach(<span class="function">(<span class="params">[i, j]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">        grid[i - <span class="number">1</span>][j] = <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i + <span class="number">1</span> &lt; grid.length &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">        grid[i + <span class="number">1</span>][j] = <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] ==<span class="number">1</span>) &#123;</span><br><span class="line">        grid[i][j - <span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (j + <span class="number">1</span> &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[i][j + <span class="number">1</span>] ==<span class="number">1</span>) &#123;</span><br><span class="line">        grid[i][j + <span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> newBadsArr = count(grid)</span><br><span class="line">    <span class="keyword">if</span> (newBadsArr.length === badsArr.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> times</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      times++</span><br><span class="line">      badsArr = newBadsArr</span><br><span class="line">      <span class="keyword">return</span> bad()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bad()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> times</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>题目来源：力扣（LeetCode）<br />链接：<a href="https://leetcode-cn.com/problems/rotting-oranges">https://leetcode-cn.com/problems/rotting-oranges</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的序列化与反序列化</title>
      <link href="2020/03/01/leetcode-297/"/>
      <url>2020/03/01/leetcode-297/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">你可以将以下二叉树：</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">序列化为 &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure><h3 id="解决思路"><a class="markdownIt-Anchor" href="#解决思路"></a> 解决思路</h3><p>其实这题说这么多，意思就是，我给你一颗二叉树，你帮我把它变成字符串，然后再通过字符串，把二叉树还原。至于字符串长什么样，你随意。只要你能还原。于是乎，就是如何保持节点和还原节点的问题。感觉还是先序遍历，比较简单。其次BFS按层扫描，保持节点也是容易想到的，前者是使用递归后者是使用while循环。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><ul><li>DFS深度优先遍历(先序遍历的实现)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serialize = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">perOrder</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">      str += <span class="string">&quot;null,&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      str += <span class="string">`<span class="subst">$&#123;root.val&#125;</span>,`</span></span><br><span class="line">      perOrder(root.left)</span><br><span class="line">      perOrder(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">  &#125;</span><br><span class="line">  perOrder(root)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decodes your encoded data to tree.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">data</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deserialize = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dataArr = data.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">  dataArr.pop()</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">build</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[<span class="number">0</span>] == <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">      arr.shift()</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> treeNode = <span class="keyword">new</span> TreeNode(arr[<span class="number">0</span>])</span><br><span class="line">    arr.shift()</span><br><span class="line">    treeNode.left = build(arr)</span><br><span class="line">    treeNode.right = build(arr)</span><br><span class="line">    <span class="keyword">return</span> treeNode    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> build(dataArr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BFS(按层扫描的代码实现)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serialize = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> queue = [root]</span><br><span class="line">  <span class="keyword">while</span> (queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> rootNode = queue.shift()</span><br><span class="line">    <span class="keyword">if</span> (rootNode == <span class="literal">null</span>) &#123;</span><br><span class="line">      str += <span class="string">&#x27;null,&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      str += <span class="string">`<span class="subst">$&#123;rootNode.val&#125;</span>,`</span></span><br><span class="line">      queue.push(rootNode.left)</span><br><span class="line">      queue.push(rootNode.right)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decodes your encoded data to tree.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">data</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deserialize = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nodes = data.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">  nodes.pop()</span><br><span class="line">  <span class="keyword">if</span> (nodes.length == <span class="number">0</span> || nodes[<span class="number">0</span>] == <span class="string">&#x27;null&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(<span class="built_in">parseInt</span>(nodes.shift()))</span><br><span class="line">  <span class="keyword">let</span> queue = [root]</span><br><span class="line">  <span class="keyword">while</span> (nodes.length !== <span class="number">0</span> &amp;&amp; queue.length !==<span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = queue.shift()</span><br><span class="line">    <span class="keyword">let</span> treeNode = nodes.shift()</span><br><span class="line">    <span class="keyword">if</span> (treeNode !== <span class="string">&#x27;null&#x27;</span>) &#123;</span><br><span class="line">      node.left = <span class="keyword">new</span> TreeNode(<span class="built_in">parseInt</span>(treeNode))</span><br><span class="line">      queue.push(node.left)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      node.left = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    treeNode = nodes.shift()</span><br><span class="line">    <span class="keyword">if</span> (treeNode !== <span class="string">&#x27;null&#x27;</span>) &#123;</span><br><span class="line">      node.right = <span class="keyword">new</span> TreeNode(<span class="built_in">parseInt</span>(treeNode))</span><br><span class="line">      queue.push(node.right)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.right = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(一)</title>
      <link href="2020/02/26/typescript/"/>
      <url>2020/02/26/typescript/</url>
      
        <content type="html"><![CDATA[<p>因为设计模式部分代码，可能需要用到接口等特性，因此需要使用TS,下面介绍一点TS基础的使用方法，对于可以用ES6实现的方式，我尽量采用ES6实现。23种设计模式,这一篇肯定写不完，前面都是基础准备，想节约时间的，可直接跳到<strong>开始设计模式那块</strong>,本篇只介绍了，单例模式和工厂模式</p><h2 id="typescript简单介绍"><a class="markdownIt-Anchor" href="#typescript简单介绍"></a> TypeScript简单介绍</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装或者更新ts</span></span><br><span class="line">npm install -g typescript</span><br><span class="line"><span class="comment"># 检测是否安装成功</span></span><br><span class="line">tsc -version</span><br><span class="line"><span class="comment"># 编写.ts文件， 运行以下命令将ts文件转换成js</span></span><br><span class="line"><span class="comment"># 运行对应js文件即可</span></span><br><span class="line">tsc [fileName].ts</span><br></pre></td></tr></table></figure><h3 id="采用webpack的方式"><a class="markdownIt-Anchor" href="#采用webpack的方式"></a> 采用webpack的方式</h3><blockquote><p>因为不想频繁的执行tsc命令自己搭建了，webpack的环境。<a href="https://github.com/wmwgithub/typescript-design-mode/blob/master/webpack.config.js">配置链接</a>,clone下来项目后,在项目<code>src</code> 目录下编写对应ts代码即可,webpack会自动编译ts代码,<code>app.ts</code>是程序主入口。因此函数调用要在<code>app.ts</code>中运行。</p></blockquote><h3 id="typescript-数据类型"><a class="markdownIt-Anchor" href="#typescript-数据类型"></a> TypeScript 数据类型</h3><p>定义ts变量需要指定类型。或者会根据第一个赋值变量分配默认类型。未赋值变量默认类型为<code>any</code></p><h4 id="布尔类型boolean"><a class="markdownIt-Anchor" href="#布尔类型boolean"></a> 布尔类型(boolean)</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag:<span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// error code 不同类型不能赋值</span></span><br><span class="line">flag = <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="数值类型number"><a class="markdownIt-Anchor" href="#数值类型number"></a> 数值类型(number)</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num:<span class="built_in">number</span> = <span class="number">123</span></span><br></pre></td></tr></table></figure><h4 id="字符串类型string"><a class="markdownIt-Anchor" href="#字符串类型string"></a> 字符串类型(string)</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str:<span class="built_in">string</span> = <span class="string">&quot;string&quot;</span></span><br></pre></td></tr></table></figure><h4 id="数组类型array"><a class="markdownIt-Anchor" href="#数组类型array"></a> 数组类型(array)</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr:<span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><h4 id="元组类型tuple"><a class="markdownIt-Anchor" href="#元组类型tuple"></a> 元组类型(tuple)</h4><p>元组类型是数组类型的子集,元组不允许越界，每一个元祖类型都指定了一个数据类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr:[<span class="built_in">number</span>,<span class="built_in">string</span>] = [<span class="number">1</span>,<span class="string">&#x27;str&#x27;</span>]</span><br><span class="line"><span class="comment">// error code 越界 左边类型长度为2 右边赋值长度为3</span></span><br><span class="line"><span class="keyword">let</span> arr:[<span class="built_in">number</span>,<span class="built_in">string</span>] = [<span class="number">1</span>,<span class="string">&#x27;str&#x27;</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h4 id="枚举类型enum"><a class="markdownIt-Anchor" href="#枚举类型enum"></a> 枚举类型(enum)</h4><p>枚举中变量默认值是 按顺序赋值0,1,2 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span>,也可以给枚举中变量直接赋值,覆盖掉默认值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Flag&#123;</span><br><span class="line">  success,</span><br><span class="line">  fail,</span><br><span class="line">  unknow = <span class="string">&#x27;unknow&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> success:Flag = Flag.success </span><br><span class="line"><span class="built_in">console</span>.log(success) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(Flag.fail) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(Flag.unknow) <span class="comment">// unknow</span></span><br></pre></td></tr></table></figure><h4 id="never类型"><a class="markdownIt-Anchor" href="#never类型"></a> never类型</h4><p>null和undefined,是never 类型的子集。还有一种是不会出现的类型,例如没有返回值的函数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num:<span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(num)  <span class="comment">// null</span></span><br><span class="line"><span class="keyword">let</span> unde:<span class="literal">undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(unde) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="函数的重载"><a class="markdownIt-Anchor" href="#函数的重载"></a> 函数的重载</h3><p>相同的函数名称，接收不同的参数，最后一个函数必须要给出函数的实现。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userInfo</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userInfo</span>(<span class="params">age: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userInfo</span>(<span class="params">info: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> info === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`my name is <span class="subst">$&#123;info&#125;</span>`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`my age is <span class="subst">$&#123;info&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(userInfo(<span class="string">&#x27;wmw&#x27;</span>))  <span class="comment">// my name is wmw</span></span><br><span class="line"><span class="built_in">console</span>.log(userInfo(<span class="number">18</span>)) <span class="comment">//  my age is 18</span></span><br></pre></td></tr></table></figure><h3 id="类的写法"><a class="markdownIt-Anchor" href="#类的写法"></a> 类的写法</h3><p>TS中类的写法大体上和ES6差不多,TS可以对类中变量，方法，指定私有还是公有的属性,在构造器中定义初始的变量时，要在构造器前声明一下变量,如果是继承类只需要声明自身独有的属性即可,继承自父类的属性可不必声明,下面对比一下两者的写法。</p><ul><li>ES6的写法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.x = x</span><br><span class="line"><span class="built_in">this</span>.y = y</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> point = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">x, y, color</span>)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(x, y)</span><br><span class="line"><span class="built_in">this</span>.color = color</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> world = <span class="string">&#x27;world&#x27;</span></span><br><span class="line">hello = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.hello)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">time</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.world)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Date</span>.now()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TS的写法</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在构造器前声明了x,y</span></span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.x = x</span><br><span class="line"><span class="built_in">this</span>.y = y</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> point = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 只需声明color,继承来的x,y不必声明</span></span><br><span class="line">  color: <span class="built_in">string</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span>, color:<span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(x, y)</span><br><span class="line"><span class="built_in">this</span>.color = color</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 可以指定变量为私有属性，(只是在写代码层面上报错)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> world = <span class="string">&#x27;world&#x27;</span></span><br><span class="line">  <span class="keyword">private</span> hello = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">this</span>.hello)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="title">time</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">this</span>.world)</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">Date</span>.now()</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3><p>TS比ES6多提供了接口的功能,一个类要实现接口,必须要实现接口指定的属性和方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义人的接口，指定了名字，年龄，和爱好</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name:<span class="built_in">string</span>,</span><br><span class="line">  age:<span class="built_in">number</span>,</span><br><span class="line">  hobby:<span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;,</span><br><span class="line">  sayHobby():<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据这个接口 定义一个类小明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> <span class="title">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  name: <span class="built_in">string</span>  </span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  hobby: <span class="built_in">string</span>[]</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>,age: <span class="built_in">number</span>,hobby: <span class="built_in">string</span>[]</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name</span><br><span class="line">      <span class="built_in">this</span>.age = age</span><br><span class="line">      <span class="built_in">this</span>.hobby = hobby</span><br><span class="line">  &#125;</span><br><span class="line">  sayHobby(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`我喜欢,<span class="subst">$&#123;<span class="built_in">this</span>.hobby.join(<span class="string">&#x27;,&#x27;</span>)&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> xiaoMing = <span class="keyword">new</span> XiaoMing(<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">18</span>,[<span class="string">&#x27;唱&#x27;</span>,<span class="string">&#x27;跳&#x27;</span>,<span class="string">&#x27;rap&#x27;</span>,<span class="string">&#x27;*球&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="设计模式的基本原则"><a class="markdownIt-Anchor" href="#设计模式的基本原则"></a> 设计模式的基本原则</h2><p>之所以会有设计模式，很大程度上是为了代码的整洁性，重用性，可靠性，可扩展性，等等，总之你写的代码不仅仅是代码，更应该是一个工程，为了这个工程的未来，每个人都应该努力提高自己的代码质量。很多时候是和他人一起合作的工程。设计模式需要遵守的七大原则</p><ul><li>单一责任原则</li><li>接口隔离原则</li><li>依赖倒转(倒置)原则</li><li>里氏替换原则</li><li>开闭原则</li><li>迪米特法则</li><li>合成复用原则</li></ul><h3 id="单一责任原则"><a class="markdownIt-Anchor" href="#单一责任原则"></a> 单一责任原则</h3><blockquote><p>字面意思，一个类只负责一件事，尽量降低类的复杂度，更不可以把丝毫不相关的代码放在一个类中。</p></blockquote><ul><li>降低类或者方法的复杂度，</li><li>提代码可读性可维护性。</li><li>降低变更代码引起的风险。</li></ul><p>案例:指定一个交通工具类，类中，指定每种交通工具的运行途径，比如汽车陆地上，飞机空中等</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一的 run方法 很明显 ，把 飞机汽车的运行方式，放一起</span></span><br><span class="line"><span class="comment">// 不利于代码以后扩展</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params">vehicle,<span class="keyword">type</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vehicle === <span class="string">&#x27;car&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;car在陆地上运行&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(vehicle === <span class="string">&#x27;aircraft&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;aircraft在空中运行&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法一 把各个功能不同的交通工具拆成不同类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params">vehicle</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vehicle + <span class="string">&#x27;在陆地上运行&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params">vehicle</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vehicle + <span class="string">&#x27;在空中运行&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解决方法2 在方法层面上实现 单一原则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params">vehicle</span>)</span>&#123;</span><br><span class="line">    retun vehicle + <span class="string">&quot;在陆地上运行&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">runAir</span>(<span class="params">vehicle</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vehicle + <span class="string">&quot;在空中运行&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口隔离原则"><a class="markdownIt-Anchor" href="#接口隔离原则"></a> 接口隔离原则</h3><blockquote><p>一个类 实现接口时，应该基于接口的最小接口，如果接口中含有大量他不需要的方法，应该拆分接口</p></blockquote><ul><li>减少不必要的代码。</li><li>代码逻辑关系更清晰,程序稳定性更好</li></ul><p>设计一个情形，B,D类 都实现了接口1,A,C通过接口依赖于B,D。但是A只需要接口中<code>operation1</code>,<code>operation2</code> 但是 C需要<code>operation1</code>,<code>operation2</code> 。 因此,如果只定义一个接口1，B,D中 都有不必要的代码。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Interface1 &#123;</span><br><span class="line">  operation1(): <span class="built_in">void</span>;</span><br><span class="line">  operation2(): <span class="built_in">void</span>;</span><br><span class="line">  operation3(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">implements</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> operation1(): <span class="built_in">void</span> &#123;</span><br><span class="line">    log(<span class="string">&#x27;B实现了接口1&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> operation2(): <span class="built_in">void</span> &#123;</span><br><span class="line">    log(<span class="string">&#x27;B实现了接口2&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不必要的代码</span></span><br><span class="line">  <span class="keyword">public</span> operation3(): <span class="built_in">void</span> &#123;</span><br><span class="line">    log(<span class="string">&#x27;B实现了接口3&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="title">implements</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 不必要的代码</span></span><br><span class="line">  <span class="keyword">public</span> operation1(): <span class="built_in">void</span> &#123;</span><br><span class="line">    log(<span class="string">&#x27;D实现了接口1&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> operation2(): <span class="built_in">void</span> &#123;</span><br><span class="line">    log(<span class="string">&#x27;D实现了接口2&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> operation3(): <span class="built_in">void</span> &#123;</span><br><span class="line">    log(<span class="string">&#x27;D实现了接口3&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> depend1(i: Interface1): <span class="built_in">void</span> &#123;</span><br><span class="line">    i.operation1()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> depend2(i: Interface1): <span class="built_in">void</span> &#123;</span><br><span class="line">    i.operation2()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> depend2(i: Interface1): <span class="built_in">void</span> &#123;</span><br><span class="line">    i.operation2()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> depend3(i: Interface1): <span class="built_in">void</span> &#123;</span><br><span class="line">    i.operation3()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Segregation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> main(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">new</span> A()</span><br><span class="line">    a.depend1(<span class="keyword">new</span> B()) <span class="comment">//B实现了接口1</span></span><br><span class="line">    a.depend2(<span class="keyword">new</span> B()) <span class="comment">// B实现了接口2</span></span><br><span class="line">    <span class="keyword">let</span> c = <span class="keyword">new</span> C()</span><br><span class="line">    c.depend2(<span class="keyword">new</span> D()) <span class="comment">// D实现了接口2</span></span><br><span class="line">    c.depend3(<span class="keyword">new</span> D()) <span class="comment">// D实现了接口3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改进之后</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Interface1 &#123;</span><br><span class="line">  operation1(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Interface2 &#123;</span><br><span class="line">  operation2(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Interface3 &#123;</span><br><span class="line">  operation3(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">implements</span> <span class="title">Interface1</span>, <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> operation1(): <span class="built_in">void</span> &#123;</span><br><span class="line">    log(<span class="string">&#x27;B实现了接口1&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> operation2(): <span class="built_in">void</span> &#123;</span><br><span class="line">    log(<span class="string">&#x27;B实现了接口2&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="title">implements</span> <span class="title">Interface2</span>, <span class="title">Interface3</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> operation2(): <span class="built_in">void</span> &#123;</span><br><span class="line">    log(<span class="string">&#x27;D实现了接口2&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> operation3(): <span class="built_in">void</span> &#123;</span><br><span class="line">    log(<span class="string">&#x27;D实现了接口3&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> depend1(i: Interface1): <span class="built_in">void</span> &#123;</span><br><span class="line">    i.operation1()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> depend2(i: Interface2): <span class="built_in">void</span> &#123;</span><br><span class="line">    i.operation2()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> depend2(i: Interface2): <span class="built_in">void</span> &#123;</span><br><span class="line">    i.operation2()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> depend3(i: Interface3): <span class="built_in">void</span> &#123;</span><br><span class="line">    i.operation3()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Segregation2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> main(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">new</span> A()</span><br><span class="line">    a.depend1(<span class="keyword">new</span> B()) <span class="comment">//B实现了接口1</span></span><br><span class="line">    a.depend2(<span class="keyword">new</span> B()) <span class="comment">// B实现了接口2</span></span><br><span class="line">    <span class="keyword">let</span> c = <span class="keyword">new</span> C()</span><br><span class="line">    c.depend2(<span class="keyword">new</span> D()) <span class="comment">// D实现了接口2</span></span><br><span class="line">    c.depend3(<span class="keyword">new</span> D()) <span class="comment">// D实现了接口3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计接口的时候注意接口隔离，不要把，不同功能的接口放一起，以免实现代码的时候出现不必要的实现类代码。B,D实现类的代码,比之前减少了不必要的代码。</p><h3 id="依赖倒转倒置原则"><a class="markdownIt-Anchor" href="#依赖倒转倒置原则"></a> 依赖倒转(倒置)原则</h3><blockquote><p>高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节，细节应该依赖抽象。依赖倒转原则中心思想是面向接口编程。遵循里氏替换原则</p></blockquote><p>我们模拟一个人接收邮件，和接收消息的场景</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 完成Persion 接收消息的功能</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> receive(email: Email): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(email.getInfo())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> getInfo(): <span class="built_in">string</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;电子邮件信息 Hello World&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DependecyInVersion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> main(): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">      person.receive(<span class="keyword">new</span> Email())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面的案例实现思路,简单,比较容易想到,但是如果我们还需要接收微信,QQ,短的消息显得不好扩展</p><p>根据依赖倒转原则,我们应该引入一个IReceiver接口,表示接收者,这样Person类<br />与接口IReceiver发生依赖,只要接口不变,Person无需改变,因为WeXin QQ等新都属接收业务范围,他们各自实现IReceiver接口就行。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DependecyInVersion2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> main(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">    person.receive(<span class="keyword">new</span> Email())</span><br><span class="line">    person.receive(<span class="keyword">new</span> QQ())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接收接口</span></span><br><span class="line"><span class="keyword">interface</span> IReceiver &#123;</span><br><span class="line">  getInfo(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义Email消息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="title">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> getInfo(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;接收到 Email消息&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义QQ消息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QQ</span> <span class="title">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> getInfo(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;接收到 QQ消息&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成Persion 接收消息的功能,</span></span><br><span class="line"><span class="comment">// 无论上层增加接收什么类型的消息,Persion类无需改变</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 基于接口传递依赖关系</span></span><br><span class="line">  <span class="keyword">public</span> receive(receiver: IReceiver): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(receiver.getInfo())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖关系的传递方式这不是设计模式原则"><a class="markdownIt-Anchor" href="#依赖关系的传递方式这不是设计模式原则"></a> 依赖关系的传递方式(这不是设计模式原则)</h3><p>为了实现接口分离，我们常常使用如下方式传递接口依赖关系。</p><ul><li>接口传递 (上面的案例就是基于接口传递依赖关系)</li><li>构造方法传递</li><li>setter方法传递</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义两个接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Message &#123;</span><br><span class="line">  info(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IReceiver &#123;</span><br><span class="line">  getInfo(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>方式2 通过构造方法传递</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMessage</span> <span class="title">implements</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> receiver!: IReceiver</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">receiver: IReceiver</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 基于构造方法 传递 </span></span><br><span class="line">    <span class="built_in">this</span>.receiver = receiver</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">info</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.receiver.getInfo()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> <span class="title">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">  getInfo(): <span class="built_in">void</span> &#123;</span><br><span class="line">    log(<span class="string">&quot;我接收到消息啦~~&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DependecyInVersion3</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> receiver = <span class="keyword">new</span> Receiver()</span><br><span class="line">    <span class="keyword">let</span> myMessage = <span class="keyword">new</span> MyMessage(receiver)</span><br><span class="line">    myMessage.info()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方式3 通过setter方法</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMessage</span> <span class="title">implements</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> receiver!: IReceiver; <span class="comment">// TS要求添加 赋值断言</span></span><br><span class="line">  <span class="keyword">public</span> setReceive(rec: IReceiver): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.receiver = rec</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">info</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.receiver.getInfo()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> <span class="title">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">  getInfo(): <span class="built_in">void</span> &#123;</span><br><span class="line">    log(<span class="string">&quot;我接收到消息啦~~&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DependecyInVersion3</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> myMessage = <span class="keyword">new</span> MyMessage()</span><br><span class="line">    myMessage.setReceive(<span class="keyword">new</span> Receiver())</span><br><span class="line">    myMessage.info()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="里氏替换原则"><a class="markdownIt-Anchor" href="#里氏替换原则"></a> 里氏替换原则</h3><p>使用继承的时候，应尽量遵循里氏替换原则,在<strong>子类中尽量不要重写父类方法</strong>。里氏替换原则告诉我们，继承实际上让两个类耦合度增强了，在适当情况下，可以通过，<strong>聚合，组合依赖来解决问题</strong>。抱歉这个暂时没有找到很好的例子。</p><h3 id="开闭原则"><a class="markdownIt-Anchor" href="#开闭原则"></a> 开闭原则</h3><blockquote><p>一个软件的类，模块和函数应该对扩展开发，对修改关闭。当软件需要变化时，尽量通过扩展软件实体行为来实现变化。而不是通过修改已有代码。</p></blockquote><p>我的定义一个画图的案例,在一个绘图的类中定义，绘制不同样子图形的情形，其实这边这个案例和第一种，单一责任原则有点类似了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; log &#125; <span class="keyword">from</span> <span class="string">&#x27;util&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">OCP</span> </span>&#123;</span><br><span class="line"><span class="comment">// (使用方)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> main(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> graphiEditor = <span class="keyword">new</span> GraphiEditor()</span><br><span class="line">    graphiEditor.drawShape(<span class="keyword">new</span> Rectangle())</span><br><span class="line">    graphiEditor.drawShape(<span class="keyword">new</span> Circle())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供方</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphiEditor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> drawShape(s: Shape): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.mType == <span class="number">1</span>) &#123;</span><br><span class="line">      log(<span class="string">&#x27;绘制矩形&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.mType == <span class="number">2</span>) &#123;</span><br><span class="line">      log(<span class="string">&#x27;绘制圆形&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提供方</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> mType: <span class="built_in">number</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">mType: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mType = mType</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方</span></span><br><span class="line"><span class="comment">// 画矩形的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">1</span>) <span class="comment">// mType = 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方</span></span><br><span class="line"><span class="comment">// 画圆形的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">2</span>) <span class="comment">// mType = 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码如果想要新增画三角形的类,发现扩展改变比较大,提供方，使用方代码都需要改变。现在经过如下修改，去掉if,else的判断，根据开闭原则，把具体的实现，放到使用方每个子类中自己实现，这样，想新增三角形的时候。只要使用方自己实现了三角形。不需要动提供方的代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; log &#125; <span class="keyword">from</span> <span class="string">&#x27;util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">OCP2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> main(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> graphiEditor = <span class="keyword">new</span> GraphiEditor()</span><br><span class="line">    graphiEditor.drawShape(<span class="keyword">new</span> Rectangle())</span><br><span class="line">    graphiEditor.drawShape(<span class="keyword">new</span> Circle())</span><br><span class="line">    graphiEditor.drawShape(<span class="keyword">new</span> Triangle())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供 方</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphiEditor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> drawShape(s: Shape): <span class="built_in">void</span> &#123;</span><br><span class="line">    s.draw()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供方</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> draw(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> draw(): <span class="built_in">void</span> &#123;</span><br><span class="line">    log(<span class="string">&#x27;绘制矩形&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> draw(): <span class="built_in">void</span> &#123;</span><br><span class="line">    log(<span class="string">&#x27;绘制圆形&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现在扩展三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> draw(): <span class="built_in">void</span> &#123;</span><br><span class="line">    log(<span class="string">&#x27;绘制三角形&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迪米特法则"><a class="markdownIt-Anchor" href="#迪米特法则"></a> 迪米特法则</h3><blockquote><p>高内聚，低耦合,尽量少对外暴露信息，一个类对自己依赖的类知道越少越好。类与类关系越密切，耦合度越大。越不利于代码更改。</p></blockquote><p>现在我们实现一个二叉搜索树并且二叉搜索树，提供了插入节点功能，和返回中序遍历（左节点-&gt;根节点-&gt;右节点）结果的功能</p><ul><li>不符合迪米特法则的实现</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">  val: <span class="built_in">number</span>;</span><br><span class="line">  left: <span class="literal">null</span> | TreeNode;</span><br><span class="line">  right: <span class="literal">null</span> | TreeNode;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">val:<span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = val</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义 二叉 搜索树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTree</span></span>&#123;</span><br><span class="line"> tree: <span class="literal">null</span> | TreeNode;</span><br><span class="line"> <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.tree = <span class="literal">null</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 定义插入方法</span></span><br><span class="line"> <span class="function"><span class="title">insert</span>(<span class="params">node:TreeNode</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">this</span>.tree === <span class="literal">null</span>)&#123;</span><br><span class="line">     <span class="built_in">this</span>.tree = node</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> root = <span class="built_in">this</span>.tree</span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(node.val&gt;root.val)&#123;</span><br><span class="line">           <span class="keyword">if</span>(root.right === <span class="literal">null</span>)&#123;</span><br><span class="line">             root.right = node</span><br><span class="line">             <span class="keyword">break</span></span><br><span class="line">           &#125;</span><br><span class="line">           root = root.right</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">           <span class="keyword">if</span>(root.left === <span class="literal">null</span>)&#123;</span><br><span class="line">             root.left = node</span><br><span class="line">             <span class="keyword">break</span></span><br><span class="line">           &#125;</span><br><span class="line">           root = root.left</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.tree</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="title">inOrder</span>(<span class="params">tree:TreeNode|<span class="literal">null</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res:<span class="built_in">number</span>[] = []</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">order</span>(<span class="params">tree:TreeNode|<span class="literal">null</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree === <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> res     </span><br><span class="line">    &#125;</span><br><span class="line">    order(tree.left)</span><br><span class="line">    res.push(tree.val)</span><br><span class="line">    order(tree.right)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">   &#125;</span><br><span class="line">   order(tree)</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现一个二叉搜索树的功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demeter</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> bsTree = <span class="keyword">new</span> BSTree()</span><br><span class="line">      bsTree.insert(<span class="keyword">new</span> TreeNode(<span class="number">8</span>))</span><br><span class="line">      bsTree.insert(<span class="keyword">new</span> TreeNode(<span class="number">7</span>))</span><br><span class="line">      bsTree.insert(<span class="keyword">new</span> TreeNode(<span class="number">11</span>))</span><br><span class="line">      bsTree.insert(<span class="keyword">new</span> TreeNode(<span class="number">9</span>))</span><br><span class="line">      bsTree.insert(<span class="keyword">new</span> TreeNode(<span class="number">3</span>))</span><br><span class="line">      bsTree.insert(<span class="keyword">new</span> TreeNode(<span class="number">2</span>))</span><br><span class="line">      <span class="comment">// 放入的顺序[8,7,11,9,3,2]</span></span><br><span class="line">      <span class="keyword">let</span> res = bsTree.inOrder(bsTree.tree)</span><br><span class="line">      <span class="built_in">console</span>.log(res) <span class="comment">// [2, 3, 7, 8, 9, 11]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码可以看出，用户在使用二叉搜索树的时候,insert方法暴露给用户的信息太多了。具体的插入流程其实不需要让用户实现。用户提供数据就行了。还有中序遍历的时候，其实没必要接收用户的参数(当然这个错是我故意这么写的，想个案例不容易啊/(ㄒoㄒ)/~~)</p><ul><li>修改之后</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">  val: <span class="built_in">number</span>;</span><br><span class="line">  left: <span class="literal">null</span> | TreeNode;</span><br><span class="line">  right: <span class="literal">null</span> | TreeNode;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">val:<span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = val</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义 二叉搜索树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTree</span></span>&#123;</span><br><span class="line"> tree: <span class="literal">null</span> | TreeNode;</span><br><span class="line"> <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.tree = <span class="literal">null</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 改成接收 不定参数</span></span><br><span class="line"> <span class="comment">// 去掉返回值，让用户 只能有 new BSTree().tree 一种方式 获取的根节点</span></span><br><span class="line"> insert(...args:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;):<span class="built_in">void</span>&#123;</span><br><span class="line">   <span class="keyword">let</span> handleInsert = <span class="function">(<span class="params">node:TreeNode</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.tree === <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="built_in">this</span>.tree = node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> root = <span class="built_in">this</span>.tree</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(node.val&gt;root.val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.right === <span class="literal">null</span>)&#123;</span><br><span class="line">              root.right = node</span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            root = root.right</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">if</span>(root.left === <span class="literal">null</span>)&#123;</span><br><span class="line">              root.left = node</span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">          root = root.left</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  args.forEach(<span class="function"><span class="params">element</span> =&gt;</span>handleInsert(<span class="keyword">new</span> TreeNode(element)));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 不需要接收参数</span></span><br><span class="line"> inOrder():<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> res:<span class="built_in">number</span>[] = []</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">order</span>(<span class="params">tree:TreeNode|<span class="literal">null</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree === <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> res     </span><br><span class="line">    &#125;</span><br><span class="line">    order(tree.left)</span><br><span class="line">    res.push(tree.val)</span><br><span class="line">    order(tree.right)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 改成 this.tree 直接引用内部的</span></span><br><span class="line">   order(<span class="built_in">this</span>.tree)</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现一个二叉搜索树的功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemeterImprove</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> bsTree = <span class="keyword">new</span> BSTree()</span><br><span class="line">      <span class="comment">// 插入元素 8 7 11 9 3 2</span></span><br><span class="line">      bsTree.insert(<span class="number">8</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">      <span class="keyword">let</span> res = bsTree.inOrder()</span><br><span class="line">      mlog.log(res) <span class="comment">// [2, 3, 7, 8, 9, 11]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="开始设计模式"><a class="markdownIt-Anchor" href="#开始设计模式"></a> 开始设计模式</h2><p>对于设计模式，大家公认有23种基本的设计模式，由于学的比较慢,这边目前只介绍单利模式和工厂模式,剩下的设计模式会慢慢的在后面的文章中，用TS实现。</p><h3 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h3><p>就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例， 并且该类只提供一个取得其对象实例的方法(静态方法)。</p><p>就是假如我们在一个系统中，需要频繁的使用某个对象，这时候如果反复的通过new，去实例化这个对象来使用，会造成不必要的内存损失。因此我们应该在对象内部提供静态属性等于实例化的这个类, 然后去通过类的静态属性获取实例化的类。案例如下</p><p>现在假如 我们有一个Person类，要多处调用Person中的 <code>sayHello</code> 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World JavaScript&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Person() === <span class="keyword">new</span> Person()) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>通过上述console.log中的比较结果知道，假如我们需要使用多次，那么每次都要占用一个新内存。通过改变代码如下,可见我们通过类本身的静态属性访问该类不要每次都实例化这个类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> person = <span class="keyword">new</span> Person()</span><br><span class="line">  <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World JavaScript&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// es6目前没有私有属性可不提供，get方法</span></span><br><span class="line">  <span class="comment">// 在这里写了一个是模仿java，</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getPerson</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.person</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.getPerson() === Person.getPerson()) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 或者直接一点</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.person === Person.person) <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>上面这种单例模式，属性java中的饿汉式，还有懒汉式，静态内部类实现，利用枚举实现等。主要是因为java的类装载机制。和线程安全问题，js暂时不用考虑这些问题 O(∩_∩)O哈哈~。</p><h3 id="工厂模式"><a class="markdownIt-Anchor" href="#工厂模式"></a> 工厂模式</h3><p>工厂模式很多情形其实是为了解决，设计违反了前面提到的 <strong>开闭原则的情景</strong> 。这种类型的设计模式属于<strong>创建型模式</strong>，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p><strong>优点：</strong> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p><p><strong>缺点：</strong> 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</p><p>从如下代码中优缺点显而易见，调用的时候很方便，去工厂取东西，不用关系工厂后面是怎么实现的。但是每次修改，工厂和工厂后面的实现都要改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单工厂模式</span></span><br><span class="line">interface Shape&#123;</span><br><span class="line">  <span class="comment">// 定义一个表示形状的接口，里面有画的方法</span></span><br><span class="line">  draw()</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="title">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">draw</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我画了一个矩形&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Squre</span> <span class="title">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">draw</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我画了一个正方形&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="title">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">draw</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我画了一个圆形&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">getShape</span>(<span class="params">shapeType</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(shapeType === <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shapeType === <span class="string">&quot;CIRCLE&quot;</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Circle()</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shapeType === <span class="string">&quot;RECTANGLE&quot;</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Rectangle()</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shapeType === <span class="string">&quot;SQUARE&quot;</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Squre()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用层</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> shapeFactory = <span class="keyword">new</span> ShapeFactory()</span><br><span class="line">  <span class="keyword">let</span> circle = shapeFactory.getShape(<span class="string">&quot;CIRCLE&quot;</span>)</span><br><span class="line">  circle.draw() <span class="comment">// 我画了一个圆形</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同样本篇是我看资料之后总结的。部分文字来源于网络</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack教程~基础篇</title>
      <link href="2020/02/23/webpack/"/>
      <url>2020/02/23/webpack/</url>
      
        <content type="html"><![CDATA[<h3 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念"></a> 基础概念</h3><p><a href="https://webpack.docschina.org/guides/installation/">官网安装方式</a></p><p>通过官网的指引安装好webpack,在项目根目录添加 <code>webpack.config.js</code> 的文件.<br /><code>webpack.config.js</code> 遵循的是 <code>commonJS</code> 规范,依次文件采用 <code>module.exports=&#123;[key]:[value]&#125;</code> 的方式,来暴露具体的配置。</p><p>一个基本的webpack配置如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;[xxx].js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;xxxx.js&#x27;</span>,</span><br><span class="line">    path: resolve(__dirname, <span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;[key]:[value]&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> PluginsName()</span><br><span class="line">  ],</span><br><span class="line">  mode: <span class="string">&#x27;production | development&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://webpack.docschina.org/concepts/">官网基础概念</a></p><h4 id="entry"><a class="markdownIt-Anchor" href="#entry"></a> Entry</h4><p>指定webpack,打包的起始文件，根据此文件分析构建依赖关系图。</p><p>入口文件，可配置一个，也可以 <code>&#123;[key]:[value]&#125;</code> 的形式配置多个</p><h4 id="output"><a class="markdownIt-Anchor" href="#output"></a> Output</h4><p>指示webpack打包后的资源，输出到哪里去，以及如何命名。</p><p>output的值是一个对象，指定了输出文件名，和文件路径，输出文件建议使用 path模块中的resolve即 <code>resolve(__dirname,xxx)</code></p><p>在webpack中输出的文件名，如果你不想指定，可以取使用<code>[hash].扩展名</code>的形式，webpack在输出的时候，会自动指定hash值。</p><h4 id="loader"><a class="markdownIt-Anchor" href="#loader"></a> Loader</h4><p>Webpack去处理那些非<code>Javascript</code>文件。(webpack本身只处理js和json数据)</p><p>对应webpack的字段是 <code>module</code>,里面指定了webpack各种的loader配置。形如</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;[key]:[value]&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>rules中的每一个对象，对应着一个处理某个文件的模块，为了处理某种文件，我们需要配置，匹配这个文件的正则表达式,形如 <code>test:/具体正则表达式/</code> ，和通过 <code>use:[loader-name]</code> 的形式指定 多个loader,如：处理css 文件，我们需要 <code>style-loader</code> 和 <code>css-loader</code> 。甚至有时候use数组里面，不只是 各个loader的名称，可能还需要修改一些loader的配置，就会采取对象的形式指定loader，如给css添加兼容性处理的情景</p><p>同一文件各种loader的处理顺序是自下而上的,css文件配置如下,文件会先经过 <code>css-loader</code> 处理,再经过<code>style-loader</code>处理。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.css$/,</span><br><span class="line">      use: [</span><br><span class="line">        &#x27;style-loader&#x27;,</span><br><span class="line">        &#x27;css-loader&#x27;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>上面引入的两种loader都是直接通过loader名称的形式引入的，按照对象的方式引入postcss-loader，对css做兼容性处理。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.css$/,</span><br><span class="line">  use: [</span><br><span class="line">    &#x27;style-loader&#x27;</span><br><span class="line">    &#x27;css-loader&#x27;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: &#x27;postcss-loader&#x27;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        ident: &#x27;postcss&#x27;,</span><br><span class="line">        plugins: () =&gt; &#123;</span><br><span class="line">          require(&#x27;postcss-preset-env&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>当然最后要注意的是，这些loader都不是webpack，内置的，而是需要 通过npm 安装。具体的插件安装可看官网。建议大家和webpack有关的都安装在  <code>devDependencies</code> 下 。</p><h4 id="plugins"><a class="markdownIt-Anchor" href="#plugins"></a> Plugins</h4><p>各种功能强大的工具，包括打包优化和压缩，甚至可以重新定义环境中的变量。插件相比于Loader可以做很多比Loader功能更强大的事。</p><p>插件和loader相同的是都需要先npm安装，不同的是，loader不需要引入，但是要在use里面写一些配置。而插件则是通过，先require 引入某个插件，然后再在plugins,实例化引入的插件对象即可。如果需要修改插件的默认配置，在实例化的时候，以对象的形式传入即可。</p><p>html 模板插件使用如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;......&#x27;</span>,</span><br><span class="line">  output:<span class="string">&#x27;......&#x27;</span>,</span><br><span class="line">  <span class="built_in">module</span>:<span class="string">&#x27;......&#x27;</span>,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 实例化require引入的插件 html-webpack-plugin</span></span><br><span class="line">    <span class="comment">//指定传入的HTML模板是src目录下的index.html文件</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: <span class="string">&#x27;.....&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mode"><a class="markdownIt-Anchor" href="#mode"></a> Mode</h4><p>模式分为 <code>development</code>开发环境，<code>production</code> 生产环境。<br />这大概是webpack最简洁的配置了，在<code>production</code> 模式下，会自动开启压缩js代码和 <code>tree shaking</code> 。</p><p>在未来的 webpack5中,只有在 <code>webpack.config.js</code> 文件中指定一个mode,就可以使用，上面的 <code>entry,output</code> 等配置,都变成了默认配置。</p><h3 id="webpack打包过程"><a class="markdownIt-Anchor" href="#webpack打包过程"></a> webpack打包过程</h3><ol><li>指定入口文件 entry</li><li>webpack会根据入口文件里面所有的依赖,形成依赖树，然后会根据依赖树中把所以需要的依赖引入，形成代码块(chunk),然后再根据不同的资源对应的loader,对代码块进行处理输出为 <code>bundles</code>.</li></ol><h3 id="处理css-less"><a class="markdownIt-Anchor" href="#处理css-less"></a> 处理css、less</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install style-loader css-loader  -D</span><br></pre></td></tr></table></figure><p>其中 css-loader 是为了把 css 文件变成commonJS模块，加载到JS中，style-loader是为了在JS解析的时候能创建style标签,把样式整合到style标签中，插入浏览器的head。</p><p>默认是有多少css，less 文件就会插入多少style标签，每个标签就是对应的css代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less-loader -D </span><br></pre></td></tr></table></figure><p>安装less-loader处理less文件，注意loader在代码里面配置顺序是固定的，less文件必须要经过less-loader处理，才能被css-loader识别，同理最后才能被style-loader处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: &#x2F;\.css$&#x2F;,</span><br><span class="line">    use: [</span><br><span class="line">      &#x2F;&#x2F; 从下到上运行loader</span><br><span class="line">      &#x2F;&#x2F; 创建style标签，将js资源插入，添加到head生效</span><br><span class="line">      &#39;style-loader&#39;,</span><br><span class="line">      &#x2F;&#x2F; 将css 文件变成commonjs 模块加载到js中，里面内容 是样式字符串。</span><br><span class="line">      &#39;css-loader&#39;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    test: &#x2F;\.less$&#x2F;,</span><br><span class="line">    use: [</span><br><span class="line">      &#39;style-loader&#39;,</span><br><span class="line">      &#39;css-loader&#39;,</span><br><span class="line">      &#39;less-loader&#39;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>把css,less文件提取合并，并且压缩一下形成单独的css,再通过link标签引入。目的是为了把css尽快的提供给浏览器，而不是放在js中，导致浏览器需要先解析js才能获取css,<a href="http://lemonlife.top/2020/02/23/web-fundamentals-optimize/">具体原因见博客~浏览器</a>,需要使用插件 mini-css-extract-plugin</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br></pre></td></tr></table></figure><p>把css文件和less文件配置中的,style-loader都替换成 <code>MiniCssExtractPlugin.loader</code>,在plugins中实例化插件并且制定输出文件路径,完整配置如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;js/build.js&#x27;</span>,</span><br><span class="line">    path: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">&#x27;./src/public/index.html&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// [hash:10]制定文件名称取哈希值的前10位</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename:<span class="string">&quot;css/[hash:10].css&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: <span class="string">&#x27;development&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压缩css,感觉就是去掉了css文件中的，空格注释，也可能去掉了一些写重复的样式吧，反正就是为了减少文件体积加快网络传输速度。需要用到插件<code>optimize-css-assets-webpack-plugin</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install optimize-css-assets-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>这个插件使用比较简单了,一样需要引入</p><p><code>const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">  plugins: [</span><br><span class="line">    ....,</span><br><span class="line">    new OptimizeCssAssetsWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">.... </span><br></pre></td></tr></table></figure><h3 id="处理html-图片-其他静态资源"><a class="markdownIt-Anchor" href="#处理html-图片-其他静态资源"></a> 处理HTML、图片、其他静态资源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>处理HTML文件需要使用 <code>html-webpack-plugin</code>,在plugins中实例化的时候，指定一下使用的模板，webpack会把输出的js通过script标签自动引入HTML中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack处理 HTML</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;/js/build.js&#x27;</span>,</span><br><span class="line">    path: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">//指定 src下的index.html 为HTML基础模板。</span></span><br><span class="line">      template: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: <span class="string">&#x27;development&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理图片资源的时候使用的是loader名称是<code>url-loader</code>,没有photo-loader😁😁😁,当然还要下载file-loader,因为url-loader依赖于file-loader</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install file-loader url-loader -D</span><br></pre></td></tr></table></figure><p>具体配置如下，可以解决commonJS import 图片资源，和css,less文件中url里面引用图片资源的问题。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.(jpg|png|gif|jpeg)$/,</span><br><span class="line">  loader: &#x27;url-loader&#x27;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    <span class="comment">// 图片小于8kb时候会被base64处理</span></span><br><span class="line">    limit: 8 * 1024,</span><br><span class="line">    <span class="comment">// 给图片重新命名</span></span><br><span class="line">    <span class="comment">// ext 图片原来扩展名称</span></span><br><span class="line">    name:&#x27;[hash:10].[ext]&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如果还要处理HTML模板中引入图片的问题还需要使用 <code>html-loader</code>，<br />此时要注意修改一下之前url-loader的配置,因为url-loader默认使用es6模块化解析，而html-loader引入图片是commonjs,解析时会出问题：[object Module],需要在url-loader配置文件中，关闭url-loader的es6模块化，使用commonjs解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-loader -D</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.(jpg|png|gif|jpeg)$/,</span><br><span class="line">  loader: &#x27;url-loader&#x27;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    limit: 8 * 1024,</span><br><span class="line">    <span class="comment">// 解决：关闭url-loader的es6模块化，使用commonjs解析</span></span><br><span class="line">    esModule: false,</span><br><span class="line">    name:&#x27;[hash:10].[ext]&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  test: /\.html$/,</span><br><span class="line">  loader: &#x27;html-loader&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理其他静态资源，比如字体图标文件等,需要安装file-loader,在之前安装url-loader的时候已经安装过file-loader了</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="comment">// exclude 排除 前面被处理过的 css/js/html资源</span></span><br><span class="line">   <span class="comment">// 其他文件一律交给file-loader处理。</span></span><br><span class="line">  exclude: /\.(css|js|html|less)$/,</span><br><span class="line">  loader: &#x27;file-loader&#x27;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    name: &#x27;[hash:10].[ext]&#x27;,</span><br><span class="line">    <span class="comment">// 指定其他资源都输出到static目录下</span></span><br><span class="line">    outputPath: &#x27;static&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="css兼容性处理"><a class="markdownIt-Anchor" href="#css兼容性处理"></a> css兼容性处理</h3><p>面试的时候经常会被问到，浏览器兼容性问题，作为一个学生，目前我开发都是使用Chrome和Firefox，处理浏览器兼容性问题，也就是webpack配置一下。<br />兼容css需要用插件postcss-loader,和插件的的配置postcss-preset-env(当然也可采用,autoprefixer规则取代postcss-preset-env规则)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-loader postcss-preset-env -D</span><br></pre></td></tr></table></figure><p>安装好插件，如果业务场景浏览器确定，可采用中 <code>package.json</code> 增加<code>browserslist</code>,来确定具体浏览器,至于browserslist的配置文件可看<a href="https://github.com/browserslist/browserslist">github</a></p><p>其中<code>development</code>,<code>production</code> 是指NodeJS环境(<code>process.env.NODE_ENV</code>),默认是production,而非webpack指定的mode。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;xxx&quot;</span>:<span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: <span class="string">&quot;xxxx&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;browserslist&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;development&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;last 1 version&quot;</span>,</span><br><span class="line">      <span class="string">&quot;&gt; 1%&quot;</span>,</span><br><span class="line">      <span class="string">&quot;IE 10&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;production&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;&gt; 0.2%&quot;</span>,</span><br><span class="line">      <span class="string">&quot;not dead&quot;</span>,</span><br><span class="line">      <span class="string">&quot;not op_mini all&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体配置如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> miniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="comment">//指定node环境为 development</span></span><br><span class="line">process.env.NODE_ENV = <span class="string">&#x27;development&#x27;</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;...&quot;</span>,</span><br><span class="line">  output: <span class="string">&quot;....&quot;</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          miniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              plugins: <span class="function">(<span class="params">loader</span>) =&gt;</span> [</span><br><span class="line">                <span class="comment">//也可以采用</span></span><br><span class="line">                <span class="comment">// require(&#x27;postcss-preset-env&#x27;)()</span></span><br><span class="line">                <span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>)()</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:<span class="string">&quot;.....&quot;</span>,</span><br><span class="line">  mode: <span class="string">&#x27;.....&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="devserver"><a class="markdownIt-Anchor" href="#devserver"></a> devServer</h3><p>配置devServer,相当于本地运行了一个NodeJS后来服务,需要安装插件<code>webpack-dev-server</code>,此时webpack编译的结果不会输出在我们指定的目录下，因为dev-server不输出文件，可以想象成文件放内存中，node服务可以访问到，因此我们手动刷新浏览器可以看到正确结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ....,</span><br><span class="line">  mode: <span class="string">&#x27;.....&#x27;</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    <span class="comment">// 项目构建后路径</span></span><br><span class="line">    contentBase: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">    <span class="comment">// 启动gzip压缩</span></span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 端口号</span></span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    <span class="comment">// 自动打开浏览器</span></span><br><span class="line">    open: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时我建议在 <code>package.json</code> 的 <code>script</code> 脚本中写入两条脚本，分别用于之前的打包模式和开启devServer 模式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ....,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    ....,</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">    &quot;build:prod&quot;: &quot;webpack --mode=production&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --open&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过运行 <code>npm run build</code> 或者<code>npm run build:prod</code> 获取之前类似的输出，<code>npm run dev</code> 开启webpack服务,此时还不支持热更新和自动刷新浏览器，需要手动刷新，才能看到结果。</p><blockquote><p>更多devServer看 <a href="https://www.webpackjs.com/configuration/dev-server/">官网配置</a></p></blockquote><h3 id="javascript代码兼容性"><a class="markdownIt-Anchor" href="#javascript代码兼容性"></a> Javascript代码兼容性</h3><p>前面配置了css代码的兼容性处理，但是JS代码其实更需要兼容，JS不兼容可能就是无法运行。处理JS兼容当然就是<code>babel</code>家族。<a href="https://www.babeljs.cn/">babel官网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install @babel&#x2F;cli @babel&#x2F;core @babel&#x2F;preset-env babel-loader -D</span><br><span class="line"></span><br><span class="line">npm install @babel&#x2F;plugin-transform-runtime  -D </span><br><span class="line"></span><br><span class="line">npm install @babel&#x2F;plugin-proposal-class-properties -D</span><br><span class="line"></span><br><span class="line">npm install @babel&#x2F;runtime @babel&#x2F;runtime-corejs2 --save</span><br></pre></td></tr></table></figure><p>在项目根目录编写 <code>babel.config.js</code> 文件,写入如下配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">       [</span><br><span class="line">         <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">         <span class="comment">//指定要兼容的浏览器，以及版本</span></span><br><span class="line">         <span class="string">&quot;targets&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;esmodules&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="string">&quot;chrome&quot;</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">          <span class="string">&quot;firefox&quot;</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">          <span class="string">&quot;ie&quot;</span>: <span class="string">&#x27;9&#x27;</span>,</span><br><span class="line">          <span class="string">&quot;safari&quot;</span>: <span class="string">&#x27;10&#x27;</span>,</span><br><span class="line">           <span class="string">&quot;edge&quot;</span>: <span class="string">&#x27;17&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">    [<span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>, &#123;</span><br><span class="line">      <span class="string">&quot;corejs&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&quot;@babel/transform-arrow-functions&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在webpack.config.js中用babel处理js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">  entry:<span class="string">&quot;....&quot;</span>,</span><br><span class="line">  output:<span class="string">&quot;....&quot;</span>,</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123; </span><br><span class="line">        <span class="comment">// 匹配js和jsx文件</span></span><br><span class="line">        test: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;babel-loader&quot;</span>],</span><br><span class="line">        <span class="comment">//排除node_modules里面的文件</span></span><br><span class="line">        <span class="comment">// 防止babel编译了，node_modules里面代码包。</span></span><br><span class="line">        exclude: [join(__dirname, <span class="string">&quot;node_modules&quot;</span>)]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的babel配置 (我用的是<a href="https://babeljs.io/docs/en/v7-migration">babel7</a>的配置) 是我上次配置ts的，不知道会不会出错，应该没有问题， <code>presets</code> 里面指定了<code>target</code>, <code>core-js</code> 部分没问题，应该就可以兼容ie。</p><blockquote><p>我认为 webpack最好的教程是来源与官网，这是我看了官网和网上找的一些视频教程之后总结的一些基础操作，详细的配置可看 <a href="https://webpack.docschina.org/">webpack官网~中文</a>，本文中部分文字来源于尚硅谷的视频，感谢尚硅谷老师的分享。【这不是广告只是为了声明版权😂】</p></blockquote><blockquote><p>以上差不多就是 webpack的一些基本操作了,后面打算把webpack配置优化部分也补上，然后自己封装一个脚手架，再加上一些ESLint的配置,欢迎大家持续关注 <a href="http://lemonlife.top/"><strong>http://lemonlife.top</strong></a> 最近有点忙/(ㄒoㄒ)/~~</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器工作原理~优化篇</title>
      <link href="2020/02/23/web-fundamentals-optimize/"/>
      <url>2020/02/23/web-fundamentals-optimize/</url>
      
        <content type="html"><![CDATA[<h3 id="优化css"><a class="markdownIt-Anchor" href="#优化css"></a> 优化CSS</h3><p>由之前的原理篇，我们知道浏览器必须要先加载生成DOM和CSSOM才能进行页面渲染，而前端为了适配不同设备可能需要很多css,例如打印设备中显示的css，移动端，网页端不同的css，此时常用的应该是 <code>@media</code> 属性，但是解析越多css，就会越耗时，因此可以把属于某一特性的css单独提取出来,<code>link</code> 引入即可，做到一开始，只下载不解析。如下：浏览器会下载两个样式表 ，但 暂时不会解析 <code>media=&quot;print&quot;</code> 中的样式表</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 浏览器默认加载和解析的css样式表 */</span></span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;xxxx.css&quot; &gt;</span><br><span class="line"><span class="comment">/* 浏览器只在要传向打印设备的时候，才启用的样式表 */</span></span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;xxxx.css&quot; media=&quot;print&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="优化javascript"><a class="markdownIt-Anchor" href="#优化javascript"></a> 优化JavaScript</h3><p>首先压缩文件减少网络传输时间，这一点基本都是大家都适用的，(建议webpack开启生成环境模式，会自动启动js压缩)。</p><p>默认情况下，JavaScript 执行会&quot;阻止DOM解析器&quot;(总之感觉形成RenderTree和运行JS是一个相互阻止的过程，毕竟两者可能对一个产生影响),当浏览器遇到文档中的脚本时，它必须暂停 DOM 构建，将控制权移交给 JavaScript 运行时，让脚本执行完毕，然后再继续构建 DOM。我们在前面的示例中已经见过内联脚本的实用情况。实际上，内联脚本始终会阻止解析器，除非您编写额外代码来推迟它们的执行。</p><p>因此一般都采用 <code>&lt;script src=&quot;xxx.js&quot;&gt;&lt;/script&gt;</code> 引入的方式。<br />采用这种方式，虽然JS不影响DOM解析的过程，但是DOM会阻断JS的运行。<br />而且如果脚本放在,被执行的元素前，是获取不到该元素的，因此以下代码浏览器会报错。<code>TypeError: Cannot read property 'style' of null</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-id">#root</span> &#123;</span></span><br><span class="line">color: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span> 我是什么颜色<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- index.js脚本内容  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- document.getElementById(&#x27;root&#x27;).style.color = &#x27;red&#x27; --&gt;</span></span><br></pre></td></tr></table></figure><p>所以我们想采用异步加载的方式来处理这些问题。</p><ul><li><p>使用window.onload实现js函数异步运行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>).style.color = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>采用 <code>&lt;script src=&quot;./index.js&quot; async&gt;&lt;/script&gt;</code> 引入脚本</p><p>浏览器遇到async引入的js脚本时候，不会阻止DOM和CSSOM形成过程，同时脚本也不会因为CSS对象而停止执行.</p></li><li><p>采用 <code>&lt;script src=&quot;./index.js&quot; defer&gt;&lt;/script&gt;</code></p><p>脚本标记也可以采用 defer 属性，方法与采用 async 属性相同。差别在于对于 defer，脚本需要等到文档解析后执行，而 async 允许脚本在文档解析时位于后台运行,对于文档中声明的多个defer脚本，会按照下载顺序执行，但是对于async，基本无执行顺序的概念，依次async中存放的代码，一定是互相没有直接引用关系的。</p></li></ul><h3 id="预加载扫描preload"><a class="markdownIt-Anchor" href="#预加载扫描preload"></a> 预加载扫描(Preload)</h3><p>可以指定一些必须的资源，加上 preload 标识,浏览器会优先从服务器获取这些资源</p><p><a href="https://zhuanlan.zhihu.com/p/32561606">知乎关于预加载链接</a></p><h3 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h3><p>优化方法总结如下</p><ul><li><p>资源最小化,采用Gzip进行文本压缩</p></li><li><p>优化CSS</p></li><li><p>采用异步js的方式</p></li><li><p>预加载扫描</p></li><li><p>减小关键路径的长度(critical path),即减少影响页面展示的请求次数</p><ul><li>正确使用HTTP缓存机制</li><li>使用HTTP2.0(一次可获得更多资源，可以减少请求次数，降低握手耗时)</li><li>服务端渲染的方式可以理解成关键路径为1，我得到了html就可以展示页面了，提高了SEO,一定程度上加速了首页显示</li></ul></li></ul><blockquote><p>教程中大多数图片和文字资源来源于Google官网</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈的压入、弹出序列</title>
      <link href="2020/02/22/validate-stack-sequences/"/>
      <url>2020/02/22/validate-stack-sequences/</url>
      
        <content type="html"><![CDATA[<h3 id="題目描述"><a class="markdownIt-Anchor" href="#題目描述"></a> 題目描述</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h3><p>首先我们知道原始数的序列题目已知的，如 <code>[1,2,3,4,5]</code> ,从该序列的第一个数开始每次都要进行一次<code>必须操作</code>,压入该序列一个数到 <code>临时栈</code> ，然后执行<code>可选操作</code>弹出<code>临时栈</code>中的数(弹出的个数随意，可以不弹出，即不执行这个可选操作，也可以全部都弹出)，直到遍历到序列最后一个，压入临时栈后，依次弹出<code>临时栈</code>中剩下所有的数。弹出的数每次都会被记录下来。题目现在给出了弹出序列，意思就是确定了我们在哪一步要执行弹出栈这个<code>可选操作</code>，即我们压入的数，和弹出序列中的第一个数相等时候，开始执行可选操作，每弹出一个，弹出序列的指针向后一次，直到 <code>临时栈</code> 栈顶元素和弹出序列中指针，指的数不相等为止，继续执行下一次操作。</p><h3 id="题例分析"><a class="markdownIt-Anchor" href="#题例分析"></a> 题例分析</h3><p><code>[1,2,3,4,5]</code>  <code>[4,5,3,2,1]</code></p><table><thead><tr><th>必须操作</th><th>临时栈</th><th>可选操作</th><th>原因</th></tr></thead><tbody><tr><td>push(1)</td><td>[1]</td><td>不执行</td><td>4 != 1</td></tr><tr><td>push(2)</td><td>[1,2]</td><td>不执行</td><td>4 != 2</td></tr><tr><td>push(3)</td><td>[1,2,3]</td><td>不执行</td><td>4 != 3</td></tr><tr><td>push(4)</td><td>[1,2,3,4]</td><td>pop(4)</td><td>4 == 4,5 != 3</td></tr><tr><td>push(5)</td><td>[1,2,3,5]</td><td>pop(5),pop(3),pop(2),pop(1)</td><td>最后了,依次弹出临时栈中剩余的元素</td></tr></tbody></table><blockquote><p>弹出序列记录为[4,5,3,2,1] 返回 true</p></blockquote><p><code>[1,2,3,4,5]</code>  <code>[4,3,5,1,2]</code></p><table><thead><tr><th>必须操作</th><th>临时栈</th><th>可选操作</th><th>原因</th></tr></thead><tbody><tr><td>push(1)</td><td>[1]</td><td>不执行</td><td>4 != 1</td></tr><tr><td>push(2)</td><td>[1,2]</td><td>不执行</td><td>4 != 2</td></tr><tr><td>push(3)</td><td>[1,2,3]</td><td>不执行</td><td>4 != 3</td></tr><tr><td>push(4)</td><td>[1,2,3,4]</td><td>pop(4),pop(3)</td><td>4 == 4,3 == 3, 5 != 2</td></tr><tr><td>push(5)</td><td>[1,2,5]</td><td>pop(5),pop(2),pop(1)</td><td>最后了,依次弹出临时栈中剩余的元素</td></tr></tbody></table><blockquote><p>弹出序列记录为[4,3,5,2,1] 返回 false</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">pushed</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">popped</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> validateStackSequences = <span class="function"><span class="keyword">function</span> (<span class="params">pushed, popped</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pushed.length == <span class="number">0</span> &amp;&amp; popped.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pushed.length == <span class="number">0</span> || popped.length == <span class="number">0</span> || pushed.length != popped.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> stack = [] <span class="comment">//辅助栈</span></span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pushed.length; i++) &#123;</span><br><span class="line">    stack.push(pushed[i])</span><br><span class="line">    <span class="keyword">while</span>(stack.length !== <span class="number">0</span>  &amp;&amp; j&lt;popped.length &amp;&amp; stack[stack.length-<span class="number">1</span>] === popped[j] )&#123;</span><br><span class="line">      j++</span><br><span class="line">      stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.length === <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺时针打印矩阵</title>
      <link href="2020/02/21/spiral-order-matrix/"/>
      <url>2020/02/21/spiral-order-matrix/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><h3 id="解决思路"><a class="markdownIt-Anchor" href="#解决思路"></a> 解决思路</h3><p>题目要求顺时针打印，可以采用定义右(right)，下(down)，左(left)，上(up) 四个方向，和分别对应的四个边界，每次触碰到边界的时候，就需要转方向了。<br/><br />需要注意的是，当我们触碰到右边界时,需要改变的是上边界，此时上边界应该加一，右边界不变，因为 触碰到右边界说明上边界已经走完了。同理<br/><br />触碰到下边界时候，右边界减一，触碰到左边界时候下边界减一，触碰到上边界时候左边界加一，依次类推。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> spiralOrder = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (matrix.length == <span class="number">1</span>) <span class="keyword">return</span> matrix[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> matrix;</span><br><span class="line">  <span class="keyword">let</span> dir = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>]] <span class="comment">//  右 下 左 上 四个方向</span></span><br><span class="line">  <span class="keyword">let</span> up = <span class="number">0</span> <span class="comment">//定义上墙壁</span></span><br><span class="line">  <span class="keyword">let</span> right = matrix[<span class="number">0</span>].length - <span class="number">1</span> <span class="comment">// 定义右墙壁</span></span><br><span class="line">  <span class="keyword">let</span> down = matrix.length - <span class="number">1</span> <span class="comment">// 定义下墙壁</span></span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span> <span class="comment">// 定义左墙壁</span></span><br><span class="line">  <span class="keyword">let</span> times = <span class="number">0</span> <span class="comment">// 转方向的次数</span></span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">let</span> resLength = matrix[<span class="number">0</span>].length * matrix.length <span class="comment">//定义最终数据长度</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span> <span class="comment">//行</span></span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span> <span class="comment">//列 </span></span><br><span class="line">  <span class="keyword">while</span> (res.length != resLength) &#123;</span><br><span class="line">    <span class="comment">// 开始行走</span></span><br><span class="line">    <span class="comment">// 右</span></span><br><span class="line">    <span class="keyword">if</span>(j &gt; right)&#123;</span><br><span class="line">      j--</span><br><span class="line">      up++</span><br><span class="line">      times++</span><br><span class="line">      i=i+dir[times % dir.length][<span class="number">0</span>]</span><br><span class="line">      j=j+dir[times % dir.length][<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;down)&#123;</span><br><span class="line">      i--</span><br><span class="line">      right--</span><br><span class="line">      times++</span><br><span class="line">      i=i+dir[times % dir.length][<span class="number">0</span>]</span><br><span class="line">      j=j+dir[times % dir.length][<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左</span></span><br><span class="line">    <span class="keyword">if</span>(j&lt;left)&#123;</span><br><span class="line">      j++</span><br><span class="line">      down--</span><br><span class="line">      times++</span><br><span class="line">      i=i+dir[times % dir.length][<span class="number">0</span>]</span><br><span class="line">      j=j+dir[times % dir.length][<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;up)&#123;</span><br><span class="line">      i++</span><br><span class="line">      left++</span><br><span class="line">      times++</span><br><span class="line">      i=i+dir[times % dir.length][<span class="number">0</span>]</span><br><span class="line">      j=j+dir[times % dir.length][<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(matrix[i][j])</span><br><span class="line">    i=i+dir[times % dir.length][<span class="number">0</span>]</span><br><span class="line">    j=j+dir[times % dir.length][<span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器工作原理~渲染篇</title>
      <link href="2020/02/21/web-fundamentals/"/>
      <url>2020/02/21/web-fundamentals/</url>
      
        <content type="html"><![CDATA[<h3 id="关键渲染路径"><a class="markdownIt-Anchor" href="#关键渲染路径"></a> 关键渲染路径</h3><p>关键渲染路径是指浏览器所经历的一系列步骤。从而将HTML,CSS和JavaScript，转换成屏幕上呈现的像素内容，首先获取HTML并且开始构建文档对象模型(DOM),然后获取CSS构建CSS对象模型(CSSOM),然后将两者结合形成渲染树(Render Tree),然后浏览器根据渲染树知道了每个元素的内容和位置(Layout)。最后渲染引擎将元素绘制在屏幕上(Paint).</p><p><img src="http://blogimage.lemonlife.top/202002211149_876.png?/" alt="" /></p><h3 id="构建对象模型html转成dom"><a class="markdownIt-Anchor" href="#构建对象模型html转成dom"></a> 构建对象模型(HTML转成DOM)</h3><p>浏览器渲染页面要先构建DOM和CSSOM,因此，要尽快将HTML,CSS提供给浏览器。<br><br />当我们在浏览器输入 <code>URL</code> 的时候,浏览器会向服务器请求资源拿到HTML等资源，然后拿到的HTML文档头部规定了浏览器按照什么样的规范来处理HTML文``件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 按照Java thymeleaf 模板引擎的规则解析 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 按照xhtml 规则解析 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每当解析遇到标签,浏览器会生成一个令牌(Token),一开始是标签HTML的令牌 <code>StartTag:HTML</code> ,然后是 <code>StartTag:head</code> ,这一整个流程由Token生成器来完成，当Token生成器在执行这一过程的时候，另一个进程正在消耗这些Token，并将他们转化成节点对象,我们创建了html节点之后消耗下一个令牌创建了head节点，由于head的结束令牌<code>EndTag:head</code>标签,在<code>endTag:html</code>，之前说明 head是html子节点,所以最后所有的Token都消费完的时候，就生成了文档对象模型(DOM,document object model),生成的DOM树表示了HTML的内容和属性，以及各个节点之间的关系。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;awesome-photo.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://blogimage.lemonlife.top/202002222033_585.png?/" alt="图片来源Google" /></p><ol><li>转换： 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。</li><li>令牌化： 浏览器将字符串转换成 W3C HTML5 标准规定的各种令牌，例如，<code>&lt;html&gt;</code>、<code>&lt;body&gt;</code> 以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。</li><li>词法分析： 发出的令牌转换成定义其属性和规则的“对象”。</li><li>DOM 构建： 最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。</li></ol><p><img src="http://blogimage.lemonlife.top/202002222035_775.png?/" alt="图片来源Google" /></p><h3 id="生成cssom"><a class="markdownIt-Anchor" href="#生成cssom"></a> 生成CSSOM</h3><p>浏览器也会根据css规范来解析css,与DOM不同的是css会向下层叠，因此也叫层叠样式表或者层叠样式规则，即子节点可能会继承父节点的一些属性，比如body中定义了字体大小16px。其他的子属性会继承这一大小。而且浏览器解析css过程是阻塞的，浏览器需要解析完所有的css才会使用css样式(和浏览器的回流重绘一样)。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">16px</span> &#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-weight</span>: bold &#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123; <span class="attribute">display</span>: none &#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123; <span class="attribute">float</span>: right &#125;</span><br></pre></td></tr></table></figure><p>与处理 HTML 时一样，我们需要将收到的 CSS 规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复 HTML 过程，不过是为 CSS 而不是 HTML.</p><p><img src="http://blogimage.lemonlife.top/202002222037_642.png?/" alt="CSS处理过程" /></p><p>CSS 字节转换成字符，接着转换成令牌和节点，最后链接到一个称为“CSS 对象模型”(CSSOM) 的树结构内：</p><p><img src="http://blogimage.lemonlife.top/202002222038_142.png?/" alt="CSSOM" /></p><p>CSSOM 为何具有树结构？为页面上的任何对象计算最后一组样式时，浏览器都会先从适用于该节点的最通用规则开始（例如，如果该节点是 body 元素的子项，则应用所有 body 样式），然后通过应用更具体的规则（即规则“向下级联”）以递归方式优化计算的样式。</p><p>以上面的 CSSOM 树为例进行更具体的阐述。span 标记内包含的任何置于 body 元素内的文本都将具有 16 像素字号，并且颜色为红色 — font-size 指令从 body 向下级联至 span。不过，如果某个 span 标记是某个段落 § 标记的子项，则其内容将不会显示。</p><p>还请注意，以上树并非完整的 CSSOM 树，它只显示了我们决定在样式表中替换的样式。每个浏览器都提供一组默认样式（也称为“User Agent 样式”），即我们不提供任何自定义样式时所看到的样式，我们的样式只是替换这些默认样式（<a href="https://www.iecss.com/">例如默认 IE 样式</a>）。</p><h3 id="形成rendertree"><a class="markdownIt-Anchor" href="#形成rendertree"></a> 形成RenderTree</h3><p>从DOM树的根节点开始，去匹配对应的CSS样式，然后把CSS样式复制到对应DM节点中，作为DOM节点的属性,如果该节点是DOM根节点,就会形成RenderTree 根节点,渲染过程中遇到<code>display:none</code>的节点,会先不处理他和他的子节点。即不把<code>display:none</code>的节点，加载到RenderTree中</p><h3 id="布局layout"><a class="markdownIt-Anchor" href="#布局layout"></a> 布局(Layout)</h3><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;</code><br />布局的宽度应该等于设备的宽度，如果没有可能会采用默认的宽度例如<code>width:100%</code> 会变成<code>980px</code>。</p><p>通过浏览器控制台分析布局事件，如下图是某网页加载过程，可找出事件耗时比较大的过程，分页原因给予优化，优化布局和代码，尽量做到批量布局，避免出现多个布局事件。<br /><img src="http://blogimage.lemonlife.top/202002222114_253.png?/" alt="RenderTree加载过程" /></p><h3 id="绘制页面paint"><a class="markdownIt-Anchor" href="#绘制页面paint"></a> 绘制页面(Paint)</h3><p>同上我们可以获取到，网页Paint的过程，可见下图网页主要耗时是渲染层合并的过程(Composite Layers,<a href="https://blog.csdn.net/weixin_40581980/article/details/81453283">了解更多</a>)</p><p><img src="http://blogimage.lemonlife.top/202002222137_360.png?/" alt="Paint过程图" /></p><h3 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h3><p>首先我们接收到HTML(本地或者浏览器)，然后开始解析它，DOM会逐步构建，并非一次性响应。在head中如果发现css和js链接，就会发请求，为了形成RenderTree,所以会先解析CSS形成CSSOM,解析CSS文件的过程会屏蔽JS引擎，相当于给DOM上锁，防止CSS,JS同时修改的现象发生。完成CSSOM会取消屏蔽 JS引擎，然后接收JS,然后执行JS,JavaScript解析完成后，我们就可以继续构建DOM的构建。获取DOM和CSSOM后,  我们将合并二者并构建RenderTree,然后运行布局绘制网页。</p><p><img src="http://blogimage.lemonlife.top/202002222158_212.png?/" alt="Google习题" /></p><ul><li>浏览器优化应当讲究，先权衡再优化的发展，因此就需要用Google Devtools 具体分析。</li><li>默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。请务必精简您的 CSS，尽快提供它，并利用媒体类型和查询来解除对渲染的阻塞。在渲染树构建中，我们看到关键渲染路径要求我们同时具有 DOM 和 CSSOM 才能构建渲染树。这会给性能造成严重影响：<strong>HTML 和 CSS 都是阻塞渲染的资源</strong></li></ul><blockquote><p>教程中大多数图片和文字资源来源于Google官网，有条件的同学可以去看看。<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=zh-cn">克服GFW地址</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连续数组</title>
      <link href="2020/02/17/leetcode-525/"/>
      <url>2020/02/17/leetcode-525/</url>
      
        <content type="html"><![CDATA[<p>给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] 是具有相同数量0和1的最长连续子数组。</span><br></pre></td></tr></table></figure><h3 id="解决思路"><a class="markdownIt-Anchor" href="#解决思路"></a> 解决思路</h3><p>把0当成-1,然后依次累加数组中的元素，记录每次求和不同的结果的下标。存入Map,如果遇到相同的值，当前下标减去Map中存在的下标即为最大的长度。(循环的思想)。所有要提前存放好Map(0,-1)</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMaxLength = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> maxLength = <span class="number">0</span></span><br><span class="line">  map.set(<span class="number">0</span>,-<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">      count -= <span class="number">1</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      count+=<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!map.has(count))&#123;</span><br><span class="line">       map.set(count,i)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      maxLength = <span class="built_in">Math</span>.max(maxLength,i - map.get(count))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxLength</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>验证二叉搜索树</title>
      <link href="2020/02/14/leetcode-98/"/>
      <url>2020/02/14/leetcode-98/</url>
      
        <content type="html"><![CDATA[<h2 id="验证二叉搜索树"><a class="markdownIt-Anchor" href="#验证二叉搜索树"></a> 验证二叉搜索树</h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。<br />假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure><h3 id="解决思路"><a class="markdownIt-Anchor" href="#解决思路"></a> 解决思路</h3><ul><li>中序遍历结果为什序</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><ul><li>中序遍历法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValidBST = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> arr = []</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">inOrder</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> arr</span><br><span class="line">     &#125;</span><br><span class="line">     inOrder(root.left)</span><br><span class="line">     arr.push(root.val)</span><br><span class="line">     inOrder(root.right)</span><br><span class="line">     <span class="keyword">return</span> arr</span><br><span class="line">   &#125;</span><br><span class="line">   inOrder(root)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(arr[i+<span class="number">1</span>]&lt;=arr[i])&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转一个单链表</title>
      <link href="2020/02/13/leetcode-206/"/>
      <url>2020/02/13/leetcode-206/</url>
      
        <content type="html"><![CDATA[<blockquote><p>反转一个单链表</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><h3 id="解决思路"><a class="markdownIt-Anchor" href="#解决思路"></a> 解决思路</h3><p>先提取下链表头结点(打断原有链表)。再从先剩下的链表中,取链表头结点。加到上一步取下来的节点的头部。引用LeetCode网友的一句话 <code>斩断过去,不忘前事</code>。依次往后完成链表反转。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span> </span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> tmp = head.next</span><br><span class="line">      <span class="comment">// 斩断过去</span></span><br><span class="line">      head.next = pre</span><br><span class="line">      pre = head</span><br><span class="line">      <span class="comment">// 不忘前事</span></span><br><span class="line">      head = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除排序数组中的重复项</title>
      <link href="2020/02/13/leetcode-26/"/>
      <url>2020/02/13/leetcode-26/</url>
      
        <content type="html"><![CDATA[<h3 id="删除排序数组中的重复项"><a class="markdownIt-Anchor" href="#删除排序数组中的重复项"></a> 删除排序数组中的重复项</h3><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br/><br />不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><p>本题可采用 <code>双指针模型</code> 解题,在数组头部声明两个指针 <code>i,j</code> 指针 <code>i</code> 固定,指针 <code>j</code> 向后移动。遇到指针<code>j</code>指向的数,不等于指针<code>i</code>指向的数的时候,指针<code>i</code>+1,并且把此时指向的数的数值改成此时指针 <code>j</code> 指向的数值。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// if(nums.length&gt;0)&#123;</span></span><br><span class="line">    <span class="comment">//   let index;</span></span><br><span class="line">    <span class="comment">//   nums = nums.filter(value=&gt;&#123;</span></span><br><span class="line">    <span class="comment">//     if(value != index)&#123;</span></span><br><span class="line">    <span class="comment">//       index = value</span></span><br><span class="line">    <span class="comment">//       return true</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//   &#125;)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">if</span>(nums.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> nums.length</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>,j =<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;nums.length)&#123;</span><br><span class="line">      <span class="keyword">if</span>(nums[i] != nums[j])&#123;</span><br><span class="line">        i++</span><br><span class="line">        nums[i] = nums[j]</span><br><span class="line">      &#125;</span><br><span class="line">      j++ </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="2020/02/13/leetcode-3/"/>
      <url>2020/02/13/leetcode-3/</url>
      
        <content type="html"><![CDATA[<h3 id="无重复字符的最长子串"><a class="markdownIt-Anchor" href="#无重复字符的最长子串"></a> 无重复字符的最长子串</h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这题算是一个典型的滑动窗口模型,可以解决的问题。从一开始扩展窗口。每次遇到有重复的数字,或者窗口本身内部有重复的数字，窗口前进一格。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> slideWindow = []</span><br><span class="line">    <span class="keyword">let</span> sArr = s.split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(sArr.length&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>(sArr).size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;sArr.length;i++)&#123;</span><br><span class="line">      <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(slideWindow)</span><br><span class="line">      <span class="keyword">if</span>(set.has(sArr[i]) || set.size &lt; slideWindow.length)&#123;</span><br><span class="line">        slideWindow.shift()</span><br><span class="line">      &#125;</span><br><span class="line">      slideWindow.push(sArr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slideWindow.length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长回文子串</title>
      <link href="2020/02/13/leetcode-5/"/>
      <url>2020/02/13/leetcode-5/</url>
      
        <content type="html"><![CDATA[<h3 id="最长回文子串"><a class="markdownIt-Anchor" href="#最长回文子串"></a> 最长回文子串</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><p>根据回文的特点，可知长度有 奇偶 两种,因此 我们分别以每个字符作为奇数类别的中心，分别向两边扩展。然后用两个相等的字符串作为偶数类别中心。向两边扩展。最后得到,两类中最长的回文字符串返回。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    sArr = s.split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(s.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">let</span> oddStr = sArr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> evenStr = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;s.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(sArr[i] == sArr[i+<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="comment">// 找到相等的字符串</span></span><br><span class="line">        <span class="keyword">let</span> tmpEvenStr = sArr[i]+sArr[i+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">1</span> <span class="comment">//定义偏移量</span></span><br><span class="line">        <span class="keyword">while</span>((i-index) &gt;=<span class="number">0</span> &amp;&amp; (i+<span class="number">1</span>+index) &lt; sArr.length &amp;&amp; sArr[i-index] == sArr[i+index+<span class="number">1</span>])&#123;</span><br><span class="line">          tmpEvenStr =  sArr[i-index] + tmpEvenStr + sArr[i+index+<span class="number">1</span>]</span><br><span class="line">          index ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmpEvenStr.length &gt; evenStr.length)&#123;</span><br><span class="line">          evenStr = tmpEvenStr</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> oddNumOffset = <span class="number">1</span></span><br><span class="line">      <span class="keyword">let</span> tmpOddStr = sArr[i]</span><br><span class="line">      <span class="keyword">while</span>((i-oddNumOffset) &gt;=<span class="number">0</span> &amp;&amp; (i+oddNumOffset) &lt;= sArr.length &amp;&amp; sArr[i-oddNumOffset] == sArr[i+oddNumOffset])&#123;</span><br><span class="line">        tmpOddStr = sArr[i-oddNumOffset] + tmpOddStr + sArr[i+oddNumOffset]</span><br><span class="line">        oddNumOffset++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(tmpOddStr.length &gt; oddStr.length)&#123;</span><br><span class="line">        oddStr = tmpOddStr</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(oddStr.length&gt;evenStr.length)&#123;</span><br><span class="line">      <span class="keyword">return</span> oddStr</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> evenStr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :152 ms, 在所有 JavaScript 提交中击败了56.65%的用户</span><br><span class="line">内存消耗 :50.5 MB, 在所有 JavaScript 提交中击败了27.49%的用户</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP</title>
      <link href="2020/02/11/computer-networks/"/>
      <url>2020/02/11/computer-networks/</url>
      
        <content type="html"><![CDATA[<h3 id="osi-7层网络模型"><a class="markdownIt-Anchor" href="#osi-7层网络模型"></a> OSi 7层网络模型</h3><blockquote><p>为了解耦而分层。OSI的7层模型中的 <code>表示层和会话层</code> 被封装在 TCP/IP 的应用层。TCP/IP中的 <code>传输层，网络层，数据控制层，物理层</code> 都由操作系统内核实现。</p></blockquote><h3 id="tcp特点"><a class="markdownIt-Anchor" href="#tcp特点"></a> TCP特点</h3><ul><li>面向连接的可靠的传输协议。</li><li>，</li></ul><p><img src="http://blogimage.lemonlife.top/202002111209_27.png?/" alt="模型" /></p><h3 id="三次握手四次挥手"><a class="markdownIt-Anchor" href="#三次握手四次挥手"></a> 三次握手/四次挥手</h3><blockquote><p>我方应用层去调用我方传输控制层。我方传输控制层生成想要握手的第一个包<code>sync</code>。<br />对方传输控制层接收到消息后，产生<code>sync+ack</code>包，发送回我方。<br />我发 把<code>ack</code>包返回给服务器。</p></blockquote><p>**序列号seq：**占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。<br />**确认号ack：**占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号(仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效)<br />**同步SYN：**连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</p><p><strong>终止FIN：</strong> 用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</p><p><img src="http://blogimage.lemonlife.top/202002111332_949.png?/" alt="三次握手模型" /></p><p><img src="http://blogimage.lemonlife.top/202002111331_376.png?/" alt="四次挥手模型" /></p><p><img src="http://blogimage.lemonlife.top/202002111335_985.png?/" alt="" /></p><p><img src="http://blogimage.lemonlife.top/202002111337_197.png?/" alt="" /></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="2020/02/10/reverse-linked-list/"/>
      <url>2020/02/10/reverse-linked-list/</url>
      
        <content type="html"><![CDATA[<h2 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> 反转链表</h2><blockquote><p>反转一个单链表。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.next &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>斩断过去,不忘前事,定义一个变量储存链表，定义另一个临时变量插入链表</p></blockquote><h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span> </span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> tmp = head.next</span><br><span class="line">      <span class="comment">// 斩断过去</span></span><br><span class="line">      head.next = pre</span><br><span class="line">      pre = head</span><br><span class="line">      <span class="comment">// 不忘前事</span></span><br><span class="line">      head = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="反转指定位置的链表"><a class="markdownIt-Anchor" href="#反转指定位置的链表"></a> 反转指定位置的链表</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseBetween = <span class="function"><span class="keyword">function</span>(<span class="params">head, m, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> originList = <span class="keyword">new</span> ListNode(<span class="number">0</span>)</span><br><span class="line">  originList.next = head</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> listNode = originList</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    listNode = listNode.next</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> prev = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> cur = listNode.next</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = cur.next</span><br><span class="line">    cur.next = prev</span><br><span class="line">    prev = cur</span><br><span class="line">    cur = next</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 m 的 next 指向 n 指针的 next, 同时将排在 m 前面一位的指针的 next 指向 n</span></span><br><span class="line">  listNode.next.next = cur</span><br><span class="line">  listNode.next = prev</span><br><span class="line">  <span class="keyword">return</span> originList.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题目</title>
      <link href="2020/02/10/interview/"/>
      <url>2020/02/10/interview/</url>
      
        <content type="html"><![CDATA[<h3 id="合并两个链表"><a class="markdownIt-Anchor" href="#合并两个链表"></a> 合并两个链表</h3><blockquote><p>具体解法见博客 <a href="http://lemonlife.top/2020/02/06/mergeListNode/">合并两个排序的链表</a></p></blockquote><h3 id="链表反序输出不外申请内存空间"><a class="markdownIt-Anchor" href="#链表反序输出不外申请内存空间"></a> 链表反序输出,不外申请内存空间</h3><blockquote><p>具体解法见博客 <a href="http://lemonlife.top/2020/02/10/reverse-linked-list/">反转链表</a></p></blockquote><h3 id="010203吗为什么"><a class="markdownIt-Anchor" href="#010203吗为什么"></a> 0.1+0.2===0.3吗?，为什么</h3><blockquote><p>在JS运行环境中 <code>0.1+0.2=0.30000000000000004</code><br /><code>(0.1).toString(2)=0.0001100110011001100110011001100110011001100110011001101</code>,小数在转换成二进制存储时容易造成无限循环的形式<br />解决办法: 可将小数转换成整数计算,如: <code>(0.1*10+0.2*10)/10</code></p></blockquote><h3 id="手动实现arrayreduce"><a class="markdownIt-Anchor" href="#手动实现arrayreduce"></a> 手动实现Array.reduce()</h3><p>数组先依次传给<code>a,b</code> 然后返回值给a,下一个值给b,依次迭代。直到数组结束。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> sum = array.reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a+b)</span><br><span class="line"><span class="built_in">console</span>.log(sum)  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><blockquote><p>手动实现如下</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">Array</span>.prototype.MyReduce = <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> params(...this)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [params(...this), ...this.slice(<span class="number">2</span>)].MyReduce(params)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sum = array.MyReduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 15</span></span><br><span class="line"><span class="keyword">let</span> multiply = array.MyReduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a * b)</span><br><span class="line"><span class="built_in">console</span>.log(multiply) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><h3 id="垂直居中的方法"><a class="markdownIt-Anchor" href="#垂直居中的方法"></a> 垂直居中的方法</h3><ol><li><code>flex</code>布局 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;</span><br><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">column</span>;  </span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">center</span>;</span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">center</span>;</span><br></pre></td></tr></table></figure></li><li>使用 <code>display:-webkit-box</code><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line"><span class="selector-tag">-webkit-box-align</span>: <span class="selector-tag">center</span>;</span><br><span class="line"><span class="selector-tag">-webkit-box-pack</span>: <span class="selector-tag">center</span>;</span><br></pre></td></tr></table></figure></li><li>通过 <code>display:table-cell</code>, 对子元素设置宽高会失效<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table-cell</span>;</span><br><span class="line"><span class="selector-tag">vertical-align</span>: <span class="selector-tag">middle</span>;</span><br><span class="line"><span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>;</span><br></pre></td></tr></table></figure></li><li>使用绝对定位和负边距,假设盒子本身宽高 <code>50px</code><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line"><span class="selector-tag">left</span><span class="selector-pseudo">:50</span>%;</span><br><span class="line"><span class="selector-tag">top</span><span class="selector-pseudo">:50</span>%;</span><br><span class="line"><span class="selector-tag">margin-left</span><span class="selector-pseudo">:-25px</span>;</span><br><span class="line"><span class="selector-tag">margin-top</span><span class="selector-pseudo">:-25px</span>;</span><br></pre></td></tr></table></figure></li><li>使用transform:translate定位<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line"><span class="selector-tag">top</span><span class="selector-pseudo">:50</span>%;</span><br><span class="line"><span class="selector-tag">left</span><span class="selector-pseudo">:50</span>%;</span><br><span class="line"><span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</span><br><span class="line"><span class="selector-tag">transform</span><span class="selector-pseudo">:translate(-50</span>%,<span class="selector-tag">-50</span>%);</span><br></pre></td></tr></table></figure></li><li>针对文本可采用<code>line-height</code>来实现垂直居中,<code>text-align:center</code> 实现水平居中</li></ol><h3 id="跨域-jsonp原理-cors原理"><a class="markdownIt-Anchor" href="#跨域-jsonp原理-cors原理"></a> 跨域、jsonp原理、CORS原理</h3><p>跨域是浏览器的安全政策下的一种同源策略,同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。要求访问资源时要 <code>协议相同</code>、<code>域名相同</code> 、 <code>端口相同</code>。</p><p><strong>解决不能跨域请求资源的办法</strong><br /><strong>JSONP:</strong> JSONP是利用浏览器对script的资源引用没有同源限制，通过动态插入一个script标签，当资源加载到页面后会立即执行的原理实现跨域的。JSONP是一种非正式传输协议，该协议的一个要点就是允许用户传递一个callback或者开始就定义一个回调方法，参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。JSONP只支持GET请求而不支持POST等其它类型的HTTP请求,它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题，JSONP的优势在于支持老式浏览器，弊端也比较明显：需要客户端和服务端定制进行开发，服务端返回的数据不能是标准的Json数据，而是callback包裹的数据。<br/><br /><strong>CORS</strong>:(IE10以下不支持)CORS是现代浏览器支持跨域资源请求的一种方式，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing），当使用XMLHttpRequest发送请求时，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：Origin，后台进行一系列处理，如果确定接受请求则在返回结果中加入一个响应头：Access-Control-Allow-Origin;浏览器判断该相应头中是否包含Origin的值，如果有则浏览器会处理响应，我们就可以拿到响应数据，如果不包含浏览器直接驳回，这时我们无法拿到响应数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, origin);</span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;POST, GET, OPTIONS, DELETE,PATCH&quot;</span>);</span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Max-Age&quot;</span>, <span class="string">&quot;3600&quot;</span>);</span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;x-requested-with&quot;</span>);</span><br><span class="line"><span class="comment">// 是否支持cookie跨域</span></span><br><span class="line">response.addHeader(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/weixin_34150830/article/details/91438855">CSDN答案</a></p></blockquote><h3 id="transform-transition-animation-区别"><a class="markdownIt-Anchor" href="#transform-transition-animation-区别"></a> <code>transform</code> 、<code>transition</code> 、 <code>animation</code> 区别</h3><blockquote><p><code>transform</code> 、<code>transition</code> 都是写在对应元素CSS样式里面的。<code>animation</code> 通过(<code>@keyframes</code>) 绑定对应的clss选择器,来控制元素样式。<br /><code>transform</code>有<code>rotate|skew|scale|translate</code>(旋转|扭曲|缩放|移动)等属性<br /><code>transition</code> ,只是一个过渡 只能设置 ,样式初始值和结束值,包括一些简单的控制样式过渡的属性<br /><code>animation</code> 不改变元素的属性。动画结束后还原。有很多动画api,基本可以控制每一帧动画。例如可以控制 动画间隔，以及动画次数,甚至可以控制反向播放</p></blockquote><h3 id="介绍一下promise以及内部的实现"><a class="markdownIt-Anchor" href="#介绍一下promise以及内部的实现"></a> 介绍一下Promise以及内部的实现。</h3><blockquote><p>Promise是为了解决Javascript回调嵌套过多而产生的。因为支持链式调用，而且书写更加方便，并纳入了ES2015规范中</p></blockquote><h4 id="promisea规范"><a class="markdownIt-Anchor" href="#promisea规范"></a> Promise/A+规范</h4><ul><li>pendding 表示初始状态,可以转移到 <code>fullfilled</code> 或者 <code>rejected</code> 状态。</li><li><code>fullfilled</code> 表示操作成功，状态不可转移。</li><li><code>rejected</code> 表示操作失败，状态不可转移。</li><li>必须有一个 <code>then</code> 异步执行方法，<code>then</code> 接收两个参数且必须返回一个 <code>promise</code>。</li></ul><p><img src="http://blogimage.lemonlife.top/202002161328_665.png?/" alt="MDN上Promise状态图" /></p><h4 id="自己实现思路"><a class="markdownIt-Anchor" href="#自己实现思路"></a> 自己实现思路</h4><p>从上面描述可知，要实现Promise需要有</p><ul><li>status 当前的状态(<code>pending|fullfilled|rejected</code>)</li><li>value <code>fullfilled</code>之后的返回值。</li><li>reason <code>rejected</code>之后的原因</li><li>fullfilledCallback <code>fillfulled</code>回调队列</li><li>rejectedCallback <code>rejected</code> 回调队列</li></ul><p><strong>简单版本</strong></p><blockquote><p>这个代码来源 github 面试写出这个已经够了，下面那个复杂版本，我自己写着玩的。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">&#x27;resolved&#x27;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">exec</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span></span><br><span class="line">  <span class="built_in">this</span>.state = PENDING</span><br><span class="line">  <span class="built_in">this</span>.value = <span class="literal">null</span></span><br><span class="line">  <span class="built_in">this</span>.resolvedCallBacks = []</span><br><span class="line">  <span class="built_in">this</span>.rejectedCallBacks = []</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="keyword">return</span> value.then(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (self.state === PENDING) &#123;</span><br><span class="line">        self.state = RESOLVED</span><br><span class="line">        self.value = value</span><br><span class="line">        self.resolvedCallBacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">          callback(value)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (self.state === PENDING) &#123;</span><br><span class="line">        self.state = REJECTED</span><br><span class="line">        self.value = reason</span><br><span class="line">        self.rejectedCallBacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">          callback(value)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    exec(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&#x27;function&#x27;</span> ? onResolved : <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> reason</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.state === PENDING) &#123;</span><br><span class="line">    <span class="built_in">this</span>.resolvedCallBacks.push(onResolved)</span><br><span class="line">    <span class="built_in">this</span>.rejectedCallBacks.push(onRejected)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.state === RESOLVED) &#123;</span><br><span class="line">    onResolved(<span class="built_in">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.state === REJECTED) &#123;</span><br><span class="line">    onRejected(<span class="built_in">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂版本</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> PENDING = <span class="string">&#x27;pendiing&#x27;</span></span><br><span class="line"> <span class="keyword">const</span> RESOLVED = <span class="string">&#x27;resolved&#x27;</span></span><br><span class="line"> <span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>excutor 同步执行器函数 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">excutor</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.status = PENDING</span><br><span class="line">   <span class="built_in">this</span>.data = <span class="literal">undefined</span></span><br><span class="line">   <span class="built_in">this</span>.callbacks = []</span><br><span class="line">   <span class="keyword">let</span> _self = <span class="built_in">this</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 状态 改成 resolve</span></span><br><span class="line">     <span class="comment">// 报错value 数据</span></span><br><span class="line">     <span class="comment">// 执行回调函数</span></span><br><span class="line">     <span class="keyword">if</span> (_self.status !== PENDING) &#123;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">     &#125;</span><br><span class="line">     _self.status = RESOLVED</span><br><span class="line">     _self.data = value</span><br><span class="line">     <span class="keyword">if</span> (_self.callbacks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         _self.callbacks.forEach(<span class="function"><span class="params">callbacksObj</span> =&gt;</span> &#123;</span><br><span class="line">           callbacksObj.onResolved(value)</span><br><span class="line">         &#125;)</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (_self.status !== PENDING) &#123;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">     &#125;</span><br><span class="line">     _self.status = REJECTED</span><br><span class="line">     _self.data = reason</span><br><span class="line">     <span class="keyword">if</span> (_self.callbacks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         _self.callbacks.forEach(<span class="function"><span class="params">callbacksObj</span> =&gt;</span> &#123;</span><br><span class="line">           callbacksObj.onRejected(value)</span><br><span class="line">         &#125;)</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果执行器 抛出异常 promise 变成 reject状态</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     excutor(resolve, reject)</span><br><span class="line">   &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">     reject(error)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Promise 实例对象 then</span></span><br><span class="line"><span class="comment">  *  <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>onResolved 成功状态对的回调函数</span></span><br><span class="line"><span class="comment">  *  <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>onRejected 失败状态的回调函数</span></span><br><span class="line"><span class="comment">  *  <span class="doctag">@return </span>一个新的promise对象 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> _self = <span class="built_in">this</span></span><br><span class="line">   <span class="comment">// 实现异常传递</span></span><br><span class="line">   onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;</span><br><span class="line">   onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&#x27;function&#x27;</span> ? onResolved : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回一个新的Promise对象</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param <span class="type">&#123;&#125;</span> </span>callback 调用指定的回调函数 </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">const</span> result = callback(_self.data)</span><br><span class="line">         <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">           result.then(resolve, reject)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           resolve(result)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">         reject(error)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (_self.status === PENDING) &#123;</span><br><span class="line">       _self.callbacks.push(&#123;</span><br><span class="line">         onResolved,</span><br><span class="line">         onRejected</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_self.status === RESOLVED) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         handle(onResolved)</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         handle(onRejected)</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* Promise 实例对象 catch</span></span><br><span class="line"><span class="comment">*  <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>onRejected 失败状态的回调函数</span></span><br><span class="line"><span class="comment">*  <span class="doctag">@return </span>一个新的promise对象 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="js实现异步有哪些方法"><a class="markdownIt-Anchor" href="#js实现异步有哪些方法"></a> JS实现异步有哪些方法</h3><blockquote><p>Javascript 的执行环境是单线程。就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。<br />**同步模式(Synchronous)：**程序的执行顺序与任务的排列顺序是一致的、同步的。<br />**异步模式(Asynchronous)：**每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p></blockquote><ul><li><p>回调函数的形式</p><p>把耗时的模块。放入定时器中。将其子模块,已回调函数的形式写入。<a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html">阮老师博客</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设f1是耗时的操作，f2需要f1的结果。 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// f1的任务代码</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">f1(f2);</span><br></pre></td></tr></table></figure></li><li><p>事件监听<br />任务的执行顺序不取决于代码的执行顺序。而是取决于某个事件是否发生。<br /><code>f1.trigger('done')</code>表示，执行完成后，立即触发done事件，从而开始执行f2。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      　f1.on(<span class="string">&#x27;done&#x27;</span>, f2);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    f1.trigger(<span class="string">&#x27;done&#x27;</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发布订阅模式(观察者模式)<br />假设存在信号中心。某个任务完成时，向信号中心发布这个信号。其他订阅者，接收到信号之后。开始执行自己的函数<br />这种方法的性质与&quot;事件监听&quot;类似，但是明显优于后者。因为我们可以通过查看&quot;消息中心&quot;，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jQuery.subscribe(<span class="string">&quot;done&quot;</span>, f2);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// f1任务代码</span></span><br><span class="line">    jQuery.publish(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">jQuery.unsubscribe(<span class="string">&quot;done&quot;</span>, f2);</span><br></pre></td></tr></table></figure><blockquote><p>手动实现观察者模式</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> observe = <span class="function"><span class="params">fn</span> =&gt;</span> queuedObservers.add(fn);</span><br><span class="line"><span class="keyword">const</span> observable = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;set&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Reflect对象的方法与Proxy对象的方法一一对应，</span></span><br><span class="line"><span class="comment">   * 只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。</span></span><br><span class="line"><span class="comment">   * 这就让Proxy对象可以方便地调用对应的Reflect方法，</span></span><br><span class="line"><span class="comment">   * 完成默认行为，作为修改行为的基础。</span></span><br><span class="line"><span class="comment">   * 也就是说，不管Proxy怎么修改默认行为，</span></span><br><span class="line"><span class="comment">   * 你总可以在Reflect上获取默认行为</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">console</span>.log(target,key,value,receiver) <span class="comment">//&#123; name: &#x27;张三&#x27;, age: 20 &#125; &#x27;name&#x27; &#x27;李四&#x27; &#123; name: &#x27;张三&#x27;, age: 20 &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  <span class="built_in">console</span>.log(target,key,value,receiver) <span class="comment">// &#123; name: &#x27;李四&#x27;, age: 20 &#125; &#x27;name&#x27; &#x27;李四&#x27; &#123; name: &#x27;李四&#x27;, age: 20 &#125;</span></span><br><span class="line">  queuedObservers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer());</span><br><span class="line">  <span class="comment">// return result;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = observable(&#123;</span><br><span class="line">  name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.name&#125;</span>, <span class="subst">$&#123;person.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`年龄是, <span class="subst">$&#123;person.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">observe(print);</span><br><span class="line">observe(print2)</span><br><span class="line">person.name = <span class="string">&#x27;李四&#x27;</span>; </span><br></pre></td></tr></table></figure></li><li><p>Promise 对象<br />它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成：<code>f1.().then(f2)</code><br />这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> resolve();</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 执行结果 1 2 5 3 4</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="symbol用法"><a class="markdownIt-Anchor" href="#symbol用法"></a> Symbol用法</h3><p>最新的ECMAScript 标准定义了8种数据类型,7种原始类型 <code>undefined</code> <code>null</code> <code>bollean</code> <code>number</code> <code>bigint</code> <code>string</code> <code>symbol</code> ,1种复杂数据类<code>object</code> 。<br/><br />如果面试官问，你可以反问一句，是基础数据类型，还是数据类型，基础数据类型7种，数据类型8种<br/></p><p><img src="http://blogimage.lemonlife.top/202002212036_7.png?/" alt="" /></p><p><strong>primitive的解释：</strong> In JavaScript, a primitive (primitive value, primitive data type) is data that is not an object and has no methods. There are 7 primitive data types: string, number, bigint, boolean, null, undefined, and symbol.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;info&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [s1]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;哈哈哈&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;test&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;TEST哈哈哈&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">a.test() <span class="comment">// TEST哈哈哈</span></span><br><span class="line">a[s1]() <span class="comment">// 哈哈哈</span></span><br><span class="line">a[<span class="built_in">Symbol</span>(<span class="string">&#x27;info&#x27;</span>)] <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="proxy"><a class="markdownIt-Anchor" href="#proxy"></a> Proxy</h3><blockquote><p>修改制定对象的一些默认方法。通过<code>new Proxy(params1,params2)</code> 创建Proxy对象。参数1是被代理的对象。参数2是被修改的默认方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;wang&quot;</span> &#125;, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, propKey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (propKey <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[propKey]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">// wang</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.time) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h3 id="fetchapi-和xhrajaxaxios的主要区别"><a class="markdownIt-Anchor" href="#fetchapi-和xhrajaxaxios的主要区别"></a> FetchApi 和XHR(ajax,axios)的主要区别</h3><blockquote><p>主要是请求方式的不同<br />XHR就是 <code>XMLHttpRequest</code> 的请求方式<br />FetchApi 类似 <code>function()&#123;&#125;.then().catch()</code>的模式，FetchAPI可以流式请求体的模式(下载大文件过程中显示数据流),更方便请求。</p></blockquote><h3 id="实现一个盒子高度是宽度的一半纯css"><a class="markdownIt-Anchor" href="#实现一个盒子高度是宽度的一半纯css"></a> 实现一个盒子高度是宽度的一半(纯CSS)</h3><p>padding属性, padding 的百分比是根据盒子的宽度来决定的。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  * &#123;</span><br><span class="line">    padding: 0;</span><br><span class="line">    margin: 0;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">    width: 1000px;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">  <span class="selector-class">.child</span> &#123;</span></span><br><span class="line">    height: 0;</span><br><span class="line">    padding-bottom: 50%;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    background: pink;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="不同浏览器标签页的通信"><a class="markdownIt-Anchor" href="#不同浏览器标签页的通信"></a> 不同浏览器标签页的通信</h3><h3 id="线程与进程的区别"><a class="markdownIt-Anchor" href="#线程与进程的区别"></a> 线程与进程的区别</h3><p><strong>进程具有的特征：</strong></p><ul><li>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态- 消亡的；</li><li>并发性：任何进程都可以同其他进行一起并发执行；</li><li>独立性：进程是系统进行资源分配和调度的一个独立单位；</li><li>结构性：进程由程序，数据和进程控制块三部分组成。<br /><strong>线程与进程的区别</strong></li><li>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；</li><li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li><li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；</li><li>调度和切换：线程上下文切换比进程上下文切换要快得多。</li></ul><h3 id="浏览器是如何工作的"><a class="markdownIt-Anchor" href="#浏览器是如何工作的"></a> 浏览器是如何工作的</h3><h3 id="回流和重绘的区别"><a class="markdownIt-Anchor" href="#回流和重绘的区别"></a> 回流和重绘的区别</h3><p>浏览器在加载HTML的时候,会形成DOM树 和render树，DOM树含有HTML标签，包括<code>dispaly:none</code>的标签还有JS代码动态添加的元素。浏览器把CSS样式解析成结构体。DOM 树和结构体结合之后生成render树。所以render树每个节点都有自己的样式。render-tree中的元素的规模，尺寸，布局等发生改变时需要重建render树。称为回流。每个页面至少需要页面加载时这一个回流。完成回流之后，浏览器需要重新在屏幕上绘制受影响的部分。该过程称为重绘。<br />如果render Tree中的部分元素更新只影响外观(如颜色)不会引起回流，只会发生重绘。<br/><br />**浏览器的优化：**显然回流的花销比重绘要高,回流的花销和 render tree 有多少节点有关。所以浏览器会维护一个队列。把所以会引起回流重绘的操作放入这个队列。当队列中的操作达到一定的数量。或者到了一定时间间隔。浏览器会进行一个批处理，把多次回流重绘变成一次回流重绘。<br />**代码的优化：**把多次改变样式代码，多次添加删除元素等操作合并成一次操作。</p><blockquote><p><a href="http://blog.poetries.top/FE-Interview-Questions/improve/#_7-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98">优质博客链接</a></p></blockquote><h3 id="express和koa的区别"><a class="markdownIt-Anchor" href="#express和koa的区别"></a> express和koa的区别</h3><p>在koa中,一切流程都是中间件。数据流向遵循洋葱模型。先入后出,也像递归模型。koa2中实现异步是通过async/awaite，koa1实现异步是通过generator/yield，而express实现异步是通过回调函数的方式。express内置了很多中间件。koa2基本没绑定其他框架。更容易定制化。扩展性好。express没有提供上下文机制。数据的控制需要自己手动实现。Koa依据洋葱模型实现数据的流入流出的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mid1 = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.body =  <span class="string">&#x27;前：&#x27;</span> + <span class="string">&#x27;1\n&#x27;</span></span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">    ctx.body =   ctx.body + <span class="string">&#x27;后：&#x27;</span> + <span class="string">&#x27;1\n&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mid2 = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.body =    ctx.body + <span class="string">&#x27;前：&#x27;</span>+ <span class="string">&#x27;2\n&#x27;</span></span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">    ctx.body =    ctx.body + <span class="string">&#x27;后：&#x27;</span>+ <span class="string">&#x27;2\n&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mid3 = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.body =  ctx.body + <span class="string">&#x27;前：&#x27;</span>+  <span class="string">&#x27;3\n&#x27;</span></span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">    ctx.body =   ctx.body + <span class="string">&#x27;后：&#x27;</span>+ <span class="string">&#x27;3\n&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(mid1)</span><br><span class="line">app.use(mid2)</span><br><span class="line">app.use(mid3)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>) </span><br><span class="line"><span class="comment">// 前1 前2 前3</span></span><br><span class="line"><span class="comment">// 后3 后2 后1</span></span><br></pre></td></tr></table></figure><h3 id="koa的洋葱模型koa中间件原理"><a class="markdownIt-Anchor" href="#koa的洋葱模型koa中间件原理"></a> koa的洋葱模型(koa中间件原理)</h3><p>初始化Koa实例后,用use方法来调用加载中间件。会有一个数组来存储中间件，use的调用顺序。决定了中间件的执行顺序。每一个中间件都是一个函数(如果不是会报错),接收两个参数,第一个ctx是上下文对象，另一个是next函数。项目启动后koa-componse模块对middleware中间件数组进行处理。会从middleware数组中取第一个函数开始执行,中间件函数调用next方法去执行下一个中间件函数(此时不代表当前中间件函数执行完毕了)，每个中间件函数执行完毕之后都会反回Promise对象。</p><p><img src="http://blogimage.lemonlife.top/202002132134_542.png?/" alt="洋葱模型图片" /></p><h3 id="mysql索引太多会有什么影响索引种类"><a class="markdownIt-Anchor" href="#mysql索引太多会有什么影响索引种类"></a> mysql索引太多会有什么影响,索引种类</h3><p>(1) 空间：索引需要占用空间；</p><p>(2) 时间：查询索引需要时间；</p><p>(3) 维护：索引须要维护（数据变更时）；</p><p>不建议使用索引的情况：</p><p>(1) 数据量很小的表</p><p>(2) 空间紧张有什么区别</p><h3 id="什么是seo"><a class="markdownIt-Anchor" href="#什么是seo"></a> 什么是SEO</h3><p>搜索引擎优化。是一种方式：利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。目的是：为网站提供生态式的自我营销解决方案，让其在行业内占据领先地位，获得品牌收益；SEO包含站外SEO和站内SEO两方面；为了从搜索引擎中获得更多的免费流量，从网站结构、内容建设方案、用户互动传播、页面等角度进行合理规划，还会使搜索引擎中显示的网站相关信息对用户来说更具有吸引力。<br /><strong>搜索引擎优化：</strong></p><ul><li><p>对网站的标题、关键字、描述精心设置，反映网站的定位，让搜索引擎明白网站是做什么的</p></li><li><p>网站内容优化：内容与关键字的对应，增加关键字的密度；</p></li><li><p>在网站上合理设置Robot.txt文件；<br /><strong>网页内部优化：</strong></p></li><li><p>META标签优化：例如：TITLE，KEYWORDS，DESCRIPTION等的优化；</p></li><li><p>title：只要强调重点即可，重要关键词出现不要超过2次，而且要靠前，每个页面的title要有所不同。</p></li><li><p>description：把网页内容高度概括到这里，长度要合理，不可过分堆砌关键词，每个页面的description要有所不同。</p></li><li><p>keywords：列举几个重要的关键词即可，不可过分堆砌。</p></li></ul><blockquote><p><a href="https://www.jianshu.com/p/77d32ca7cb9d">转载自简书</a></p></blockquote><h3 id="实现bfs算法广度优先遍历"><a class="markdownIt-Anchor" href="#实现bfs算法广度优先遍历"></a> 实现BFS算法(广度优先遍历)</h3><h3 id="实现观察者模式发布订阅模式"><a class="markdownIt-Anchor" href="#实现观察者模式发布订阅模式"></a> 实现观察者模式(发布订阅模式)</h3><h3 id="手动实现proxy"><a class="markdownIt-Anchor" href="#手动实现proxy"></a> 手动实现Proxy</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(obj) !== <span class="string">&#x27;[object Object]&#x27;</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">let</span> newObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    newObj[key] = clone(obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度克隆当前对象</span></span><br><span class="line"><span class="comment">//遍历当前对象所有属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyProxy</span>(<span class="params">target, handle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> targetCopy = clone(target);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.keys(target).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//Object.defineProperty 修改每一项的get set 方法 </span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(targetCopy, key, &#123;</span><br><span class="line">      get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handle.get &amp;&amp; handle.get(target, key);</span><br><span class="line">      &#125;,</span><br><span class="line">      set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">        handle.set &amp;&amp; handle.set(target, key, newVal);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> targetCopy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myProxy = <span class="keyword">new</span> MyProxy(&#123; <span class="attr">name</span>: <span class="string">&quot;wmw&quot;</span>, <span class="attr">son</span>: &#123; <span class="attr">sonName</span>: <span class="string">&quot;sonName&quot;</span> &#125; &#125;, &#123;</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;set方法被拦截&quot;</span>) &#125;,</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;get方法被拦截&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">myProxy.name = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">myProxy.year = <span class="string">&quot;2020&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/wmwgithub/typescript-design-mode/blob/master/src/proxy/proxy.js">源码</a></p></blockquote><h3 id="proxy-实现vue数据双向绑定"><a class="markdownIt-Anchor" href="#proxy-实现vue数据双向绑定"></a> Proxy 实现Vue数据双向绑定</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&#x27;wmw&#x27;</span>,</span></span><br><span class="line">    age: 21</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> template = <span class="string">`</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>  &gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    姓名：</span><span class="template-variable">&#123;&#123;<span class="name">name</span>&#125;&#125;</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    年龄：</span><span class="template-variable">&#123;&#123;<span class="name">age</span>&#125;&#125;</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>  <span class="attr">id</span>=<span class="string">&#x27;input1&#x27;</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">  `</span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">renderHTML</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> res = template.replace(<span class="regexp">/\&#123;\&#123;\w+\&#125;\&#125;/g</span>, <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span></span><br><span class="line">      key = key.slice(2, key.length - 2)</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> data[key]</span></span><br><span class="line">    &#125;)</span><br><span class="line">    el.innerHTML = res</span><br><span class="line">  &#125;</span><br><span class="line">  renderHTML()</span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">renderJS</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Array</span>.from(el.getElementsByTagName(<span class="string">&#x27;input&#x27;</span>))</span></span><br><span class="line"><span class="javascript">      .filter(<span class="function"><span class="params">ele</span> =&gt;</span> ele.getAttribute(<span class="string">&#x27;v-model&#x27;</span>))</span></span><br><span class="line"><span class="javascript">      .forEach(<span class="function"><span class="params">input</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> key = input.getAttribute(<span class="string">&#x27;v-model&#x27;</span>)</span></span><br><span class="line">        input.value = data[key]</span><br><span class="line"><span class="javascript">        input.onfocus = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">        input.oninput = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          dataProxy[key] = <span class="built_in">this</span>.value</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  renderJS()</span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> dataProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">set</span>(<span class="params">obj, name, value</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// diff算法</span></span></span><br><span class="line">      obj[name] = value</span><br><span class="line">      renderHTML()</span><br><span class="line">      renderJS()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;) </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/wmwgithub/typescript-design-mode/blob/master/src/proxy/vue/index.html">源码</a></p></blockquote><h3 id="单例模式工厂模式"><a class="markdownIt-Anchor" href="#单例模式工厂模式"></a> 单例模式/工厂模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        instance = <span class="built_in">this</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p1 == p2)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Factory = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = &#123;</span><br><span class="line">    <span class="function"><span class="title">Student</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name</span><br><span class="line">      <span class="built_in">this</span>.age = age</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">Teacher</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name</span><br><span class="line">      <span class="built_in">this</span>.age = age</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type, name, age</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[type]) &#123;</span><br><span class="line">        <span class="keyword">return</span> s[type].call(<span class="built_in">this</span>, name, age)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu = <span class="keyword">new</span> Factory(<span class="string">&quot;Student&quot;</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(stu.name, stu.age) <span class="comment">// 张三 18</span></span><br></pre></td></tr></table></figure><h3 id="js函数柯里化"><a class="markdownIt-Anchor" href="#js函数柯里化"></a> JS函数柯里化</h3><blockquote><p>Curry 把接受多个参数的函数，变成了接受一个单一参数(最初参数的第一个),并返回能正确运行的函数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingAdd</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">curryingAdd(<span class="number">1</span>)(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>让参数能够复用，调用起来也更方便。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">reg,text</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> reg.text(text)</span><br><span class="line">&#125;</span><br><span class="line">check(<span class="regexp">/\d+/g</span>,<span class="string">&#x27;test&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">check(<span class="regexp">/[a-z]+/g</span>,<span class="string">&#x27;test&#x27;</span>) <span class="comment">//true</span></span><br><span class="line"><span class="comment">// Currying 后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingCheck</span>(<span class="params">reg</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">txt</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hasNumber = curryingCheck(<span class="regexp">/\d+/g</span>)</span><br><span class="line"><span class="keyword">var</span> hasLetter = curryingCheck(<span class="regexp">/[a-z]+/g</span>)</span><br><span class="line"></span><br><span class="line">hasNumber(<span class="string">&#x27;test1&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">hasNumber(<span class="string">&#x27;testtest&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">hasLetter(<span class="string">&#x27;21212&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>通用的柯理化函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn    待柯里化的原函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>len   所需的参数个数，默认为原函数的形参个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn,len = fn.length</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _curry.call(<span class="built_in">this</span>,fn,len)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn    待柯里化的原函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>len   所需的参数个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>args  已接收的参数列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_curry</span>(<span class="params">fn,len,...args1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> _args = [...args1,...args2];</span><br><span class="line">      <span class="keyword">if</span>(_args.length &gt;= len)&#123;</span><br><span class="line">          <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>,_args);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">// 继续收集参数的过程</span></span><br><span class="line">          <span class="keyword">return</span> _curry.call(<span class="built_in">this</span>,fn,len,..._args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现一个sum函数使得sum123valueof和sum123valueof执行输出的结果都等于6"><a class="markdownIt-Anchor" href="#实现一个sum函数使得sum123valueof和sum123valueof执行输出的结果都等于6"></a> 实现一个sum函数使得<code>sum(1,2,3).valueOf()</code>和<code>sum(1)(2)(3).valueOf()</code>执行输出的结果都等于6</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">b = args[<span class="number">0</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">c = args[<span class="number">1</span>]</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b + c</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>).valueOf()) <span class="comment">//6 </span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).valueOf()()()) <span class="comment">//6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum2</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args[<span class="number">0</span>] + b + c</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum2(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>).valueOf()) <span class="comment">//6</span></span><br><span class="line"><span class="built_in">console</span>.log(sum2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).valueOf()) <span class="comment">// 6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="手动实现对象深拷贝的方法"><a class="markdownIt-Anchor" href="#手动实现对象深拷贝的方法"></a> 手动实现对象深拷贝的方法</h3><blockquote><p>面试我只想用ES5 的写法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(source)) &#123;</span><br><span class="line">    <span class="comment">// Reflect.getOwnPropertyDescriptor(source,key)</span></span><br><span class="line">    <span class="comment">//  获取对象的属性描述符  对象是否可写 等</span></span><br><span class="line">    <span class="built_in">Reflect</span>.defineProperty(obj, key, <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(source, key))</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Reflect</span>.apply(<span class="built_in">Object</span>.prototype.toString, source[key], []) === <span class="string">&#x27;[object Object]&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">Reflect</span>.set(obj, key, merge(source[key]))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(obj) !== <span class="string">&#x27;[object Object]&#x27;</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">let</span> newObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    newObj[key] = clone(obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="防抖节流"><a class="markdownIt-Anchor" href="#防抖节流"></a> 防抖节流</h3><ul><li>防抖</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timeout !== <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        &#125; </span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(fn, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 滚动事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, debounce(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure><ul><li>节流</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">var</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> curTime = <span class="built_in">Date</span>.now();</span><br><span class="line">     <span class="keyword">var</span> remaining = delay - (curTime - startTime);</span><br><span class="line">     <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">     <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">     <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        startTime = <span class="built_in">Date</span>.now();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 定时器解决，节流函数，最后一次需要被执行的问题</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(func, remaining);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, throttle(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><blockquote><p>面试需要 数据结构与算法，网络原理，底层知识，项目经验，设计模式，SQL语法</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并两个排序的链表</title>
      <link href="2020/02/06/mergeListNode/"/>
      <url>2020/02/06/mergeListNode/</url>
      
        <content type="html"><![CDATA[<h2 id="合并两个排序的链表"><a class="markdownIt-Anchor" href="#合并两个排序的链表"></a> 合并两个排序的链表</h2><blockquote><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><h2 id="我的思路"><a class="markdownIt-Anchor" href="#我的思路"></a> 我的思路</h2><blockquote><p>因为两个链表都是有序的，因此只要以一个链表为基准,把另一个链表的值依次插入即可</p></blockquote><h2 id="我的解决办法"><a class="markdownIt-Anchor" href="#我的解决办法"></a> 我的解决办法</h2><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode pList1;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="comment">//已经到List1最后一个 说明List2后面都比List1要大</span></span><br><span class="line">         <span class="keyword">if</span>(pList1.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            pList1.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">            <span class="keyword">return</span> pList1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后一项比前一项大的情况</span></span><br><span class="line">        <span class="keyword">if</span>(pList1.next.val&gt;=val)&#123;</span><br><span class="line">            ListNode newListNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">            newListNode.next = pList1.next;</span><br><span class="line">            pList1.next = newListNode;</span><br><span class="line">            <span class="keyword">return</span> newListNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不满足上面两种的情况 继续迭代</span></span><br><span class="line">        pList1 = pList1.next;</span><br><span class="line">        <span class="keyword">return</span> addNode(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 链表1的指针</span></span><br><span class="line">        pList1 = list1;</span><br><span class="line">        <span class="keyword">while</span>(list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            addNode(list2.val);</span><br><span class="line">            list2 = list2.next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>JavaScript</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Merge</span>(<span class="params">pHead1, pHead2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="comment">//排除 第一项pHead1大于pHead2的情况</span></span><br><span class="line">    <span class="keyword">if</span>(pHead1!=<span class="literal">null</span>&amp;&amp; pHead2!=<span class="literal">null</span> &amp;&amp; pHead1.val &gt;= pHead2.val)&#123;</span><br><span class="line">        <span class="keyword">let</span> newListNode = <span class="keyword">new</span> ListNode(pHead2.val)</span><br><span class="line">        newListNode.next = pHead1</span><br><span class="line">        pHead1 = newListNode</span><br><span class="line">        pHead2 = pHead2.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 提取链表指针</span></span><br><span class="line">    <span class="keyword">let</span> head1 = pHead1</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//情况1 pHead1 已经到了最后</span></span><br><span class="line">        <span class="keyword">if</span>(head1.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            head1.next = <span class="keyword">new</span> ListNode(val)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况2 从小到大迭代 pHead1，发现 后一个值比pHead2的当前值大</span></span><br><span class="line">        <span class="comment">// 插入当前值</span></span><br><span class="line">        <span class="keyword">if</span>(head1.next.val&gt;=val)&#123;</span><br><span class="line">            <span class="keyword">let</span> newListNode = <span class="keyword">new</span> ListNode(val)</span><br><span class="line">             <span class="comment">//插入到 比他大的节点前</span></span><br><span class="line">             newListNode.next = head1.next</span><br><span class="line">             head1.next = newListNode</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不满足以上两种情况 迭代pHead1链表</span></span><br><span class="line">        head1 = head1.next</span><br><span class="line">        <span class="keyword">return</span> add(val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代pHead2</span></span><br><span class="line">    <span class="keyword">while</span>(pHead2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        add(pHead2.val)</span><br><span class="line">        pHead2=pHead2.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pHead1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契数列与跳台阶</title>
      <link href="2020/02/04/Fibonacci/"/>
      <url>2020/02/04/Fibonacci/</url>
      
        <content type="html"><![CDATA[<h2 id="斐波那契数列与跳台阶"><a class="markdownIt-Anchor" href="#斐波那契数列与跳台阶"></a> 斐波那契数列与跳台阶</h2><blockquote><p><strong>问题一:</strong> 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）<br/><br /><strong>问题二:</strong> 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><h2 id="分析问题"><a class="markdownIt-Anchor" href="#分析问题"></a> 分析问题</h2><blockquote><p>根据斐波那契数列后一项是前两项之和的特点。采用递归可以解决这个问题。通常递归可以转换成动态规划解决问题。因此下面我采用的是动态规划</p></blockquote><blockquote><p>对应跳台阶问题,青蛙每次可以跳任意的台阶,因此后一个台阶的走法,是前面所有台阶走法之和再加1。因此是前一个台阶走法的两倍。(高中数列问题<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup><mo>+</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^0+2^1+2^2+\cdots+2^{n-1}=2^n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>)</p></blockquote><h2 id="解决问题"><a class="markdownIt-Anchor" href="#解决问题"></a> 解决问题</h2><ul><li>斐波那契数列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arrayList.add(<span class="number">0</span>);</span><br><span class="line">    arrayList.add(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//处理第 0项和第1项情况；</span></span><br><span class="line">        <span class="keyword">return</span> arrayList.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        arrayList.add(i,arrayList.get(i-<span class="number">1</span>)+arrayList.get(i-<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrayList.get(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>跳台阶</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;(target-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重建二叉树</title>
      <link href="2020/02/04/reConstructBinaryTree/"/>
      <url>2020/02/04/reConstructBinaryTree/</url>
      
        <content type="html"><![CDATA[<h2 id="重建二叉树"><a class="markdownIt-Anchor" href="#重建二叉树"></a> 重建二叉树</h2><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p></blockquote><h2 id="分析问题"><a class="markdownIt-Anchor" href="#分析问题"></a> 分析问题</h2><blockquote><p>根据前序遍历先遍历根节点的特点,可知前序遍历的序列中前一部分可能是根节点。根据中序遍历先遍历左节点再遍历根节点的特点。在中序遍历的结果中左节点在根节点的左边。因此中序遍历中和前序遍历相等的点为根节点,节点左边可构成左子树。</p></blockquote><h2 id="解决问题"><a class="markdownIt-Anchor" href="#解决问题"></a> 解决问题</h2><blockquote><p>从上分析知,1为根节点1的左子树由 <code>4,7,2</code> 构成;2为根节点2的左子树由 <code>4,7</code> 构成;依次类推,易知可采用递归解决问题。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(pre.length == <span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> rootValue = pre[<span class="number">0</span>];</span><br><span class="line">           TreeNode tree = <span class="keyword">new</span> TreeNode(rootValue);</span><br><span class="line">           <span class="keyword">if</span>(pre.length ==<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> tree;</span><br><span class="line">           &#125;</span><br><span class="line">          <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;in.length;i++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(rootValue == in[i])&#123;</span><br><span class="line">                  rootIndex = i;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        tree.left = reConstructBinaryTree(Arrays.copyOfRange(pre,<span class="number">1</span>,rootIndex+<span class="number">1</span>),Arrays.copyOfRange(in,<span class="number">0</span>,rootIndex));</span><br><span class="line">        tree.right = reConstructBinaryTree(Arrays.copyOfRange(pre,rootIndex+<span class="number">1</span>,in.length),Arrays.copyOfRange(in,rootIndex+<span class="number">1</span>,in.length));</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="2020/02/02/tree/"/>
      <url>2020/02/02/tree/</url>
      
        <content type="html"><![CDATA[<h2 id="树tree"><a class="markdownIt-Anchor" href="#树tree"></a> 树(Tree)</h2><h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3><ul><li><p>介绍</p><blockquote><p>树(Tree)是基础数据结构的一种, 树中的每一个元素称作节点,节点与节点之间有兄弟节点,父子节点这两种。兄弟节点之间不直接相连。我们把没有子节点的节点叫做叶子节点。</p></blockquote></li><li><p>节点的高度</p><blockquote><p>节点到叶子节点最长的路径(边数)</p></blockquote></li><li><p>节点的深度</p><blockquote><p>节点到根节点所经历的边的个数</p></blockquote></li><li><p>节点的层数</p><blockquote><p><code>节点的深度+1</code> 因为根节点的层数是1。</p></blockquote></li><li><p>树的高度</p><blockquote><p>根节点的高度,或者其他节点的节点高度和节点深度之和。</p></blockquote><p><img src="http://blogimage.lemonlife.top/202002021232_96.png?/" alt="来源：极客时间-数据结构之美专题" /></p></li></ul><h3 id="二叉树binary-tree"><a class="markdownIt-Anchor" href="#二叉树binary-tree"></a> 二叉树(Binary Tree)</h3><ul><li><p>介绍</p><blockquote><p>树的每个节点最多含有两个子节点。分别是左节点和右节点，并不要求每个节点都含有左右节点，有的节点只有左节点，有的节点只有右节</p></blockquote><p><img src="http://blogimage.lemonlife.top/202002021248_678.png?/" alt="来源：极客时间-数据结构算法之美" /></p></li><li><p>满二叉树</p><blockquote><p>叶子节点都在树的最底层;且除了叶子节点外,其他节点都有左右两个子节点。</p></blockquote><p><img src="http://blogimage.lemonlife.top/202002021249_40.png?/" alt="来源：极客时间-数据结构算法之美" /></p></li><li><p>完全二叉树</p><blockquote><p>叶子节点在最后两层，最后一层的叶子节点都靠左并且除了最后一层其他层构成满二叉树。<br /><img src="http://blogimage.lemonlife.top/202002021252_81.png?/" alt="来源：极客时间-数据结构算法之美" /></p></blockquote></li></ul><h4 id="二叉树的储存"><a class="markdownIt-Anchor" href="#二叉树的储存"></a> 二叉树的储存</h4><pre><code>树作为一种基础的数据结构,存储方式有直观的 链式储存 和用 数组存储 两种。1. 链式存储法,每个节点有三个字段,其中一个储存数据,另外两个分别指向左右两个节点。2. 数组的顺序存储法,是把跟节点存在下标 i=1 的位置(i=0暂时为空)。把i节点左节点存在2*i的位置,右节点存在2*i+1的位置。这一存储方式比较适合满二叉树和完全二叉树。用于其他类型的容易造成空间的浪费。</code></pre><p><img src="http://blogimage.lemonlife.top/202002031112_287.png?/" alt="链式存储法" /><br /><img src="http://blogimage.lemonlife.top/202002031118_599.png?/" alt="数组的顺序存储法" /></p><h4 id="二叉树遍历"><a class="markdownIt-Anchor" href="#二叉树遍历"></a> 二叉树遍历</h4><ul><li><p>前序遍历</p><blockquote><p>对于某个节点先遍历这个节点,再遍历左节点，最后遍历右节点。</p></blockquote></li><li><p>中序遍历</p><blockquote><p>先遍历左节点再遍历这个节点本身，最后遍历有节点</p></blockquote></li><li><p>后序遍历</p><blockquote><p>先遍历左节点再遍历右节点,最后遍历这个节点本身。</p></blockquote><p><img src="http://blogimage.lemonlife.top/202002021348_774.png?/" alt="来源：极客时间-数据结构算法之美" /></p></li></ul><p><strong>递归模式遍历</strong></p><p>前序遍历的递推公式：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node* root)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">   print root <span class="comment">// 此处为伪代码，表示打印 root 节点 </span></span><br><span class="line">   preOrder(root-&gt;left); </span><br><span class="line">   preOrder(root-&gt;right);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历的递推公式：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* root)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>; </span><br><span class="line">  inOrder(root-&gt;left);</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印 root 节点 </span></span><br><span class="line">  inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历的递推公式：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node* root)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>; </span><br><span class="line">  postOrder(root-&gt;left); </span><br><span class="line">  postOrder(root-&gt;right); </span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印 root 节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代模式遍历</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  &#96;&#96;&#96;</span><br><span class="line">### 二叉查找树(Binary Search Tree)</span><br><span class="line">  &gt;二叉查找树要求,在树的任意一个节点,在其左节点的值都要小于该节点的值,在其右节点的值都要大于该节点的值,因此二叉查找树实现快速查找,并且还支持数据的快速插入或删除。</span><br><span class="line">  - 查找过程</span><br><span class="line">     </span><br><span class="line">    先和根节点比较,如果要查找的值小于根节点则在左子树中查找,否则在右子树中查找依此类推。</span><br><span class="line">    &#96;&#96;&#96;Java</span><br><span class="line">    public class SearchTree &#123;</span><br><span class="line">      public static class Node&#123;</span><br><span class="line">          private int data;</span><br><span class="line">          private Node left;</span><br><span class="line">          private Node right;</span><br><span class="line">          public Node(int data)&#123;</span><br><span class="line">              this.data &#x3D; data;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      private Node tree;</span><br><span class="line">      public Node find(int data)&#123;</span><br><span class="line">          Node t &#x3D; tree;</span><br><span class="line">          while (t!&#x3D;null)&#123;</span><br><span class="line">              if(data&lt;t.data)&#123;</span><br><span class="line">                  t&#x3D;t.left;</span><br><span class="line">              &#125; else if(data&gt;t.data) &#123;</span><br><span class="line">                  t&#x3D;t.right;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                return t;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><pre><code>![二叉查找树查找过程](http://blogimage.lemonlife.top/202002021921_337.png?/)</code></pre><ul><li><p>插入过程</p><blockquote><p>二叉查找树新插入的数据一般在叶子节点上,从根节点开始,如果要插入的数比节点数据小并且节点左子树为空，则将新插入的数据放到该节点左子节点的位置。如果左子树不为空依次递归遍历左子树。同样如果要插入的数据大于节点数据。对节点的右子树同样操作即可。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data,Node tree)</span></span>&#123;</span><br><span class="line">Node indexNode = tree;</span><br><span class="line"><span class="keyword">while</span>(indexNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(data &gt;= indexNode.data)&#123;</span><br><span class="line">        <span class="keyword">if</span>(indexNode.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            indexNode.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        indexNode = indexNode.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data&lt;indexNode.data) &#123;</span><br><span class="line">        <span class="keyword">if</span>(indexNode.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            indexNode.left == <span class="keyword">new</span> Node(data);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        indexNode = indexNode.left;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://blogimage.lemonlife.top/202002021953_674.png?/" alt="插入" /></p></li><li><p>删除过程</p></li></ul><blockquote><p>二叉查找树删除过程相对于查找和插入来说比较麻烦。有三种情况<br /><img src="http://blogimage.lemonlife.top/202002022219_211.png?/" alt="" /><br />1. 如果要删除节点没有子节点我们只需要直接将父节点中指向该节点的指针指向<code>null</code>即可。比如删除图中节点55。<br/><br />2. 如果要删除的节点有一个节点(一个左节点或者一个右节点)，只需要将父节点的指针指向要删除节点的子节点即可。比如删除图中节点13<br/><br />3. 如果要删除的节点含有两个子节点。我们找到该节点的右子树中最小的节点。把他替换到要删除的节点上。比如删除图中节点18</p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///这部分感觉教程上代码有问题 先欠着以后补上。</span></span><br></pre></td></tr></table></figure><h4 id="二叉查找树时间复杂度分析"><a class="markdownIt-Anchor" href="#二叉查找树时间复杂度分析"></a> 二叉查找树时间复杂度分析</h4><blockquote><p>二叉查找树执行查找的效率和数的高度成正比O(height),因此树的形状(树的左右平衡程度有关)会影响查询时间。<br/><br />1. 最坏的程度一棵树可以退化成链表查,一个含有n个节点的树,树的高度就是n。找时间复杂度为 <code>O(n)</code> <br/><br />2. 当二叉树的平衡情况最好时(满二叉树或者平衡二叉树)。一个含有n个节点的树高度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span><br/><br />n=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup><mo>+</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mn>2</mn><mrow><mi>L</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mn>2</mn><mi>L</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^0+2^1+2^2+\cdots+2^{L-1}=2^L-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.924661em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> (L代表树的高度)</br><br />查找的时间复杂度为O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span>)</p></blockquote><p><img src="http://blogimage.lemonlife.top/202002031131_882.png?/" alt="二叉查找树的情况" /></p><blockquote><p>文章中图片和部分文字代码片段来源 <code>极客时间-数据结构与算法之美</code></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程的基础</title>
      <link href="2020/02/01/java-concurrent-programming/"/>
      <url>2020/02/01/java-concurrent-programming/</url>
      
        <content type="html"><![CDATA[<h2 id="线程有关的基本概念"><a class="markdownIt-Anchor" href="#线程有关的基本概念"></a> 线程有关的基本概念</h2><h3 id="线程安全"><a class="markdownIt-Anchor" href="#线程安全"></a> 线程安全</h3><h2 id="java内存模型及线程实现案例分析"><a class="markdownIt-Anchor" href="#java内存模型及线程实现案例分析"></a> Java内存模型及线程实现案例分析</h2><h2 id="线程池原理及应用"><a class="markdownIt-Anchor" href="#线程池原理及应用"></a> 线程池原理及应用</h2><h2 id="java锁及应用"><a class="markdownIt-Anchor" href="#java锁及应用"></a> Java锁及应用</h2><h2 id="并发容器及原理分析"><a class="markdownIt-Anchor" href="#并发容器及原理分析"></a> 并发容器及原理分析</h2><h2 id="课程总结"><a class="markdownIt-Anchor" href="#课程总结"></a> 课程总结</h2><blockquote><p>网络视频课程来源<a href="https://edu.csdn.net/course/play/26270">CSDN</a>,感谢作者的分享。💪💪💪</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 网络视频课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从尾到头打印链表</title>
      <link href="2020/02/01/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>2020/02/01/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="从尾到头打印链表"><a class="markdownIt-Anchor" href="#从尾到头打印链表"></a> 从尾到头打印链表</h2><blockquote><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 链表节点</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="分析题目"><a class="markdownIt-Anchor" href="#分析题目"></a> 分析题目</h2><p><img src="http://blogimage.lemonlife.top/202002010106_129.png?/" alt="链表结构示意图" /></p><blockquote><p>链表一种基础的数据结构,从尾到头就是反向遍历链表,通过链表头依次可访问到后继节点，即可得到链表的顺序结构的值。把结果依次存入栈中，再弹出即可得到反向链表值。</p></blockquote><h2 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决办法</h2><ul><li>Java 代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(listNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arrayList;</span><br><span class="line">       &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (listNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(listNode.val);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">           arrayList.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>JavaScript 代码</li></ul><blockquote><p>JS下面代码<code>array2</code>的作用，也可以采用 <code>unshift</code> 方法代替。多用一个数组变量，空间复杂度高一点。但是比采用<code>unshift</code>函数时间复杂度略低。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printListFromTailToHead</span>(<span class="params">head</span>)</span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">let</span> list = head</span><br><span class="line">    <span class="keyword">if</span>(list == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> array1 = []</span><br><span class="line">    <span class="keyword">let</span> array2 = []</span><br><span class="line">    <span class="keyword">while</span>(list.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        array1.push(list.val)</span><br><span class="line">        list = list.next</span><br><span class="line">    &#125;</span><br><span class="line">    array1.push(list.val)</span><br><span class="line">    <span class="keyword">while</span>(array1.length != <span class="number">0</span>)&#123;</span><br><span class="line">        array2.push(array1.pop())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>替换空格</title>
      <link href="2020/01/31/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>2020/01/31/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="替换空格"><a class="markdownIt-Anchor" href="#替换空格"></a> 替换空格</h2><blockquote><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><h2 id="分析题目"><a class="markdownIt-Anchor" href="#分析题目"></a> 分析题目</h2><blockquote><p>在平时写代码中经常遇到字符串替换问题，因此我直接调用了,语言本身的系统函数解决问题。</p></blockquote><h2 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h2><ul><li>Java 版本</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.toString().replaceAll(<span class="string">&quot;\\s&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>JavaScript版本</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceSpace</span>(<span class="params">str</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/\s/g</span>,<span class="string">&quot;%20&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用JS代码时有些测试用例，因为数据量太大，时间超过了2秒过不去。Java一直在20ms左右。在数据量一般的情况下<code>JS V8</code>引擎的速度优于Java只需要12ms左右。</p></blockquote><p><img src="http://blogimage.lemonlife.top/202001311330_4.png?/" alt="情况对比" /></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维数组中的查找</title>
      <link href="2020/01/30/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>2020/01/30/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="二维数组中的查找"><a class="markdownIt-Anchor" href="#二维数组中的查找"></a> 二维数组中的查找</h2><blockquote><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><h2 id="分析题目"><a class="markdownIt-Anchor" href="#分析题目"></a> 分析题目</h2><blockquote><p>题目属于二维数组,采用两层for循环遍历每一个元素可以判断出是否含有该整数，时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)</p></blockquote><blockquote><p>根据题目的特点数据每行每列递增;因此可以采用二分法，先确定数据在哪一行，然后再采用二分法确定数据在哪一列，从而确定具体有没有这个数。时间复杂度<code>O(n+nlog(n))</code></p></blockquote><h2 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决办法</h2><ol><li>暴力法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> width = array[<span class="number">0</span>].length; <span class="comment">//数组宽度 （列数）</span></span><br><span class="line">    <span class="keyword">int</span> height = array.length;  <span class="comment">// 数组高度 （行数）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;width;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == array[i][j])&#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>二分法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> width = array[<span class="number">0</span>].length; <span class="comment">//数组宽度 （列数）</span></span><br><span class="line">        <span class="keyword">if</span>(width == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 空二维数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ints[<span class="number">0</span>] &lt;= target &amp;&amp; ints[width - <span class="number">1</span>] &gt;= target) &#123;</span><br><span class="line">                <span class="comment">//数据在第i行</span></span><br><span class="line">                <span class="comment">/// 2.再确定再哪一列(在这一行内二分查找)</span></span><br><span class="line">                <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> maxIndex = width-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (maxIndex - minIndex &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> middle = (<span class="keyword">int</span>) Math.floor((minIndex + maxIndex) / <span class="number">2.0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (target &gt; ints[middle]) &#123;</span><br><span class="line">                        minIndex = middle;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        maxIndex = middle;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (target == ints[middle] || target == ints[minIndex]||target==ints[maxIndex]) &#123;</span><br><span class="line">                        result = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter从入门到入门</title>
      <link href="2019/10/09/flutter/"/>
      <url>2019/10/09/flutter/</url>
      
        <content type="html"><![CDATA[<h2 id="flutter-历史介绍"><a class="markdownIt-Anchor" href="#flutter-历史介绍"></a> Flutter 历史介绍</h2><blockquote><p>起源于有人找我让我帮他写安卓项目，但是原生安卓我不会，本来想用RN，后来了解到RN配置比较麻烦，每次调试对电脑要求也比较高。所以我继续探索有没有其他开发Android的框架，后来遇到了Fluter，对于Flutter多优秀和Flutter和RN的对比，大家可上网去搜阿里闲鱼，美团等这些大厂的对比结果。</p></blockquote><p>Flutter 开发环境配置，在有科学上网的前提下相对比较简单，没有科学上网基本配置不了的。</p><p>Flutter框架采用Dart语言为开发语言，Dart入门不难,JavaScript(接触了解过ES6或者TS)熟练的人基本入门很快</p><h2 id="helloworld走起"><a class="markdownIt-Anchor" href="#helloworld走起"></a> HelloWorld走起</h2><ul><li><p>Dart</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;hello World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Fluter 项目初始化</p><ol><li>安装好Flutter 运行命令<code>flutter create helloworld</code></li><li>IDE会自动给你安装依赖，如果没有进入项目根目录 运行<code>flutter pub get</code> 就行</li><li>依赖安装完之后终端继续运行 <code>flutter run</code></li></ol></li><li><p>Flutter 目录结构说明</p><p><img src="http://blogimage.lemonlife.top/201910180132_872.png?/" alt="" /></p><ol><li><p>打包时候要用的包，包括修改应用名、图标、加密打包、之类的<code>android</code> <code>ios</code></p></li><li><p>代码主文件<code>lib</code> 目录初始只有一个<code>main</code>文件</p></li><li><p><code>test</code> 测试文件夹 ，这个删了都可以的不影响项目</p></li><li><p>依赖文件<code>pubspec.yaml</code> ，里面写了项目需要哪些依赖 和引用了哪些静态资源（字体，图片等）</p></li></ol></li><li><p>Flutter <code>main</code> 文件分析</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This widget is the root of your application.</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: MyHomePage(title: <span class="string">&#x27;Flutter Demo Home Page&#x27;</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  MyHomePage(&#123;Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _incrementCounter() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(</span><br><span class="line">              <span class="string">&#x27;You have pushed the button this many times:&#x27;</span>,</span><br><span class="line">            ),</span><br><span class="line">            Text(</span><br><span class="line">              <span class="string">&#x27;<span class="subst">$_counter</span>&#x27;</span>,</span><br><span class="line">              style: Theme.of(context).textTheme.display1,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: <span class="string">&#x27;Increment&#x27;</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ), </span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目中使用路由"><a class="markdownIt-Anchor" href="#项目中使用路由"></a> 项目中使用路由</h2><ul><li>静态路由</li><li>动态路由</li><li>路由传参</li></ul><h2 id="页面状态管理"><a class="markdownIt-Anchor" href="#页面状态管理"></a> 页面状态管理</h2><h4 id="前端基础概念"><a class="markdownIt-Anchor" href="#前端基础概念"></a> 前端基础概念</h4><ol><li>页面</li><li>组件</li><li>上下文</li><li>数据与状态</li></ol><h3 id="不使用依赖的原生管理方案"><a class="markdownIt-Anchor" href="#不使用依赖的原生管理方案"></a> 不使用依赖的原生管理方案</h3><h3 id="使用evenbus"><a class="markdownIt-Anchor" href="#使用evenbus"></a> 使用EvenBus</h3><h3 id="使用provider"><a class="markdownIt-Anchor" href="#使用provider"></a> 使用Provider</h3><h3 id="其他框框"><a class="markdownIt-Anchor" href="#其他框框"></a> 其他框框</h3><h2 id="详解provider-页面状态管理方案"><a class="markdownIt-Anchor" href="#详解provider-页面状态管理方案"></a> 详解Provider 页面状态管理方案</h2><blockquote><p>未完待续。。。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(零)</title>
      <link href="2019/09/16/javascript-design-mode/"/>
      <url>2019/09/16/javascript-design-mode/</url>
      
        <content type="html"><![CDATA[<h3 id="call-apply-bind-简单运用"><a class="markdownIt-Anchor" href="#call-apply-bind-简单运用"></a> call apply bind 简单运用</h3><ol><li>上手一个小例子</li></ol>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a:<span class="number">1</span>,</span><br><span class="line">  getA:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> == obj)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getA() <span class="comment">// true 1</span></span><br><span class="line"><span class="keyword">let</span> funGetA = obj.getA</span><br><span class="line">funGetA() <span class="comment">// false undefined</span></span><br><span class="line">funGetA.apply(obj) <span class="comment">// true 1</span></span><br><span class="line">funGetA.call(obj)<span class="comment">// true 1</span></span><br><span class="line">funGetA.bind(obj)() <span class="comment">// true 1</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* obj.getA()执行时候函数上下文 是对象obj 的环境 所以 this 指向 obj </span></span><br><span class="line"><span class="comment">* funGetA 执行时 上下文 已经变成了 window 此时 this指向window </span></span><br><span class="line"><span class="comment">* apply 和 call 把obj作为参数传入函数 把函数中this的指向改变成obj</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="2"><li>call 和apply区别</li></ol><blockquote><p>显然call和apply 的第一个参数作用都是制定了参数体内this的指向，不同的是 apply 只接受两个参数。apply第二个参数是一个集合(<code>数组</code> <code>类数组</code> )，call 从第二个参数开始后面的每一个参数都是依次传入函数</p></blockquote>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a,b,c)</span><br><span class="line">&#125;</span><br><span class="line">fun.apply(<span class="literal">null</span>,<span class="number">1</span>) <span class="comment">//报错 TypeError: CreateListFromArrayLike called on non-object</span></span><br><span class="line">fun.apply(<span class="literal">null</span>,[<span class="number">1</span>])<span class="comment">// 1 undefined undefined</span></span><br><span class="line">fun.apply(<span class="literal">null</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// 1 2 3</span></span><br><span class="line">fun.call(<span class="literal">null</span>,<span class="number">1</span>,<span class="number">2</span>) <span class="comment">//1 2 undefied  </span></span><br></pre></td></tr></table></figure><ol start="3"><li>手动自己实现一个<code>bind</code>函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.testBind=<span class="function"><span class="keyword">function</span>(<span class="params">context,...args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...inArgs</span>)</span>&#123;</span><br><span class="line">    self.apply(context,[...args,...inArgs])  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj =&#123;</span><br><span class="line">  name:<span class="string">&#x27;testbind&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun =<span class="function"><span class="keyword">function</span>(<span class="params">...allArgs</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(allArgs) <span class="comment">// [1,2,3,4,5,6]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) <span class="comment">// testbind</span></span><br><span class="line">&#125;.testBind(obj,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">fun(<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><h3 id="闭包的运用"><a class="markdownIt-Anchor" href="#闭包的运用"></a> 闭包的运用</h3><ol><li>封装变量，延长变量的生命周期</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">fun2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    a++</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fun1();</span><br><span class="line"><span class="built_in">console</span>.log(f(),f(),f()) <span class="comment">// 2 3 4</span></span><br></pre></td></tr></table></figure><blockquote><p>会发现 f函数每次运行之后他的a变量生命并没有被销毁，下次运行时 a变量的值直接被记录了下来</p></blockquote><ul><li>封装变量，延长变量的生命周期的运用 js随机数的生成</li></ul>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildRandom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> seed =<span class="keyword">new</span> <span class="built_in">Date</span>().getTime(); <span class="comment">// 这边如果是常数 那么每次重新运行整个文件结果都一样单次运行函数不一样</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Robert Jenkins&#x27; 32 bit integer hash function.</span></span><br><span class="line">    seed = seed &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">    seed = ((seed + <span class="number">0x7ed55d16</span>) + (seed &lt;&lt; <span class="number">12</span>))  &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">    seed = ((seed ^ <span class="number">0xc761c23c</span>) ^ (seed &gt;&gt;&gt; <span class="number">19</span>)) &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">    seed = ((seed + <span class="number">0x165667b1</span>) + (seed &lt;&lt; <span class="number">5</span>))   &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">    seed = ((seed + <span class="number">0xd3a2646c</span>) ^ (seed &lt;&lt; <span class="number">9</span>))   &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">    seed = ((seed + <span class="number">0xfd7046c5</span>) + (seed &lt;&lt; <span class="number">3</span>))   &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">    seed = ((seed ^ <span class="number">0xb55a4f09</span>) ^ (seed &gt;&gt;&gt; <span class="number">16</span>)) &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="keyword">return</span> (seed &amp; <span class="number">0xfffffff</span>) / <span class="number">0x10000000</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> random = buildRandom()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(random())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>random</code> 函数每次运行结束<code>seed</code>变量并没有被销毁，依然存在于整体的生命中期中，继续影响下一次的seed的值</p></blockquote><ol start="2"><li>使用在函数缓存机制中 减少全局变量的污染。</li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function fun1() &#123;</span><br><span class="line">  let a &#x3D; 1</span><br><span class="line">  for (let i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">    a &#x3D; a + i</span><br><span class="line">  &#125;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let fun2 &#x3D; (function () &#123;</span><br><span class="line">  let cache &#x3D; &#123;&#125;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    let a &#x3D; 1</span><br><span class="line">    let args &#x3D; Array.prototype.join.call(arguments, &quot;&quot;)</span><br><span class="line">    if (cache[args]) &#123;</span><br><span class="line">      return cache[args]</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">      a &#x3D; a + i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cache[args] &#x3D; a;</span><br><span class="line">    return cache[args];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.time(&#39;nocache&#39;)</span><br><span class="line">for (let i &#x3D; 0; i &lt; 100000; i++) &#123;</span><br><span class="line">  fun1(1, 2, 3, 4, 5)</span><br><span class="line">&#125;</span><br><span class="line">console.timeEnd(&quot;nocache&quot;) &#x2F;&#x2F; 1276ms</span><br><span class="line"></span><br><span class="line">console.time(&#39;usecache&#39;)</span><br><span class="line">for (let i &#x3D; 0; i &lt; 100000; i++) &#123;</span><br><span class="line">  fun2(1, 2, 3, 4, 5)</span><br><span class="line">&#125;</span><br><span class="line">console.timeEnd(&#39;usecache&#39;) &#x2F;&#x2F;73ms</span><br></pre></td></tr></table></figure><blockquote><p>注意cache[args]的自身结果不能为false，如果cache[args]一直为false <code>return cache[args]</code>就不会运行</p></blockquote><h3 id="高阶函数函数式编程"><a class="markdownIt-Anchor" href="#高阶函数函数式编程"></a> 高阶函数|函数式编程</h3><blockquote><ol><li>函数作为参数传入</li><li>函数作为返回值输出</li><li>函数柯里化</li></ol></blockquote><p><strong>对于函数式编程这块后面肯定会有更详细的文章推出 <a href="http://blog.wangminwei.top">不迷路链接</a></strong></p><h3 id="柯里化"><a class="markdownIt-Anchor" href="#柯里化"></a> 柯里化</h3><blockquote><p>柯里化又称分部求值一个currying function 首先会接收一些参数，但是不会先求值，继续返货另一个函数，等到函数真正需要求值的时候之前传入的所有参数，会被一次性求值。</p></blockquote>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cost=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length ==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> money= args.reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a+b)</span><br><span class="line">      <span class="keyword">return</span> money</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      [].push.apply(args,<span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">cost(<span class="number">100</span>)</span><br><span class="line">cost(<span class="number">200</span>)</span><br><span class="line">cost(<span class="number">300</span>)</span><br><span class="line"><span class="built_in">console</span>.log(cost()) <span class="comment">// 600</span></span><br></pre></td></tr></table></figure><blockquote><p>调用cost函数的时候，如果明确的带上了一些参数，此时不会进行真正的求值运算，而是把这些参数保持起来，保存到<code>args</code>数组中，不传参时再进行求值运算。</p></blockquote><h3 id="函数节流"><a class="markdownIt-Anchor" href="#函数节流"></a> 函数节流</h3><blockquote><p>函数因某些事件被不停的高频调用;为防止高频调用导致性能消耗过大页面卡顿现象；需要限制函数在规定时间内被调用的次数</p></blockquote><ul><li><p>应用场景分析</p><p>浏览器<code>window.onresize</code>和<code>mousemove</code>事件,这两个事件带来的问题原理差不多,都是因为用户每一次操作这两个函数都会进行响应，比如前者用户改变一次浏览器窗口大小函数响应一次。这时候如果用户平滑的从左到右拖动来改变浏览器大小，函数就会不停的响应，如果用户一秒钟拖动慢一点拖动距离长一点；差不多函数可以响应30多次；这个对页面的性能损耗是巨大的；有时候我们往往不需要实时记录浏览器窗口大小，可能一秒钟记录一两次就行。</p></li></ul><h4 id="节流函数的实现"><a class="markdownIt-Anchor" href="#节流函数的实现"></a> 节流函数的实现</h4><ol><li>定时器实现延时函数实现节流</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn 接收要执行的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>interval 延迟的时间默认500毫秒即一秒钟只被执行2次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayFun</span>(<span class="params">fn: <span class="built_in">Function</span>, interval: <span class="built_in">number</span> = <span class="number">500</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer, intervalUse = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> _self = fn</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(timer)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      _self()</span><br><span class="line">      intervalUse = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;函数被执行&#x27;</span>)</span><br><span class="line">    &#125;, <span class="built_in">Number</span>(intervalUse &amp;&amp; interval))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Number(intervalUse &amp;&amp; interval)</code> 第一次调用不需要延迟,<br />即<code>intervalUse = false</code> 此时<code>Number(intervalUse &amp;&amp; interval)= 0</code> 函数立即执行;相反 如果这时候用户继续有操作;<code>intervalUse = true;Number(intervalUse &amp;&amp; interval)=interval</code> 定时器生效;用户操作被延迟</p></blockquote><blockquote><p>案例源码<a href="https://github.com/wmwgithub/blog-demo/blob/master/2019_11_6/1/onresize.html">GitHub链接</a></p></blockquote><p>可以看到设置<code>interval=1000</code>后在用户平滑的改变浏览器窗口大小时候函数每秒钟只执行了一次<br /><img src="http://blogimage.lemonlife.top/201911061432_908.png" alt="" /></p><ol start="2"><li>分时函数实现节流</li></ol><blockquote><p>上面一种方式针对于，用户频繁的操作，还有一种场景就是用户只操作一次，但是带来的函数的调用是成百上千次；比如用户点了加载数据按钮加载数据的时候，此时数据有上千条；一次性加载页面肯定会卡死甚至浏览器直接退出;这时候就需要分时加载；比如100ms加载10条这种方式;而不是在用户一点击就疯狂调用对应的函数</p></blockquote><ul><li>原始方法 页面出现长时间白屏</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array =[]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;=<span class="number">1000000</span>;i++)array.push(i);</span><br><span class="line"><span class="keyword">let</span> add=<span class="function">(<span class="params">array</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; array.length; index++) &#123;</span><br><span class="line">    <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    div.innerHTML =array[index]</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">add(array)</span><br></pre></td></tr></table></figure><ul><li>分时节流之后 数据缓慢加载出来但是基本无白屏现象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000000</span>; i++)array.push(i);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">array, times</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oneSize = <span class="built_in">Math</span>.floor(array.length / times);</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; oneSize; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">      div.innerHTML = array[count];</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">      count++;</span><br><span class="line">      <span class="keyword">if</span> (count === array.length) &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(add, <span class="number">40</span>);</span><br><span class="line">&#125;</span><br><span class="line">create(array,<span class="number">100</span>)</span><br></pre></td></tr></table></figure><blockquote><p>案例源码<a href="https://github.com/wmwgithub/blog-demo/blob/master/2019_11_6/2/index_timer.html">GitHub链接</a></p></blockquote><h3 id="惰性加载函数"><a class="markdownIt-Anchor" href="#惰性加载函数"></a> 惰性加载函数</h3><blockquote><p>Web开发中不同浏览器运行环境下不可避免的要进行一些适配操作，如果每次调用一个事件都通过<code>if else</code>来对不同的浏览器的解决方案，将会带来性能的损耗，可以把这写需要适配的函数抽离成惰性加载的方式来调用</p></blockquote><ul><li>第一版本 每次使用都要判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">    element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注意此处只是一个例子 window.attachEvent 这种IE专属的函数 很早就没人用了 可能IE自己现在都不用了</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">    <span class="keyword">return</span> element.attachEvent(<span class="string">&#x27;on&#x27;</span>+type, handler)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>稍作改进 浏览器代码加载的时候就给出结果只判断一次</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addEvent = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">        element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">        element.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, handler)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li>引入惰性加载的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>  addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">      addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">        element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">      addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">        element.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, handler)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addEvent(element, type, handler)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>对比第一个 函数每次运行都需要<code>if else</code>判断，肯定要消耗性能，对比第二个浏览器在加载代码时候要做函数运算延长了页面响应时间;第三种方式在第一次绑定事件的时候重写了绑定事件的方法，因此 只有在第一次 使用该函数的时候需要执行<code>if else</code>操作，与第二种方法不同的是，它把本来在浏览器加载代码所消耗的时间，转移到了函数第一次运行的时候，加快了页面的响应</p></blockquote><blockquote><p>案例源码<a href="https://github.com/wmwgithub/blog-demo/blob/master/2019_11_6/3/index.html">GitHub链接</a></p></blockquote><p><em>以上内容是我看完 JavaScript设计模式与开发实战 第一部分之后自己总结的，感谢曾(da)探(lao)</em></p><center><b>欢迎大家评论区交流</b></center>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git自动化部署项目</title>
      <link href="2019/08/02/git-hooks/"/>
      <url>2019/08/02/git-hooks/</url>
      
        <content type="html"><![CDATA[<h2 id="java-spring-boot-项目"><a class="markdownIt-Anchor" href="#java-spring-boot-项目"></a> Java spring boot 项目</h2><blockquote><p>使用git和docker 自动化部署spring boot 项目,默认一下流程用<code>root</code>身份进行，普通用户登录请在一些命令前加<code>sudo</code>;</p></blockquote><h3 id="git操作"><a class="markdownIt-Anchor" href="#git操作"></a> git操作</h3><ol><li>服务器上创建git仓库(假设仓库名称是times)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git inint --bare times.git</span><br><span class="line">chmod -R +777 times.git</span><br><span class="line">cd times.git&#x2F;hooks</span><br><span class="line">touch post-receive</span><br><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一些目录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir times.tmp</span><br><span class="line">mkdir times.work</span><br><span class="line">cd times.work</span><br><span class="line">touch .&#x2F;work-hooks</span><br><span class="line">chmod +x work-hooks</span><br></pre></td></tr></table></figure><ol start="3"><li>编写自动化脚本(post-receive文件)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> GIT_DIR</span><br><span class="line">GIT_DIR=/root/times.git</span><br><span class="line">WORK_DIR=/root/times.work</span><br><span class="line">TMP=/root/times.tmp</span><br><span class="line"><span class="comment"># 把times仓库里面的代码克隆到TMP临时目录</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="variable">$GIT_DIR</span> <span class="variable">$TMP</span></span><br><span class="line"><span class="comment"># 把临时文件复制到工作区文件夹</span></span><br><span class="line">\cp -rf <span class="variable">$&#123;TMP&#125;</span>/*  <span class="variable">$&#123;WORK_DIR&#125;</span>/</span><br><span class="line"><span class="comment"># 清除临时目录</span></span><br><span class="line">rm -rf <span class="variable">$&#123;TMP&#125;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$WORK_DIR</span></span><br><span class="line"><span class="comment">#执行工作区里面的工作脚本</span></span><br><span class="line">sudo ./work-hooks</span><br></pre></td></tr></table></figure><ol start="4"><li>编写工作文件夹里面的部署</li></ol><blockquote><p>即<code>times.work</code>文件夹下的<code>work-hooks</code>脚本</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#用maven打包项目</span></span><br><span class="line"><span class="comment">#mvn package</span></span><br><span class="line"><span class="comment">#跳过测试用例打包项目</span></span><br><span class="line">mvn  package  -Dmaven.skip.test=<span class="literal">true</span></span><br><span class="line"><span class="comment">#AR=$(pwd)/target/photos-0.0.1-SNAPSHOT.war</span></span><br><span class="line"><span class="comment">#docker 运行项目</span></span><br><span class="line"><span class="comment"># docker run -p 8080:8080 --name times-springboot -v /root/times.work/target/photos-0.0.1-SNAPSHOT.war:/photos-0.0.1-SNAPSHOT.war -d openjdk:8-jdk nohup  java -jar /photos-0.0.1-SNAPSHOT.war</span></span><br><span class="line"><span class="comment"># docker run -p 8080:8080 --name times-springboot -v /root/times.work/target/photos-0.0.1-SNAPSHOT.war:/photos-0.0.1-SNAPSHOT.war --link times-mysql:mysql   -d openjdk:8-jdk nohup  java -jar /photos-0.0.1-SNAPSHOT.war </span></span><br><span class="line">docker restart times-springboot</span><br></pre></td></tr></table></figure><h3 id="部署相关命令"><a class="markdownIt-Anchor" href="#部署相关命令"></a> 部署相关命令</h3><blockquote><p><code>cd /root/times.work</code> <code>vim</code>cd</p></blockquote><h3 id="推送代码到远程仓库"><a class="markdownIt-Anchor" href="#推送代码到远程仓库"></a> 推送代码到远程仓库</h3><ul><li>简单版本每次推送都需要输密码</li></ul><ol><li>本地代码仓库添加远程仓库<br /><code>git remote add aly-times root@106.15.179.33:/root/times.git</code></li><li>推送本地代码去远程仓库<br /><code>git push aly-times master</code>如果出现代码冲突推送不上可直接<code>git push -f aly-times master</code></li></ol><h3 id="常见问题和解决办法"><a class="markdownIt-Anchor" href="#常见问题和解决办法"></a> 常见问题和解决办法</h3><ol><li>报错<code>bash: ***:command not found</code><br />解决办法<a href="https://www.linuxidc.com/Linux/2012-07/66270.htm">参看链接</a><br /><img src="../../../../images/git-hooks/solution1.png" alt="链接内容" /></li></ol><h3 id="最后补充和本节内容无关的内容"><a class="markdownIt-Anchor" href="#最后补充和本节内容无关的内容"></a> 最后补充和本节内容无关的内容</h3><ol><li>后台运行spring boot项目<br /><code>nohup java -jar yourackage-version.jar &gt;temp.log &amp;</code></li></ol><blockquote><p>nohup – no hang up 意味保持执行不挂起之意。<br />&amp; – 表示在后台执行进程 ，与&amp;&amp; 不同，&amp;&amp;代表执行前后两条指令。<br />– 这个是Linux重定向的命令，可以理解为可以将命令行输出的日志等内容重定向到制定的文件如上指令中的temp.log文件中。Linux重定向指令还有&gt;&gt;该指令和&gt;的区别是，前者是追加写入，后者是覆盖写入。</p></blockquote><p><a href="https://blog.csdn.net/yanJunit/article/details/77728338">参看链接</a></p><ol start="2"><li>停止运行的项目</li></ol><ul><li>通过运行<code>war</code>包名称查找进程id <code>ps -ef|grep jenkins.war</code>  (jenkins.war,运行时运行的war包)</li><li>或者 通过程序运行端口查找进程id 【Linux】 <code>netstat -nlp |grep 8080</code> 【Windows】<code>netstat -ano|findstr 8080</code></li><li>结束对应进程 【Linux】 <code>kill 7832 pid</code> 【Windows】<code>taskkill -F -PID 7832</code>   (7832,进程id)</li></ul><p><a href="https://blog.csdn.net/qq_38950013/article/details/95163962">参看链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用方法</title>
      <link href="2019/07/30/git-use-method/"/>
      <url>2019/07/30/git-use-method/</url>
      
        <content type="html"><![CDATA[<h2 id="安装git"><a class="markdownIt-Anchor" href="#安装git"></a> 安装Git</h2><ul><li>Windows安装git,直接搜索git下载安装就好了</li><li>Linux(ubuntu系列)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git </span><br></pre></td></tr></table></figure><ul><li><p>Linux(Centos)</p><p>自己的仓库地址里面有简单的一键安装脚本 <a href="https://github.com/wmwgithub/shell">git-centos.sh</a></p></li></ul><h2 id="码云gitee配置ssh密钥"><a class="markdownIt-Anchor" href="#码云gitee配置ssh密钥"></a> 码云(gitee)配置ssh密钥</h2><ul><li>见网友的<a href="https://www.jianshu.com/p/416ac815b2b1">简书连接</a></li></ul><h2 id="在仓库里面创建新分支"><a class="markdownIt-Anchor" href="#在仓库里面创建新分支"></a> 在仓库里面创建新分支</h2><ol><li>登录码云找到仓库<br /><img src="../../../../images/git-use-method/address.png" alt="复制仓库地址" /></li><li>下载代码到本地<br /><img src="../../../../images/git-use-method/gitclone.png" alt="git clone" /></li><li>创建新的分支</li></ol><blockquote><p>创建一个含有自己名字字母缩写的新分支<br /><img src="../../../../images/git-use-method/gitcheckout.png" alt="git checkout" /></p></blockquote><ol start="4"><li>提交代码</li></ol><blockquote><p><a href="http://xn--README-9m7i2cw9qpnh84qhzzh.md">随便修改一下README.md</a> 文件然后进行 <code>add</code> <code>commit</code> <code>push</code> 流程;主要提交的分支一定是刚刚自己创建的分支不允许提交到master或者他人分支<br /><img src="../../../../images/git-use-method/push.png" alt="git push" /></p></blockquote><ol start="5"><li>提交成功的样子</li></ol><blockquote><p>点一下那个master除了<code>master</code>分支和我刚刚创建的 <code>dev-wmw</code>看到自己的分支说明成功<br /><img src="../../../../images/git-use-method/success.png" alt="提交成功" />、</p></blockquote><h2 id="最后不做要求"><a class="markdownIt-Anchor" href="#最后不做要求"></a> 最后不做要求</h2><blockquote><p>写代码有代码规范提交代码也有<code>git commit</code>规范</p></blockquote><ul><li>我觉得比较常用的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">feat：新功能（feature）</span><br><span class="line">fix：修补bug</span><br><span class="line">docs：文档（documentation）</span><br><span class="line">style： 格式（不影响代码运行的变动）</span><br><span class="line">refactor：重构（即不是新增功能，也不是修改bug的代码变动）</span><br><span class="line">test：增加测试</span><br><span class="line">chore：构建过程或辅助工具的变动</span><br></pre></td></tr></table></figure><ul><li><p>网络上比较全的规范</p><p><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">阮一峰的网络日志:Commit message</a><br /><a href="https://segmentfault.com/a/1190000009048911">未知名网友在segmentfault上的帖子</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建过程</title>
      <link href="2019/07/27/init/"/>
      <url>2019/07/27/init/</url>
      
        <content type="html"><![CDATA[<h2 id="安装hexo环境默认winddows-macos和linux自行搜索如何安装nodejs"><a class="markdownIt-Anchor" href="#安装hexo环境默认winddows-macos和linux自行搜索如何安装nodejs"></a> 安装Hexo环境(默认winddows MacOS和Linux自行搜索如何安装Node.JS)</h2><blockquote><p>当然要安装其他博客主题或者基于GitHub构建博客不可或缺的工具就是<a href="https://git-scm.com/">Git</a>这个管理工具,所以建议先安装Git</p></blockquote><blockquote><p>Hexo基于JavaScript,采用npm包管理器管理插件,安装Hexo需要先安装<a href="https://nodejs.org/zh-cn/download/">npm</a>和<a href="https://nodejs.org/zh-cn/download/">Node.JS</a>;推荐下载LTS版本的Node.JS。</p></blockquote><ul><li><code>cmd</code>中运行命令<code>git --version</code> <code>node -v</code> <code>npm -v</code> 出现对应的版本号说明安装成功</li><li><code>cmd</code> 运行命令 <code>npm install hexo-cli -g</code> 安装Hexo脚手架工具,可参看官网<a href="https://hexo.io/zh-cn/docs/">概述</a>,<a href="https://hexo.io/zh-cn/docs/setup">建站</a>的过程</li><li>例如</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo  init test</span><br><span class="line">cd test</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p><img src="http://blogimage.lemonlife.top/201910301359_423.png" alt="安装Hexo" /></p><h2 id="安装主题"><a class="markdownIt-Anchor" href="#安装主题"></a> 安装主题</h2><blockquote><p>我选择的是melody个人觉得这款主题真的很好看用起来也很方便。<a href="https://github.com/Molunerfinn/hexo-theme-melody/tree/fca917dd321bcda46b2a7dcddcf18cbe408cff18">主题GitHub地址</a></p></blockquote><ul><li>例如(首先保障一下命令都是在上一步创建的test文件夹里面的)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https:&#x2F;&#x2F;github.com&#x2F;Molunerfinn&#x2F;hexo-theme-melody themes&#x2F;melody</span><br><span class="line">npm install hexo-renderer-jade hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p><img src="http://blogimage.lemonlife.top/201910302300_80.png?/" alt="安装主题" /></p><ul><li>修改配置文件，使用先安装的主题</li></ul><p>修改test文件夹里面的<code>_config.yml</code>的文件的<code>theme landspcape</code>改成<code>theme melody</code>然后运行<code>hexo server</code>启动项目<br /><img src="http://blogimage.lemonlife.top/201910302301_62.png?/" alt="修改配置文件" /></p><h2 id="创建新帖子"><a class="markdownIt-Anchor" href="#创建新帖子"></a> 创建新帖子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure><h2 id="帖子打包发布到github"><a class="markdownIt-Anchor" href="#帖子打包发布到github"></a> 帖子打包发布到GitHub</h2><blockquote><p>首先确保自己电脑的GitHub ssh秘钥已经配置正确</p></blockquote><ul><li>先运行 <code>npm install hexo-deployer-git --save</code> 安装插件</li><li>修改<code>_config.yml</code>文件，在文件添加</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: GitHub地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><ul><li>运行 <code>hexo generate</code> 生成部署文件到public文件夹</li><li>运行 <code>hexo deploy</code> 部署到相应的仓库</li></ul><!-- > 注意下次部署 可以直接运行 `hexo generate` 然后到`.deploy_git`目录中手动提交 --><h2 id="添加评论功能"><a class="markdownIt-Anchor" href="#添加评论功能"></a> 添加评论功能</h2><ol><li>进入主题的插件管理网站的<a href="https://molunerfinn.com/hexo-theme-melody-doc/third-party-support.html#comments">评论插件展示版块</a>,这边有很多评论版块，我使用的是<code>Gittalk</code></li><li>如果使用GitHub相关评论工具需要在 <a href="https://github.com/settings/applications/new">GitHub官网</a>注册一个 OAuth application <code>Homepage URL</code>和 <code>Authorization callback URL</code>都可填你的博客域名,其他评论工具我没有使用过</li><li>修改 <code>source/_data/melody.yml</code>文件，其中<code>client_id client_secret</code> 字段是之前注册生成的 <code>admin</code>字段就写自己的GitHub名字(数组形式：[‘张三’]) 如果博客是共同管理的把其他成员也写进去即可：[‘张三’,‘李四’]。</li></ol><h2 id="写在最后"><a class="markdownIt-Anchor" href="#写在最后"></a> 写在最后</h2><blockquote><p>更多melody主题的用法，参看<a href="https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/">中文文档</a>;最后再次感谢一下melody的作者</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 搭建博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法[转载]</title>
      <link href="2019/07/27/rank-method/"/>
      <url>2019/07/27/rank-method/</url>
      
        <content type="html"><![CDATA[<h3 id="1-基本介绍"><a class="markdownIt-Anchor" href="#1-基本介绍"></a> 1、基本介绍</h3><p>​排序算法比较基础，但是设计到很多计算机科学的想法，如下：</p><p>​1、比较和非比较的策略</p><p>​2、迭代和递归的实现</p><p>​3、分而治之思想</p><p>​4、最佳、最差、平均情况时间复杂度分析</p><p>​5、随机算法</p><h3 id="2-排序算法的分类"><a class="markdownIt-Anchor" href="#2-排序算法的分类"></a> 2、排序算法的分类</h3><h4 id="算法分类"><a class="markdownIt-Anchor" href="#算法分类"></a> 算法分类</h4><p><img src="http://blogimage.lemonlife.top/201909181100_29.jpg?/" alt="" /></p><h4 id="算法总结"><a class="markdownIt-Anchor" href="#算法总结"></a> 算法总结</h4><p><img src="http://blogimage.lemonlife.top/201909181101_243.jpg?/" alt="" /></p><h3 id="3-冒泡排序"><a class="markdownIt-Anchor" href="#3-冒泡排序"></a> 3、冒泡排序</h3><h4 id="1冒泡排序的介绍"><a class="markdownIt-Anchor" href="#1冒泡排序的介绍"></a> （1）冒泡排序的介绍</h4><p>​冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h4 id="2冒泡排序的原理"><a class="markdownIt-Anchor" href="#2冒泡排序的原理"></a> （2）冒泡排序的原理：</h4><p>​1、如果元素大小关系不正确，交换这两个数（在本例中为a&gt; b），</p><p>​2、比较一对相邻元素（a，b），</p><p>​3、重复步骤1和2，直到我们到达数组的末尾（最后一对是第（N-2）和（N-1）项，因为我们的数组从零开始）</p><p>​4、到目前为止，最大的元素将在最后的位置。 然后我们将N减少1，并重复步骤1，直到N = 1。</p><h4 id="3动图演示"><a class="markdownIt-Anchor" href="#3动图演示"></a> （3）动图演示</h4><p><img src="http://blogimage.lemonlife.top/201909181101_1.jpg?/" alt="" /></p><h4 id="4代码演示"><a class="markdownIt-Anchor" href="#4代码演示"></a> （4）代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> array[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    t = array[j];</span><br><span class="line">                    array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>JavaScript实现</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">method(arr: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">        [arr[i], arr[j]] = [arr[j], arr[i]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-选择排序"><a class="markdownIt-Anchor" href="#4-选择排序"></a> 4、选择排序</h3><h4 id="1选择排序的介绍"><a class="markdownIt-Anchor" href="#1选择排序的介绍"></a> （1）选择排序的介绍</h4><p>​选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h4 id="2选择排序的原理"><a class="markdownIt-Anchor" href="#2选择排序的原理"></a> （2）选择排序的原理</h4><p>​1、在 <strong>[L … N-1]</strong> 范围内找出最小项目 <strong>X</strong> 的位置，</p><p>​2、用第 <strong>L</strong> 项交换X，</p><p>​3、将下限 <strong>L</strong> 增加1并重复步骤1直到 <strong>L = N-2</strong>。</p><h4 id="3动态图演示"><a class="markdownIt-Anchor" href="#3动态图演示"></a> （3）动态图演示</h4><p><img src="http://blogimage.lemonlife.top/201909181102_996.jpg?/" alt="" /></p><h4 id="4代码演示-2"><a class="markdownIt-Anchor" href="#4代码演示-2"></a> （4）代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; array[index]) </span><br><span class="line">                    index = j; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = array[index];</span><br><span class="line">            array[index] = array[i];</span><br><span class="line">            array[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>JavaScript实现</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">method(arr: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> min = arr[i], minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (min &gt; arr[j]) &#123;</span><br><span class="line">        <span class="comment">// 每轮循环都获取到最小值</span></span><br><span class="line">        min = arr[j]</span><br><span class="line">        minIndex = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定最小值之后 再进行交换</span></span><br><span class="line">    arr[minIndex] = arr[i]</span><br><span class="line">    arr[i] = min</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-插入排序"><a class="markdownIt-Anchor" href="#5-插入排序"></a> 5、插入排序</h3><h4 id="1插入排序的介绍"><a class="markdownIt-Anchor" href="#1插入排序的介绍"></a> （1）插入排序的介绍</h4><p>​插入排序（Insertion sort）是一种简单直观且稳定的排序算法。如果有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p><h4 id="2插入排序的原理"><a class="markdownIt-Anchor" href="#2插入排序的原理"></a> （2）插入排序的原理</h4><p>​1、从第一个元素开始，该元素可以认为已经被排序；</p><p>​2、取出下一个元素，在已经排序的元素序列中从后向前扫描；</p><p>​3、如果该元素（已排序）大于新元素，将该元素移到下一位置；</p><p>​4、重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</p><p>​5、将新元素插入到该位置后；</p><p>​6、重复步骤2~5。</p><h4 id="3动态图演示-2"><a class="markdownIt-Anchor" href="#3动态图演示-2"></a> （3）动态图演示</h4><p><img src="http://blogimage.lemonlife.top/201909181102_303.jpg?/" alt="插入排序" /></p><h4 id="4代码演示-3"><a class="markdownIt-Anchor" href="#4代码演示-3"></a> （4）代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> current;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            current = array[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> preIndex = i;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; current &lt; array[preIndex]) &#123;</span><br><span class="line">                array[preIndex + <span class="number">1</span>] = array[preIndex];</span><br><span class="line">                preIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>JavaScript代码实现</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">method(arr: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">let</span> resArr = [arr[<span class="number">0</span>]]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> insertIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (insertIndex &lt; resArr.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (resArr[insertIndex] &lt; arr[i]) &#123;</span><br><span class="line">        insertIndex++</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resArr.splice(insertIndex, <span class="number">0</span>, arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-归并排序"><a class="markdownIt-Anchor" href="#6-归并排序"></a> 6、归并排序</h3><h4 id="1归并排序的介绍"><a class="markdownIt-Anchor" href="#1归并排序的介绍"></a> （1）归并排序的介绍</h4><p>​归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><h4 id="2归并排序的原理"><a class="markdownIt-Anchor" href="#2归并排序的原理"></a> （2）归并排序的原理</h4><p>​1、将每对单个元素（默认情况下，已排序）归并为2个元素的有序数组，</p><p>​2、将2个元素的每对有序数组归并成4个元素的有序数组，重复这个过程…，</p><p>​3、最后一步：归并2个N / 2元素的排序数组（为了简化讨论，我们假设N是偶数）以获得完全排序的N个元素数组。</p><h4 id="3动态图演示-3"><a class="markdownIt-Anchor" href="#3动态图演示-3"></a> （3）动态图演示</h4><p><img src="http://blogimage.lemonlife.top/201909181103_140.jpg?/" alt="" /></p><h4 id="4代码演示-4"><a class="markdownIt-Anchor" href="#4代码演示-4"></a> （4）代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] MergeSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">       <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> array;</span><br><span class="line">       <span class="keyword">int</span> mid = array.length / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">int</span>[] left = Arrays.copyOfRange(array, <span class="number">0</span>, mid);</span><br><span class="line">       <span class="keyword">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class="line">       <span class="keyword">return</span> merge(MergeSort(left), MergeSort(right));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line">       <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>; index &lt; result.length; index++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i &gt;= left.length)</span><br><span class="line">               result[index] = right[j++];</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= right.length)</span><br><span class="line">               result[index] = left[i++];</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (left[i] &gt; right[j])</span><br><span class="line">               result[index] = right[j++];</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               result[index] = left[i++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="7-快速排序"><a class="markdownIt-Anchor" href="#7-快速排序"></a> 7、快速排序</h3><h4 id="1快速排序的介绍"><a class="markdownIt-Anchor" href="#1快速排序的介绍"></a> （1）快速排序的介绍</h4><p>​快速排序（Quicksort）是对冒泡排序的一种改进。</p><p>​它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h4 id="2快速排序的原理"><a class="markdownIt-Anchor" href="#2快速排序的原理"></a> （2）快速排序的原理</h4><p>​1、从数列中挑出一个元素，称为 “基准”（pivot）；<br />​2、重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br />​3、递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><h4 id="3动态图演示-4"><a class="markdownIt-Anchor" href="#3动态图演示-4"></a> （3）动态图演示</h4><p><img src="http://blogimage.lemonlife.top/201909181103_889.jpg?/" alt="" /></p><h4 id="4代码演示-5"><a class="markdownIt-Anchor" href="#4代码演示-5"></a> （4）代码演示</h4><p><strong>Java</strong>  实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] QuickSort(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length &lt; <span class="number">1</span> || start &lt; <span class="number">0</span> || end &gt;= array.length || start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> smallIndex = partition(array, start, end);</span><br><span class="line">        <span class="keyword">if</span> (smallIndex &gt; start)</span><br><span class="line">            QuickSort(array, start, smallIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (smallIndex &lt; end)</span><br><span class="line">            QuickSort(array, smallIndex + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序算法——partition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = (<span class="keyword">int</span>) (start + Math.random() * (end - start + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> smallIndex = start - <span class="number">1</span>;</span><br><span class="line">        swap(array, pivot, end);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt;= array[end]) &#123;</span><br><span class="line">                smallIndex++;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; smallIndex)</span><br><span class="line">                    swap(array, i, smallIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> smallIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换数组内两个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>JavaScript实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr: any[], left: number, right: number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> l = left <span class="comment">// 左索引</span></span><br><span class="line">    <span class="keyword">let</span> r = right <span class="comment">// 右索引</span></span><br><span class="line">    <span class="keyword">let</span> pivot = arr[<span class="built_in">Math</span>.floor((l + r) / <span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="comment">//中线 在左边找 到一个比中间值大的值</span></span><br><span class="line">    <span class="keyword">while</span> (arr[l] &lt; pivot) &#123;</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在中线右边找 比中间值小到值</span></span><br><span class="line">    <span class="keyword">while</span> (arr[r] &gt; pivot) &#123;</span><br><span class="line">        r -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="comment">// 说明 左边都是比中值小的值 ，右边都是比中值大的值</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// l&lt;r的时候交换 索引 l,r 对应的值</span></span><br><span class="line">    [arr[l], arr[r]] = [arr[r], arr[l]]</span><br><span class="line">    <span class="keyword">if</span> (arr[l] == pivot || arr[r] == pivot) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line">        r -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; r) &#123;</span><br><span class="line">        quickSort(arr, left, r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt; l) &#123;</span><br><span class="line">        quickSort(arr, l, right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-希尔排序"><a class="markdownIt-Anchor" href="#8-希尔排序"></a> 8、希尔排序</h3><h4 id="1希尔排序的介绍"><a class="markdownIt-Anchor" href="#1希尔排序的介绍"></a> （1）希尔排序的介绍</h4><p>​希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。</p><p>​希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><h4 id="2希尔排序的原理"><a class="markdownIt-Anchor" href="#2希尔排序的原理"></a> （2）希尔排序的原理</h4><p>​1、选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；<br />​2、按增量序列个数k，对序列进行k 趟排序；<br />​3、每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><h4 id="3动态图演示-5"><a class="markdownIt-Anchor" href="#3动态图演示-5"></a> （3）动态图演示</h4><p><img src="http://blogimage.lemonlife.top/201909181103_203.jpg?/" alt="" /></p><h4 id="4代码演示-6"><a class="markdownIt-Anchor" href="#4代码演示-6"></a> （4）代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 希尔排序</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ShellSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">       <span class="keyword">int</span> len = array.length;</span><br><span class="line">       <span class="keyword">int</span> temp, gap = len / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">               temp = array[i];</span><br><span class="line">               <span class="keyword">int</span> preIndex = i - gap;</span><br><span class="line">               <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; array[preIndex] &gt; temp) &#123;</span><br><span class="line">                   array[preIndex + gap] = array[preIndex];</span><br><span class="line">                   preIndex -= gap;</span><br><span class="line">               &#125;</span><br><span class="line">               array[preIndex + gap] = temp;</span><br><span class="line">           &#125;</span><br><span class="line">           gap /= <span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> array;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>JavaScript 实现希尔排序的交换模式,因为交换很耗时</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">method(arr: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">    <span class="keyword">let</span> offSet = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> (offSet &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= arr.length - offSet; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; arr.length - offSet; j += offSet) &#123;</span><br><span class="line">          <span class="keyword">if</span> (arr[j] &gt; arr[j + offSet]) &#123;</span><br><span class="line">            [arr[j], arr[j + offSet]] = [arr[j + offSet], arr[j]]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      offSet = <span class="built_in">Math</span>.floor(offSet / <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>JavaScript 实现希尔排序的移位模式</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">method(arr: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">let</span> offSet = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">while</span> (offSet &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(&#x27;此轮offset为&#x27;, offSet)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length - offSet; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> min = arr[i], <span class="attr">minIndex</span>: <span class="built_in">number</span> = i</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; arr.length; j += offSet) &#123;</span><br><span class="line">        <span class="comment">// 修改查找方法 为 类选择排序</span></span><br><span class="line">        <span class="comment">//开始查找最小的index</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; min) &#123;</span><br><span class="line">          min = arr[j]</span><br><span class="line">          minIndex = j</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[minIndex] = arr[i]</span><br><span class="line">      arr[i] = min</span><br><span class="line">    &#125;</span><br><span class="line">    offSet = <span class="built_in">Math</span>.floor(offSet / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-计数排序"><a class="markdownIt-Anchor" href="#9-计数排序"></a> 9、计数排序</h3><h4 id="1计数排序的介绍"><a class="markdownIt-Anchor" href="#1计数排序的介绍"></a> （1）计数排序的介绍</h4><p>​计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br />​计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p><h4 id="2计数排序的原理"><a class="markdownIt-Anchor" href="#2计数排序的原理"></a> （2）计数排序的原理</h4><p>​1、找出待排序的数组中最大和最小的元素；<br />​2、统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br />​3、对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br />​4、反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p><h4 id="3动态图演示-6"><a class="markdownIt-Anchor" href="#3动态图演示-6"></a> （3）动态图演示</h4><p><img src="http://blogimage.lemonlife.top/201909181104_130.jpg?/" alt="" /></p><h4 id="4代码演示-7"><a class="markdownIt-Anchor" href="#4代码演示-7"></a> （4）代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计数排序</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] CountingSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">       <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span> array;</span><br><span class="line">       <span class="keyword">int</span> bias, min = array[<span class="number">0</span>], max = array[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (array[i] &gt; max)</span><br><span class="line">               max = array[i];</span><br><span class="line">           <span class="keyword">if</span> (array[i] &lt; min)</span><br><span class="line">               min = array[i];</span><br><span class="line">       &#125;</span><br><span class="line">       bias = <span class="number">0</span> - min;</span><br><span class="line">       <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">       Arrays.fill(bucket, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">           bucket[array[i] + bias]++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (index &lt; array.length) &#123;</span><br><span class="line">           <span class="keyword">if</span> (bucket[i] != <span class="number">0</span>) &#123;</span><br><span class="line">               array[index] = i - bias;</span><br><span class="line">               bucket[i]--;</span><br><span class="line">               index++;</span><br><span class="line">           &#125; <span class="keyword">else</span></span><br><span class="line">               i++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> array;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>JavaScript实现</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">findMinMax(arr: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">let</span> minMax = [arr[<span class="number">0</span>], arr[<span class="number">0</span>]]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (minMax[<span class="number">0</span>] &gt; arr[i]) minMax[<span class="number">0</span>] = arr[i];</span><br><span class="line">    <span class="keyword">if</span> (minMax[<span class="number">1</span>] &lt; arr[i]) minMax[<span class="number">1</span>] = arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> minMax</span><br><span class="line">&#125;</span><br><span class="line">method(arr: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">let</span> [min, max] = <span class="built_in">this</span>.findMinMax(arr)</span><br><span class="line">  <span class="keyword">let</span> countArr = <span class="keyword">new</span> <span class="built_in">Array</span>(max - min + <span class="number">1</span>)</span><br><span class="line">  arr.map(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    countArr[value - min] ? countArr[value - min] += <span class="number">1</span> : countArr[value - min] = <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  arr = []</span><br><span class="line">  countArr.map(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (value &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      arr.push(min + index)</span><br><span class="line">      value--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-桶排序"><a class="markdownIt-Anchor" href="#10-桶排序"></a> 10、桶排序</h3><h4 id="1桶排序的介绍"><a class="markdownIt-Anchor" href="#1桶排序的介绍"></a> （1）桶排序的介绍</h4><p>​桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。</p><h4 id="2桶排序的原理"><a class="markdownIt-Anchor" href="#2桶排序的原理"></a> （2）桶排序的原理</h4><p>​1、设置一个定量的数组当作空桶；<br />​2、遍历输入数据，并且把数据一个一个放到对应的桶里去；<br />​3、对每个不是空的桶进行排序；<br />​4、从不是空的桶里把排好序的数据拼接起来。</p><h4 id="3动态图演示-7"><a class="markdownIt-Anchor" href="#3动态图演示-7"></a> （3）动态图演示</h4><p><img src="http://blogimage.lemonlife.top/201909181104_316.jpg?/" alt="" /></p><h4 id="4代码演示-8"><a class="markdownIt-Anchor" href="#4代码演示-8"></a> （4）代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 桶排序</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bucketSize</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">BucketSort</span><span class="params">(ArrayList&lt;Integer&gt; array, <span class="keyword">int</span> bucketSize)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.size() &lt; <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span> array;</span><br><span class="line">       <span class="keyword">int</span> max = array.get(<span class="number">0</span>), min = array.get(<span class="number">0</span>);</span><br><span class="line">       <span class="comment">// 找到最大值最小值</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (array.get(i) &gt; max)</span><br><span class="line">               max = array.get(i);</span><br><span class="line">           <span class="keyword">if</span> (array.get(i) &lt; min)</span><br><span class="line">               min = array.get(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> bucketCount = (max - min) / bucketSize + <span class="number">1</span>;</span><br><span class="line">       ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketCount);</span><br><span class="line">       ArrayList&lt;Integer&gt; resultArr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">           bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">           bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (bucketSize == <span class="number">1</span>) &#123; </span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketArr.get(i).size(); j++)</span><br><span class="line">                   resultArr.add(bucketArr.get(i).get(j));</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (bucketCount == <span class="number">1</span>)</span><br><span class="line">                   bucketSize--;</span><br><span class="line">               ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp.size(); j++)</span><br><span class="line">                   resultArr.add(temp.get(j));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> resultArr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="11-基数排序"><a class="markdownIt-Anchor" href="#11-基数排序"></a> 11、基数排序</h3><h4 id="1基数排序的介绍"><a class="markdownIt-Anchor" href="#1基数排序的介绍"></a> （1）基数排序的介绍</h4><p>​基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；<br />​基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的</p><h4 id="2基数排序的原理"><a class="markdownIt-Anchor" href="#2基数排序的原理"></a> （2）基数排序的原理</h4><p>​1、取得数组中的最大数，并取得位数；<br />​2、arr为原始数组，从最低位开始取每个位组成radix数组；<br />​3、对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p><h4 id="3动态图演示-8"><a class="markdownIt-Anchor" href="#3动态图演示-8"></a> （3）动态图演示</h4><p><img src="http://blogimage.lemonlife.top/201909181104_775.jpg?/" alt="" /></p><h4 id="4代码演示-9"><a class="markdownIt-Anchor" href="#4代码演示-9"></a> （4）代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 基数排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] RadixSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">       <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span> array;</span><br><span class="line">       <span class="comment">// 1.先算出最大数的位数；</span></span><br><span class="line">       <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">           max = Math.max(max, array[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> maxDigit = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">           max /= <span class="number">10</span>;</span><br><span class="line">           maxDigit++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> mod = <span class="number">10</span>, div = <span class="number">1</span>;</span><br><span class="line">       ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">           bucketList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, mod *= <span class="number">10</span>, div *= <span class="number">10</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">               <span class="keyword">int</span> num = (array[j] % mod) / div;</span><br><span class="line">               bucketList.get(num).add(array[j]);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketList.size(); j++) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketList.get(j).size(); k++)</span><br><span class="line">                   array[index++] = bucketList.get(j).get(k);</span><br><span class="line">               bucketList.get(j).clear();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> array;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>JavaScript实现</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">method(arr: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="comment">//定义10个装数的桶</span></span><br><span class="line">  <span class="keyword">let</span> bucket = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    bucket[i] = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取出个位数做 放入桶中</span></span><br><span class="line">  arr = arr.filter(<span class="function"><span class="params">value</span> =&gt;</span> &#123; bucket[value % <span class="number">10</span>].push(value) &#125;)</span><br><span class="line">  bucket.map(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      arr.push(value.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 取出 10位数 放桶中</span></span><br><span class="line">  arr = arr.filter(<span class="function"><span class="params">value</span> =&gt;</span> &#123; bucket[<span class="built_in">Math</span>.floor((value / <span class="number">10</span>)) % <span class="number">10</span>].push(value) &#125;)</span><br><span class="line">  bucket.map(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      arr.push(value.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 取出百位数 放入桶中</span></span><br><span class="line">  arr = arr.filter(<span class="function"><span class="params">value</span> =&gt;</span> &#123; bucket[<span class="built_in">Math</span>.floor((value / <span class="number">100</span>)) % <span class="number">10</span>].push(value) &#125;)</span><br><span class="line">  bucket.map(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      arr.push(value.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-堆排序"><a class="markdownIt-Anchor" href="#12-堆排序"></a> 12、堆排序</h3><h4 id="1堆排序的介绍"><a class="markdownIt-Anchor" href="#1堆排序的介绍"></a> （1）堆排序的介绍</h4><p>​堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="2堆排序的原理"><a class="markdownIt-Anchor" href="#2堆排序的原理"></a> （2）堆排序的原理</h4><p>​1、将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br />​2、将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br />​3、由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p><h4 id="3动态图演示-9"><a class="markdownIt-Anchor" href="#3动态图演示-9"></a> （3）动态图演示</h4><p><img src="http://blogimage.lemonlife.top/201909181105_568.jpg?/" alt="" /></p><h4 id="4代码演示-10"><a class="markdownIt-Anchor" href="#4代码演示-10"></a> （4）代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明全局变量，用于记录数组array的长度；</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] HeapSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        len = array.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">1</span>) <span class="keyword">return</span> array;</span><br><span class="line">        <span class="comment">//1.构建一个最大堆</span></span><br><span class="line">        buildMaxHeap(array);</span><br><span class="line">        <span class="comment">//2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆</span></span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(array, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">            len--;</span><br><span class="line">            adjustHeap(array, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立最大堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从最后一个非叶子节点开始向上构造最大堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (len/<span class="number">2</span> - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line">            adjustHeap(array, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整使之成为最大堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = i;</span><br><span class="line">        <span class="comment">//如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span></span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">2</span> &lt; len &amp;&amp; array[i * <span class="number">2</span>] &gt; array[maxIndex])</span><br><span class="line">            maxIndex = i * <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//如果有右子树，且右子树大于父节点，则将最大指针指向右子树</span></span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt; len &amp;&amp; array[i * <span class="number">2</span> + <span class="number">1</span>] &gt; array[maxIndex])</span><br><span class="line">            maxIndex = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex != i) &#123;</span><br><span class="line">            swap(array, maxIndex, i);</span><br><span class="line">            adjustHeap(array, maxIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>JavaScript 实现基本堆排序</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.val = val</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个变量存放二叉搜索树</span></span><br><span class="line">    <span class="built_in">this</span>.tree = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.tree == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.tree = <span class="keyword">new</span> TreeNode(val)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pTree = <span class="built_in">this</span>.tree <span class="comment">// 存一下指针</span></span><br><span class="line">    <span class="keyword">while</span> (pTree != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 开始执行插入的流程</span></span><br><span class="line">      <span class="keyword">if</span> (pTree.val &gt;= val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pTree.left == <span class="literal">null</span>) &#123;</span><br><span class="line">          pTree.left = <span class="keyword">new</span> TreeNode(val)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        pTree = pTree.left</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pTree.right == <span class="literal">null</span>) &#123;</span><br><span class="line">          pTree.right = <span class="keyword">new</span> TreeNode(val)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        pTree = pTree.right</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inOrder</span>(<span class="params">tree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tree == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  inOrder(tree.left)</span><br><span class="line">  <span class="built_in">console</span>.log(tree.val)</span><br><span class="line">  inOrder(tree.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> heapSort = <span class="keyword">new</span> HeapSort()</span><br><span class="line"><span class="keyword">let</span> testArray = [<span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line">testArray.map(<span class="function"><span class="params">value</span> =&gt;</span> heapSort.insert(value))</span><br><span class="line">inOrder(heapSort.tree) <span class="comment">// 1 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure><h3 id="最后总结"><a class="markdownIt-Anchor" href="#最后总结"></a> 最后总结</h3><p>不同的排序算法有不同的应用场景,一般情况下如果数据都是正数，可以考虑采用基数排序，计数排序，桶排序之类的排序算法。其中计数排序算是最耗费空间的了，也是拿空间换时间最明显的那个😁</p><blockquote><p>博客中中JavaScript部分是我自己写的,Java和文字引用于马老师,<em>马士兵教育公开课</em>。JS部分<a href="https://github.com/wmwgithub/typescript-design-mode/tree/master/src/sort">源码</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
